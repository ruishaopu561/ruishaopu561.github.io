<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>GAMES101_学习笔记 | Shaopu Rui</title><meta name="description" content="Computer Graphics课程视频 学习新知识的方式：Why, What and How Lecture3. Transformation2D变换 缩放矩阵(Scale) \left[ \begin{matrix}  x&#39; \\ y&#39; \end{matrix} \right] &#x3D; \left[ \begin{matrix}  s_x &amp; 0 \\  0 &amp; s_y \end{matrix}"><meta name="keywords" content="笔记"><meta name="author" content="Shaopu Rui"><meta name="copyright" content="Shaopu Rui"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="GAMES101_学习笔记"><meta name="twitter:description" content="Computer Graphics课程视频 学习新知识的方式：Why, What and How Lecture3. Transformation2D变换 缩放矩阵(Scale) \left[ \begin{matrix}  x&#39; \\ y&#39; \end{matrix} \right] &#x3D; \left[ \begin{matrix}  s_x &amp; 0 \\  0 &amp; s_y \end{matrix}"><meta name="twitter:image" content="http://ruishaopu561.github.io/img/cover/games101.webp"><meta property="og:type" content="article"><meta property="og:title" content="GAMES101_学习笔记"><meta property="og:url" content="http://ruishaopu561.github.io/2020/06/19/GAMES101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="Shaopu Rui"><meta property="og:description" content="Computer Graphics课程视频 学习新知识的方式：Why, What and How Lecture3. Transformation2D变换 缩放矩阵(Scale) \left[ \begin{matrix}  x&#39; \\ y&#39; \end{matrix} \right] &#x3D; \left[ \begin{matrix}  s_x &amp; 0 \\  0 &amp; s_y \end{matrix}"><meta property="og:image" content="http://ruishaopu561.github.io/img/cover/games101.webp"><meta property="article:published_time" content="2020-06-19T13:45:43.000Z"><meta property="article:modified_time" content="2021-01-21T03:00:06.680Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://ruishaopu561.github.io/2020/06/19/GAMES101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="prev" title="c++ 基础(1)" href="http://ruishaopu561.github.io/2021/01/20/c++%E5%9F%BA%E7%A1%80-1/"><link rel="next" title="unity-shader学习记录" href="http://ruishaopu561.github.io/2020/06/16/unity-shader%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://ruishaopu561.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Computer-Graphics"><span class="toc-number">1.</span> <span class="toc-text">Computer Graphics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture3-Transformation"><span class="toc-number">1.1.</span> <span class="toc-text">Lecture3. Transformation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2D变换"><span class="toc-number">1.1.1.</span> <span class="toc-text">2D变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#齐次坐标"><span class="toc-number">1.1.2.</span> <span class="toc-text">齐次坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#矩阵知识"><span class="toc-number">1.1.3.</span> <span class="toc-text">矩阵知识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture4-观测变换-Viewing-transformation"><span class="toc-number">1.2.</span> <span class="toc-text">Lecture4. 观测变换(Viewing transformation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#视图变换-View-Model-transformation"><span class="toc-number">1.2.1.</span> <span class="toc-text">视图变换(View&#x2F;Model transformation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#投影变换-projection-transformation"><span class="toc-number">1.2.2.</span> <span class="toc-text">投影变换(projection transformation)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#正交投影-Orthographic-projection"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">正交投影(Orthographic projection)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#透视投影-Perspective-projection"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">透视投影(Perspective projection)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿"><span class="toc-number">1.3.</span> <span class="toc-text">Lecture5&#x2F;6. Rasterization(光栅化)&#x2F;Antialiasing(反采样&#x2F;抗锯齿)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反采样的方法"><span class="toc-number">1.3.1.</span> <span class="toc-text">反采样的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#z-buffer"><span class="toc-number">1.3.2.</span> <span class="toc-text">z-buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shadow-Mapping"><span class="toc-number">1.3.3.</span> <span class="toc-text">Shadow Mapping</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture7-8-9-Shading"><span class="toc-number">1.4.</span> <span class="toc-text">Lecture7&#x2F;8&#x2F;9. Shading</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Illumination-amp-Shading"><span class="toc-number">1.4.1.</span> <span class="toc-text">Illumination &amp; Shading</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shading频率"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Shading频率</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Grahics-Pipeline-图形管线"><span class="toc-number">1.4.2.</span> <span class="toc-text">Grahics Pipeline(图形管线)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Texture-Mapping-纹理映射"><span class="toc-number">1.4.3.</span> <span class="toc-text">Texture Mapping(纹理映射)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#插值"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">插值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重心坐标"><span class="toc-number">1.4.4.</span> <span class="toc-text">重心坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#纹理应用"><span class="toc-number">1.4.5.</span> <span class="toc-text">纹理应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture10-11-12-Geometry"><span class="toc-number">1.5.</span> <span class="toc-text">Lecture10&#x2F;11&#x2F;12. Geometry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#隐式表现方法"><span class="toc-number">1.5.1.</span> <span class="toc-text">隐式表现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#显式表现方法"><span class="toc-number">1.5.2.</span> <span class="toc-text">显式表现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#贝塞尔曲线"><span class="toc-number">1.5.3.</span> <span class="toc-text">贝塞尔曲线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#逐段贝塞尔曲线"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">逐段贝塞尔曲线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-splines-B样条曲线"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">B-splines(B样条曲线)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#贝塞尔曲面"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">贝塞尔曲面</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mesh-Operations-网格操作"><span class="toc-number">1.5.4.</span> <span class="toc-text">Mesh Operations(网格操作)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mesh-Subvision-网格细分-UpSampling"><span class="toc-number">1.5.5.</span> <span class="toc-text">Mesh Subvision(网格细分)(UpSampling)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mesh-Simplification-网格简化-DownSampling"><span class="toc-number">1.5.6.</span> <span class="toc-text">Mesh Simplification(网格简化)(DownSampling)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mesh-Regularization-网格正则化-Same-Triangles"><span class="toc-number">1.5.7.</span> <span class="toc-text">Mesh Regularization(网格正则化)(Same #Triangles)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture13-14-15-16-Ray-Tracing"><span class="toc-number">1.6.</span> <span class="toc-text">Lecture13&#x2F;14&#x2F;15&#x2F;16. Ray Tracing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#光线追踪的技术问题"><span class="toc-number">1.6.1.</span> <span class="toc-text">光线追踪的技术问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Basic-radiometry-辐射度量学"><span class="toc-number">1.6.2.</span> <span class="toc-text">Basic radiometry(辐射度量学)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRDF"><span class="toc-number">1.6.3.</span> <span class="toc-text">BRDF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Monte-Carlo-Intergration-蒙特卡洛积分"><span class="toc-number">1.6.4.</span> <span class="toc-text">Monte Carlo Intergration(蒙特卡洛积分)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解渲染方程"><span class="toc-number">1.6.5.</span> <span class="toc-text">解渲染方程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture17-Materials-and-Appearances-材质外观"><span class="toc-number">1.7.</span> <span class="toc-text">Lecture17. Materials and Appearances(材质外观)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture18-Advanced-Topics-in-Rendering"><span class="toc-number">1.8.</span> <span class="toc-text">Lecture18. Advanced Topics in Rendering</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无偏光线传播算法"><span class="toc-number">1.8.1.</span> <span class="toc-text">无偏光线传播算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有偏光线传播算法"><span class="toc-number">1.8.2.</span> <span class="toc-text">有偏光线传播算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture19-Cameras-Lenses-and-Light-Fields"><span class="toc-number">1.9.</span> <span class="toc-text">Lecture19. Cameras, Lenses and Light Fields</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture20-Color-and-Perception"><span class="toc-number">1.10.</span> <span class="toc-text">Lecture20. Color and Perception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lecture21-22-Animation"><span class="toc-number">1.11.</span> <span class="toc-text">Lecture21&#x2F;22. Animation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Euler方法"><span class="toc-number">1.11.1.</span> <span class="toc-text">Euler方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#大规模粒子的模拟方法"><span class="toc-number">1.11.2.</span> <span class="toc-text">大规模粒子的模拟方法</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/cover/games101.webp)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Shaopu Rui</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">GAMES101_学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-06-19 21:45:43"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-06-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2021-01-21 11:00:06"><i class="fa fa-history" aria-hidden="true"></i> Updated 2021-01-21</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="Computer-Graphics"><a href="#Computer-Graphics" class="headerlink" title="Computer Graphics"></a>Computer Graphics</h2><p><a href="https://www.bilibili.com/video/BV1X7411F744" target="_blank" rel="noopener">课程视频</a></p>
<p>学习新知识的方式：Why, What and How</p>
<h3 id="Lecture3-Transformation"><a href="#Lecture3-Transformation" class="headerlink" title="Lecture3. Transformation"></a>Lecture3. Transformation</h3><h4 id="2D变换"><a href="#2D变换" class="headerlink" title="2D变换"></a>2D变换</h4><ul>
<li><p>缩放矩阵(Scale)</p>
<script type="math/tex; mode=display">\left[ \begin{matrix}
 x' \\ y'
\end{matrix}
\right] = \left[
\begin{matrix}
 s_x & 0 \\
 0 & s_y
\end{matrix}
\right]
\left[
\begin{matrix}
 x \\
 y
\end{matrix}
\right]
 \tag{1}</script></li>
<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
 x'\\
 y'
\end{matrix}
\right] = 
\left[
\begin{matrix}
 -1 & 0 \\
 0 & -1
\end{matrix}
\right]
\left[
\begin{matrix}
 x \\
 y
\end{matrix}
\right]
 \tag{2}</script></li>
<li><p>切片矩阵(Shear)</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
 x'\\
 y'
\end{matrix}
\right] = 
\left[
\begin{matrix}
 1 & a \\
 0 & 1
\end{matrix}
\right]
\left[
\begin{matrix}
 x \\
 y
\end{matrix}
\right]
 \tag{3}</script></li>
<li><p>旋转变换(Rotate)</p>
<script type="math/tex; mode=display">R_\theta = 
  \left[
      \begin{matrix}
      cos\theta & -sin\theta \\ 
      sin\theta & cos\theta 
  \end{matrix}
  \right]
  =>
  \left[
      \begin{matrix}
      x' \\ y' 
      \end{matrix}
  \right] = R_\theta 
  \left[
      \begin{matrix}
      x \\ y 
      \end{matrix}
  \right]
  \tag{4}</script></li>
<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>
</li>
</ul>
<h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><ul>
<li>为什么要用齐次坐标？<ul>
<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>
</ul>
</li>
<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>
<li>2D向量：$(x, y, 0)^T$,<ul>
<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>
</ul>
</li>
<li>三维坐标同理</li>
</ul>
<h4 id="矩阵知识"><a href="#矩阵知识" class="headerlink" title="矩阵知识"></a>矩阵知识</h4><ul>
<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>
</ul>
<h3 id="Lecture4-观测变换-Viewing-transformation"><a href="#Lecture4-观测变换-Viewing-transformation" class="headerlink" title="Lecture4. 观测变换(Viewing transformation)"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id="视图变换-View-Model-transformation"><a href="#视图变换-View-Model-transformation" class="headerlink" title="视图变换(View/Model transformation)"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>
<ul>
<li>Position: $\hat{e}$</li>
<li>Look-at: $\hat{g}$</li>
<li>Up direction: $\hat{t}$</li>
</ul>
<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>
<ul>
<li>先平移$\hat{e}$到原点<script type="math/tex; mode=display">T_{view} = 
      \left[ 
          \begin{matrix}
          1 & 0 & 0 & -x_e \\
          0 & 1 & 0 & -y_e \\
          0 & 0 & 1 & -z_e \\
          0 & 0 & 0 & 1
          \end{matrix}
      \right]</script></li>
<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type="math/tex; mode=display">R_{view}^{-1} = 
      \left[ 
          \begin{matrix}
          x_{\hat{g}\times\hat{t}} & x_{t} & x_{-g} & 0 \\
          y_{\hat{g}\times\hat{t}} & y_{t} & y_{-g} & 0 \\
          z_{\hat{g}\times\hat{t}} & z_{t} & z_{-g} & 0 \\
          0 & 0 & 0 & 1
          \end{matrix}
      \right] 
      => 
      R_{view} = 
      \left[ 
          \begin{matrix}
          x_{\hat{g}\times\hat{t}} & y_{\hat{g}\times\hat{t}} & z_{\hat{g}\times\hat{t}} & 0 \\
          x_{t} & y_{t} & z_{t} & 0 \\
          x_{-g} & y_{-g} & z_{-g} & 0 \\
          0 & 0 & 0 & 1
          \end{matrix}
      \right]</script></li>
</ul>
<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>
<h4 id="投影变换-projection-transformation"><a href="#投影变换-projection-transformation" class="headerlink" title="投影变换(projection transformation)"></a>投影变换(projection transformation)</h4><h5 id="正交投影-Orthographic-projection"><a href="#正交投影-Orthographic-projection" class="headerlink" title="正交投影(Orthographic projection)"></a>正交投影(Orthographic projection)</h5><h5 id="透视投影-Perspective-projection"><a href="#透视投影-Perspective-projection" class="headerlink" title="透视投影(Perspective projection)"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>
<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>
<ul>
<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>
</ul>
<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>
<script type="math/tex; mode=display">M_{persp->ortho} = 
    \left[
        \begin{matrix}
        n & 0 & 0 & 0 \\
        0 & n & 0 & 0 \\
        0 & 0 & n+f & -nf \\
        0 & 0 & 1 & 0 \\
        \end{matrix}
    \right]</script><p>$ =&gt; M<em>{persp-&gt;ortho}*M</em>{persp} = M_{ortho}$</p>
<h3 id="Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿"><a href="#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿" class="headerlink" title="Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>
<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>
<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>
<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>
<ul>
<li>时域的卷积==频域的乘积</li>
<li>高通滤波求边界，低通滤波模糊</li>
</ul>
<h4 id="反采样的方法"><a href="#反采样的方法" class="headerlink" title="反采样的方法"></a>反采样的方法</h4><ul>
<li>增加采样率：像素小，采样率更高<ul>
<li>这是物理限制。</li>
</ul>
</li>
<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>
<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>
<li>结果：效果还可以，先采样后模糊不行</li>
</ul>
</li>
<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>
</ul>
<h4 id="z-buffer"><a href="#z-buffer" class="headerlink" title="z-buffer"></a>z-buffer</h4><ul>
<li>复杂度：O(n)，n是三角形的个数</li>
<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>
<li>处理不了透明物体，因为有$\alpha$</li>
</ul>
<h4 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>
<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>
<p>过程：</p>
<ul>
<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>
<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>
</ul>
<p>问题：</p>
<ul>
<li>只能做硬阴影（point light only），边缘非常锐利</li>
<li>数值精度导致深度对比判断有问题</li>
<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>
</ul>
<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>
<h3 id="Lecture7-8-9-Shading"><a href="#Lecture7-8-9-Shading" class="headerlink" title="Lecture7/8/9. Shading"></a>Lecture7/8/9. Shading</h3><h4 id="Illumination-amp-Shading"><a href="#Illumination-amp-Shading" class="headerlink" title="Illumination &amp; Shading"></a>Illumination &amp; Shading</h4><h5 id="Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光"><a href="#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光" class="headerlink" title="Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>
<li>1.基础定义：<ul>
<li>视点向量：v</li>
<li>光源向量：l</li>
<li>物体法线向量：n</li>
</ul>
</li>
<li>2.Lambert’s余弦定律：$cos\theta = l \cdot n$</li>
<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>
<li>结合1/2/3 =&gt;<ul>
<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \cdot l)$</li>
<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>
<li>$L_i$: 光的颜色</li>
<li>与观察方向v无关，漫反射向各方向的反射相同</li>
</ul>
</li>
<li>4.关于高光的定义<ul>
<li>镜面反射方向向量: R</li>
<li>半程向量: h ($h = \frac{v+l}{||v+l||}$)</li>
</ul>
</li>
<li>5.半程向量h与法线向量n是否接近</li>
<li>结合4/5 =&gt;<ul>
<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \cdot h)^p$</li>
<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>
<li>$L_i$: 光的颜色</li>
<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>
</ul>
</li>
<li>环境光照ambient：$L_a = k_aI_a$<ul>
<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>
<li>$L_a$: 光的颜色</li>
<li>不考虑光线方向、观察方向、法线方向</li>
<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>
</ul>
</li>
<li>结合ambient + diffuse + specular =&gt; <ul>
<li>$L = L_a + L_d + L_s$</li>
</ul>
</li>
</ul>
<h5 id="Shading频率"><a href="#Shading频率" class="headerlink" title="Shading频率"></a>Shading频率</h5><ul>
<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>
<li>效果较差</li>
</ul>
</li>
<li>Gouraud shading<ul>
<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>
<li>各面求和或加权求和，再归一化</li>
</ul>
</li>
<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>
</ul>
</li>
<li>Phong Shading：逐像素<ul>
<li>求出所有顶点法线向量，计算出各顶点颜色值</li>
<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>
<li>逐像素着色</li>
</ul>
</li>
</ul>
<h4 id="Grahics-Pipeline-图形管线"><a href="#Grahics-Pipeline-图形管线" class="headerlink" title="Grahics Pipeline(图形管线)"></a>Grahics Pipeline(图形管线)</h4><p><img src="/img/games101/graphicspipeline.png" alt="Graphics Pipeline"></p>
<ul>
<li>Vertex Shader: 顶点着色器</li>
<li>Fragment Shader: 像素/片段着色器</li>
</ul>
<h4 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping(纹理映射)"></a>Texture Mapping(纹理映射)</h4><ul>
<li><p>纹理放大：</p>
<ul>
<li>双线性插值</li>
<li>双立方（三次）插值<ul>
<li>效果更好，开销更大</li>
</ul>
</li>
</ul>
</li>
<li><p>Mipmap</p>
<ul>
<li>快速的、近似的、方形的范围查询</li>
<li>根据原纹理计算出更小分辨率的纹理</li>
<li>计算level D的Mipmap:<ul>
<li>$L = max(\sqrt{(\frac{du}{dx})^2 + (\frac{du}{dy})^2}, \sqrt{(\frac{dv}{dx})^2, (\frac{dv}{dy})^2})$</li>
<li>$D = log_2L$</li>
</ul>
</li>
<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>
<li>1.在D层求插值</li>
<li>2.在D+1层求插值</li>
<li>3.求层与层的插值</li>
</ul>
</li>
</ul>
</li>
<li>Anisotropic Filter(各向异性过滤)<ul>
<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h5></li>
</ul>
</li>
<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>
<li>双线性插值：<ul>
<li>$u<em>0 = lerp(s, u</em>{00}, u_{10})$</li>
<li>$u<em>1 = lerp(s, u</em>{01}, u_{11})$</li>
<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h4></li>
</ul>
</li>
<li>三角形内任一点$(x, y) = \alpha A + \beta B + \gamma C, \alpha+\beta+\gamma=1, \alpha &gt;=0 \beta&gt;=0, \gamma&gt;=0$</li>
<li><p>重心：$\alpha = \beta = \gamma = 1/3$</p>
</li>
<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>
</li>
<li>三维空间中需要先计算插值再投影</li>
<li>投影之后没有不变性，这是缺点</li>
</ul>
<h4 id="纹理应用"><a href="#纹理应用" class="headerlink" title="纹理应用"></a>纹理应用</h4><ul>
<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>
<li>sphere map</li>
<li>cube map：将sphere map的内容映射到cube上</li>
</ul>
</li>
<li>凹凸映射(Bump mapping)<ul>
<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>
<li>纹理图中对u求导得：$dp/du = (\Delta u, 0, h(u+1)-h(u))$</li>
<li>纹理图中对v求导得：$dp/dv = (\Delta v, 0, h(v+1)-h(v))$</li>
<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>
</ul>
</li>
<li>位移贴图(Displacment Mapping)<ul>
<li>也是存了高度，但是真的改了顶点位置</li>
<li>模型更细致更好，能更好的表现贴图结果</li>
</ul>
</li>
</ul>
<h3 id="Lecture10-11-12-Geometry"><a href="#Lecture10-11-12-Geometry" class="headerlink" title="Lecture10/11/12. Geometry"></a>Lecture10/11/12. Geometry</h3><ul>
<li>分类：隐式几何，显式几何<ul>
<li>结合需要进行选择</li>
</ul>
</li>
<li>隐式几何：<ul>
<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>
<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>
</ul>
</li>
<li>显式几何：<ul>
<li>直接给出所有点坐标，或者用参数映射<ul>
<li>参数映射：<ul>
<li>遍历(u, v)就能得到所有点的集合</li>
<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>
</ul>
</li>
</ul>
</li>
<li>判断内外位置很复杂，判断形状比较简单</li>
</ul>
</li>
</ul>
<h4 id="隐式表现方法"><a href="#隐式表现方法" class="headerlink" title="隐式表现方法"></a>隐式表现方法</h4><ul>
<li>CSG<ul>
<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>
</ul>
</li>
<li>Signed Distance Function(符号距离函数)</li>
<li>Level Set(水平集)</li>
<li>Fractal(分形)</li>
</ul>
<h4 id="显式表现方法"><a href="#显式表现方法" class="headerlink" title="显式表现方法"></a>显式表现方法</h4><ul>
<li>点云</li>
<li>多边形网格</li>
<li>贝塞尔曲线(通过参数t定义)<h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>
</ul>
<p>曲线一定经过$p<em>0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p</em>{n-1}$，$p_n$的切线相同</p>
<ul>
<li><p>画线的算法：</p>
<ul>
<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>
<li>推导过程见下图，就是一个递归求t的过程 <img src="/img/games101/beziert.png" alt="bezier t"></li>
<li>总结公式：(n+1)个控制点$p<em>0…p_n$，公式就是$b^n(t)=b_0^n(t) = \sum</em>{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>
<li>$B_i^n(t) = \left( \begin{matrix} n \  i \end{matrix} \right) t^i (1-t)^{n-i}$</li>
</ul>
</li>
</ul>
</li>
<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>
</li>
<li>投影变换下不适用。</li>
<li>凸包性质：不会超过给定控制点形成的凸包范围</li>
</ul>
<h5 id="逐段贝塞尔曲线"><a href="#逐段贝塞尔曲线" class="headerlink" title="逐段贝塞尔曲线"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>
<ul>
<li>连续性：<ul>
<li>c0连续：曲线A的终点就是曲线B的起点</li>
<li>c1连续：c0连续，且该重合点切线相同</li>
</ul>
</li>
</ul>
<h5 id="B-splines-B样条曲线"><a href="#B-splines-B样条曲线" class="headerlink" title="B-splines(B样条曲线)"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>
<h5 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>
<p>因此这里需要两个参数$t_1$，$t_2$</p>
<h4 id="Mesh-Operations-网格操作"><a href="#Mesh-Operations-网格操作" class="headerlink" title="Mesh Operations(网格操作)"></a>Mesh Operations(网格操作)</h4><h4 id="Mesh-Subvision-网格细分-UpSampling"><a href="#Mesh-Subvision-网格细分-UpSampling" class="headerlink" title="Mesh Subvision(网格细分)(UpSampling)"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>
<li>Loop细分<ul>
<li>将一个三角形分成4个（各边中点相连）</li>
<li>对各新旧顶点进行不同的顶点位置更新<ul>
<li>对新顶点的更新方式：（白点） <img src="/img/games101/new_vertex.png" alt="new vertex"></li>
<li>对旧顶点的更新方式：（白点） <ul>
<li>n: 该顶点的度</li>
<li>u: 考虑周围顶点的值</li>
<li><img src="/img/games101/old_vertex.png" alt="old vertex"></li>
</ul>
</li>
</ul>
</li>
<li>只能用三角形面</li>
</ul>
</li>
<li>Catmull-Clark细分<ul>
<li>基础定义：<ul>
<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>
<li>Extraordinary vertex: 奇异点，度不为4的点</li>
</ul>
</li>
<li>取各边和各面的中点，并且面中点与边中点连接</li>
<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>
<li>点的更新<ul>
<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>
<li><img src="/img/games101/catmull_clark.png" alt="Catmull Clark"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Mesh-Simplification-网格简化-DownSampling"><a href="#Mesh-Simplification-网格简化-DownSampling" class="headerlink" title="Mesh Simplification(网格简化)(DownSampling)"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>
<li>Collapse Edge：一条边坍缩成一个点<ul>
<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>
<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>
<li>这其实是贪心算法，没法全局取坍缩的边</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Mesh-Regularization-网格正则化-Same-Triangles"><a href="#Mesh-Regularization-网格正则化-Same-Triangles" class="headerlink" title="Mesh Regularization(网格正则化)(Same #Triangles)"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id="Lecture13-14-15-16-Ray-Tracing"><a href="#Lecture13-14-15-16-Ray-Tracing" class="headerlink" title="Lecture13/14/15/16. Ray Tracing"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>
<ul>
<li>软阴影(Soft shadows)</li>
<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>
<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>
</ul>
<p>光线追踪类型：</p>
<ul>
<li>Pinhole Ray Tracing</li>
<li>Recursive(Whitted-style) Ray Tracing<br>  <img src="/img/games101/recurcive_raytracing.png" alt="recurcive ray tracing"></li>
</ul>
<h4 id="光线追踪的技术问题"><a href="#光线追踪的技术问题" class="headerlink" title="光线追踪的技术问题"></a>光线追踪的技术问题</h4><ul>
<li><p>光线与物体表面的焦点</p>
<ul>
<li>光线：$r(t) = oringin + t * direction, 0 \le t &lt; \infty$</li>
<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>
<li>与显式表面相交计算，<ul>
<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \cdot N = (origin + t * direction - p’) \cdot N = 0 =&gt; t = \frac{p’\cdot N-origin}{direction \cdot N}$，检查：$0 \le t &lt; \infty$</li>
<li>Moller Trumbore算法：<ul>
<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\left[ \begin{matrix} t \ b_1 \ b_2 \end{matrix} \right] = \frac{1}{S_1 \cdot E_1} \left[ \begin{matrix} S_2 \cdot E_2 \ S_1 \cdot S \ S_2 \cdot D  \end{matrix} \right]， \begin{matrix} E_1 = p_1 - p_0 \  E_2 = p_2 - p_0 \ S = O-p_0 \ S_1=D \times E_2 \ S_2=S \times E_1  \end{matrix}, 检查: \begin{matrix} 0 \le t &lt; \infty \ 0 \le b_1 \le 1 \ 0 \le b_2 \le 1 \  \end{matrix}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>
<ul>
<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>
<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>
</ul>
</li>
<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>
<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>
<li>Oct Tree: 八叉树</li>
<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>
<li>并不是按物体划分，因此后续的物体判断比较复杂</li>
</ul>
</li>
<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src="/img/games101/spatial_partition.png" alt="spatial partition"></li>
</ul>
</li>
<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>
<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Basic-radiometry-辐射度量学"><a href="#Basic-radiometry-辐射度量学" class="headerlink" title="Basic radiometry(辐射度量学)"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>
<p>基础定义：</p>
<ul>
<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>
<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\Phi = \frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>
<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \frac{d\Phi}{dw}[\frac{W}{sr}][\frac{lm}{sr} = cd = candela]$<ul>
<li>立体角=面积/半径的平方：$\Omega = \frac{A}{r^2}$</li>
</ul>
</li>
<li>Irradiance：<ul>
<li>接受辐射，或者是光源往外辐射</li>
<li>$E(x) = \frac{d(\Phi)}{dA}$</li>
<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>
<li>也能解释季节变化，因为自转导致直射纬度在变</li>
<li><center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/irradiance_falloff.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          Irradiance衰减图示
      </div>
  </center></li>
</ul>
</li>
<li>radiance：<ul>
<li>单位立体角、单位辐射面积上的功率</li>
<li>$L(p, w) = \frac{d^2\Phi(p, w)}{d\omega dA cos\theta}$，$cos\theta$是irradiance的夹角</li>
</ul>
</li>
</ul>
<h4 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>
<ul>
<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/rushe_fanshe.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          BRDF: 入射光与反射光
      </div>
  </center></li>
<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>
<li>$L<em>r(p, \omega_r) = \int</em>{H^2}f_r(p, \omega_i \rightarrow \omega_r)L_i(p, \omega_i)cos\theta_i d{\omega}_i$</li>
</ul>
</li>
<li>渲染方程：<ul>
<li>反射光 = 自己发光+反射别人的光</li>
<li>$L<em>o(p,\omega_o) = L_e(p, \omega_o) + \int</em>{\Omega^+}L_i(p,\omega_i)f_r(p, \omega_i, \omega_o) (n \cdot \omega_i) d{\omega}_i$，其中$n \cdot\omega_i = cos\theta_i$</li>
<li>方程简化<ul>
<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src="/img/games101/brdf1.png" alt="original"> <img src="/img/games101/brdf2.png" alt="./simmplify"></li>
</ul>
</li>
<li>光栅化只能做到$E$和$E+KE$</li>
</ul>
</li>
</ul>
<h4 id="Monte-Carlo-Intergration-蒙特卡洛积分"><a href="#Monte-Carlo-Intergration-蒙特卡洛积分" class="headerlink" title="Monte Carlo Intergration(蒙特卡洛积分)"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\int_a^b f(x)dx$</p>
<ul>
<li>常规算式：$\int f(x)dx = \frac{1}{N} \sum_{i=1}^{N} \frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>
</ul>
<h4 id="解渲染方程"><a href="#解渲染方程" class="headerlink" title="解渲染方程"></a>解渲染方程</h4><ul>
<li>Simple蒙特卡洛解法(不考虑自光源)<ul>
<li>直接光照下<br>  $L<em>o(a,\omega_o)<br>  =\int</em>{\Omega^+}L<em>i(a,\omega_i)f_r(a, \omega_i, \omega_o) (n \cdot \omega_i) d{\omega}_i<br>  =\frac{1}{N} \sum</em>{i=1}^{N} \frac{L_i(a,\omega_i)f_r(a, \omega_i, \omega_o) (n \cdot \omega_i)}{p(\omega_i)}$</li>
</ul>
</li>
<li>考虑物体发光，也就是考虑间接反射。<ul>
<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/motekarluo_n.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          蒙特卡洛方法——N
      </div>
  </center></li>
</ul>
</li>
<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/motekarluo_1.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          蒙特卡洛方法——1
      </div>
  </center>
  <center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/ray_generation.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          Ray Generation
      </div>
  </center></li>
<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>
  <center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/recursion_solution.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          解决无限递归
      </div>
  </center>
</li>
<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>
<ul>
<li>首先是立体角到光源面积的积分转换，关系：$d\omega_i = \frac{cos\theta’}{||x’-p||^2} dA$，$\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>
<li>得到新的渲染方程：$L<em>o(a,\omega_o)<br>  =\int</em>{\Omega^+}L_i(a,\omega_i)f_r(a, \omega_i, \omega_o) (n \cdot \omega_i) \frac{cos\theta’}{||x’-p||^2} dA$</li>
<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>
<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>
<li>伪代码如下：  <center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/lightsource.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          光源采样
      </div>
  </center>

</li>
</ul>
</li>
</ul>
<h3 id="Lecture17-Materials-and-Appearances-材质外观"><a href="#Lecture17-Materials-and-Appearances-材质外观" class="headerlink" title="Lecture17. Materials and Appearances(材质外观)"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>
<li>Diffuse / Lambertian Material<ul>
<li>BRDF $f_r = \frac{\rho}{\pi}$，其中$\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>
</ul>
</li>
<li>Glossy Material(抛光金属)</li>
<li>Ideal reflective / refractive material (BSDF*)<ul>
<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>
<li>折射定律：Snell’s Law <ul>
<li>$\eta_i sin\theta_i = \eta_t sin\theta_t$</li>
</ul>
</li>
</ul>
</li>
<li>Specular </li>
<li>Fresnel Term(菲涅尔项，$\eta = 1.5$)<ul>
<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>
<li>Schlick’s近似算法：$R(\theta) = R_0 + (1-R_0)(1-cos\theta)^5$，其中$R_0 = (\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>
</ul>
</li>
<li>Microfacet Material(微表面材料，非常重要！！！)<ul>
<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>
<li>近处是几何，远处的材质</li>
<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>
<li>$f(i,o) = \frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>
<li>F(i, h)：$F<em>{Schlick} = C</em>{spec} + (1-C<em>{spec})(1-l \cdot h)^5$(考虑了高光颜色$C</em>{spec}$)，菲涅尔项，描述光的反射与折射量</li>
<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \frac{2(n \cdot h)(n \cdot v)}{v \cdot h}, \frac{2(n \cdot h)(n \cdot l)}{v \cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>
<li>D(h)：$D_{GGX} = \frac{\alpha^2}{\pi ((n \cdot h)^2(\alpha^2-1)+1)^2}$，法线分布  <center>
      <img style="border-radius: 0.3125em;
      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
      src="/img/games101/microfacet.png">
      <br>
      <div style="color:orange; border-bottom: 1px solid #d9d9d9;
      display: inline-block;
      color: #999;
      padding: 2px;">
          微表面模型
      </div>
  </center></li>
</ul>
</li>
</ul>
</li>
<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>
<li>与绝对方位角有关</li>
</ul>
</li>
</ul>
<h3 id="Lecture18-Advanced-Topics-in-Rendering"><a href="#Lecture18-Advanced-Topics-in-Rendering" class="headerlink" title="Lecture18. Advanced Topics in Rendering"></a>Lecture18. Advanced Topics in Rendering</h3><ul>
<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>
<li>有偏：biased，与unbiased相反。<ul>
<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>
</ul>
</li>
</ul>
<h4 id="无偏光线传播算法"><a href="#无偏光线传播算法" class="headerlink" title="无偏光线传播算法"></a>无偏光线传播算法</h4><ul>
<li>BDPT: Bidrectional Path Tracing<ul>
<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>
<li>很难实现，速度也很慢，对某些情况的效果很好。</li>
</ul>
</li>
<li>MLT: Metropolis Light Transport<ul>
<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>
<li>复杂光路上效果很好。但是很难判断是否收敛</li>
</ul>
</li>
</ul>
<h4 id="有偏光线传播算法"><a href="#有偏光线传播算法" class="headerlink" title="有偏光线传播算法"></a>有偏光线传播算法</h4><ul>
<li>Photon Mapping<ul>
<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>
<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>
</ul>
</li>
<li>实现过程<ul>
<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>
<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>
<li>计算：local density estimation<ul>
<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>
<li>N越小的时候，noise就会比较大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Vertex Connection and Merging<ul>
<li>BDPT和Photon Mapping的组合</li>
</ul>
</li>
<li>Instant Radiosity(IR)实时辐射度<ul>
<li>不能处理Glossy的物体</li>
</ul>
</li>
</ul>
<h3 id="Lecture19-Cameras-Lenses-and-Light-Fields"><a href="#Lecture19-Cameras-Lenses-and-Light-Fields" class="headerlink" title="Lecture19. Cameras, Lenses and Light Fields"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id="Lecture20-Color-and-Perception"><a href="#Lecture20-Color-and-Perception" class="headerlink" title="Lecture20. Color and Perception"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>
<h3 id="Lecture21-22-Animation"><a href="#Lecture21-22-Animation" class="headerlink" title="Lecture21/22. Animation"></a>Lecture21/22. Animation</h3><ul>
<li>关键帧动画</li>
<li>质点弹簧系统</li>
<li>粒子系统</li>
<li>Forward Kinematics</li>
<li>Rigging(绑定)</li>
</ul>
<h4 id="Euler方法"><a href="#Euler方法" class="headerlink" title="Euler方法"></a>Euler方法</h4><ul>
<li>一阶(前向)欧拉方法<ul>
<li>$x^{t+ \Delta t} = x^t + \Delta t x’^t, x’^{t+ \Delta t} = x’^t + \Delta t x’’^t$</li>
<li>受步长$\Delta t$的影响误差可能很大，当然减小$\Delta t$可以减小误差</li>
<li>非常不稳定，可能会出现不符合实际规律得到结果</li>
</ul>
</li>
<li>中点法（Midpoint method）<ul>
<li>$x<em>{mid} = x^t + \Delta t /2 \cdot x’^t \rightarrow x^{t+\Delta t} = x^t + \Delta t \cdot x’</em>{mid}$</li>
<li>上式化简得$x^{t+ \Delta t} = x^t + \Delta t x’^t + \frac{(\Delta t)^2}{2} x’’^t$</li>
</ul>
</li>
<li>Implicit Euler Method<ul>
<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>
<li>$x^{t+ \Delta t} = x^t + \Delta t x’^{t+ \Delta t}, x’^{t+ \Delta t} = x’^t + \Delta t x’’^{t+ \Delta t}$</li>
</ul>
</li>
<li>Runge Kutta Method<ul>
<li>RK4,4阶，最常用</li>
<li>假设初始条件$\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>
<li>有$y<em>{n+1} = y_n + \frac{1}{6}h(k_1+2k_2+2k_3+k_4), t</em>{n+1} = t_n + h$</li>
<li>上式中$k_{1-4}$的值如下：$\left[ \begin{matrix} k_1 \ k_2 \ k_3 \ k_4 \end{matrix} \right] = \left[ \begin{matrix} f(t_n, y_n) \ f(t_n+\frac{h}{2}, y_n+h \frac{k_1}{2}) \ f(t_n+\frac{h}{2}, y_n+h \frac{k_2}{2}) \ f(t_n+h, y_n+hk_3) \end{matrix} \right]$</li>
</ul>
</li>
<li>Position Based / Verlet Integration</li>
</ul>
<h4 id="大规模粒子的模拟方法"><a href="#大规模粒子的模拟方法" class="headerlink" title="大规模粒子的模拟方法"></a>大规模粒子的模拟方法</h4><ul>
<li>拉格朗日法（质点法）<ul>
<li>对每个单独的粒子计算其运动变化规律</li>
</ul>
</li>
<li>欧拉法（网格法）<ul>
<li>划分空间，以空间为单位考虑</li>
</ul>
</li>
<li>Material Point Method(MPM)<ul>
<li>现在非常热门的方法，也是拉格朗日法和的结合</li>
</ul>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Shaopu Rui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://ruishaopu561.github.io/2020/06/19/GAMES101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://ruishaopu561.github.io/2020/06/19/GAMES101-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/database.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/01/20/c++%E5%9F%BA%E7%A1%80-1/"><img class="prev_cover" src="/img/cover/cpp.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">c++ 基础(1)</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/16/unity-shader%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><img class="next_cover" src="/img/cover/shader.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">unity-shader学习记录</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/01/20/c++基础-1/" title="c++ 基础(1)"><img class="relatedPosts_cover" src="/img/cover/cpp.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-20</div><div class="relatedPosts_title">c++ 基础(1)</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/20/c++基础-2/" title="c++ 基础(2)"><img class="relatedPosts_cover" src="/img/cover/cpp.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-20</div><div class="relatedPosts_title">c++ 基础(2)</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/20/c++基础-3/" title="c++ 基础(3)"><img class="relatedPosts_cover" src="/img/cover/cpp.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-20</div><div class="relatedPosts_title">c++ 基础(3)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/16/unity-shader学习记录/" title="unity-shader学习记录"><img class="relatedPosts_cover" src="/img/cover/shader.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-16</div><div class="relatedPosts_title">unity-shader学习记录</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/21/数据库基础-1/" title="数据库基础-1"><img class="relatedPosts_cover" src="/img/cover/database.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-21</div><div class="relatedPosts_title">数据库基础-1</div></div></a></div><div class="relatedPosts_item"><a href="/2021/01/24/数据库基础-2/" title="数据库基础-2"><img class="relatedPosts_cover" src="/img/cover/database.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-01-24</div><div class="relatedPosts_title">数据库基础-2</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Shaopu Rui</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>