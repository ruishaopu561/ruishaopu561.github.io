{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Butterfly/_config.yml","hash":"75e95a12ad055490a58ac92f35f8794e9fbd63bf","modified":1592583112792},{"_id":"themes/Butterfly/package.json","hash":"56e967481d2996e4618455cf372e592884f929b1","modified":1591950732658},{"_id":"themes/Butterfly/LICENSE","hash":"e7e7b7677bb19563a9013e936486bdefeb761d07","modified":1591950732609},{"_id":"themes/Butterfly/README.md","hash":"31708ead9c9a494d5fa2c8ec5fc3cf675f13240e","modified":1591950732610},{"_id":"themes/Butterfly/languages/default.yml","hash":"3492594f5aed8ab7ee46c212bc1030b8140c4682","modified":1591950732612},{"_id":"themes/Butterfly/languages/en.yml","hash":"3492594f5aed8ab7ee46c212bc1030b8140c4682","modified":1591950732613},{"_id":"themes/Butterfly/.github/stale.yml","hash":"70467ce772e68de57a4bf2ac285f1c0b122f25f5","modified":1591950732604},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"2471c83209aba78883ef1337a5a47b4a2654061d","modified":1591950732613},{"_id":"themes/Butterfly/README_CN.md","hash":"6f42d4ab0dfd564eb7b434867812c9f4a4e163cc","modified":1591950732611},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"430789bde19a81103eddaa50b68376a3080a2cac","modified":1591950732614},{"_id":"themes/Butterfly/layout/404.pug","hash":"2d58b62240a5ea1119cc19e647e9a17efe1c7243","modified":1591950732614},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE.md","hash":"8f7a0f8d4bfc97ba106128828a33a9cc0a295194","modified":1591950732604},{"_id":"themes/Butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1591950732615},{"_id":"themes/Butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1591950732615},{"_id":"themes/Butterfly/layout/flink.pug","hash":"391c3af22057ddd2a44da475710e6ff7866d954e","modified":1591950732615},{"_id":"themes/Butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1591950732656},{"_id":"themes/Butterfly/layout/page.pug","hash":"5cef945ed21199da6950cb3806d1faa45d3130c1","modified":1591950732657},{"_id":"themes/Butterfly/layout/post.pug","hash":"ace5cefcd90d34e09119bedb064c34238f653687","modified":1591950732657},{"_id":"themes/Butterfly/layout/tag.pug","hash":"e658aa76a11d1e18ec00131d9cec1a38b3d6a62e","modified":1591950732658},{"_id":"source/_posts/unity-shader学习记录.md","hash":"0ee009ec9da7d70421629f66734a923704eab2b0","modified":1592410464439},{"_id":"source/_posts/GAMES101-学习笔记.md","hash":"58086fd150891d398954b2455a1784ea601ae8ec","modified":1592580215242},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"0537eb7e279c213430518e0674a380769d52f425","modified":1591950732616},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"9d98c38f1634987ef22a3cdb391b1f9fa2f806d2","modified":1591950732622},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"47b70ee674f8c6a07139f1915e6c4fc0d6f31ab5","modified":1591950732623},{"_id":"source/_posts/Hexo-Github.md","hash":"12d25cf807f8fd8289b160a1be69251b5fdc38fe","modified":1592579941097},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"603a800d85acfd533fca8603fc49c86a4caa10a0","modified":1591950732635},{"_id":"source/_posts/hello-world.md","hash":"eca7034e946c51d94536e2fec5351e16e6b03821","modified":1592324691374},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"fa6b9b365c75120b90e069e439843b9def8c7ee5","modified":1591950732642},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"418349c6a31f246d91aab53640ded1ae674463aa","modified":1591950732643},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"3981532dfffb57d00e3ebf5f590a2094d426898a","modified":1591950732647},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1591950732659},{"_id":"themes/Butterfly/scripts/events/replace_config.js","hash":"39fabaae6943bbafb8248ee81ae9b32e1145c84a","modified":1591950732660},{"_id":"themes/Butterfly/scripts/filters/post_lazyload.js","hash":"e2bd91061e7481c6fa787de22257744172508ece","modified":1591950732661},{"_id":"themes/Butterfly/scripts/filters/random_cover.js","hash":"8e44ec5c9a50b01790186cb6c319b70a42581add","modified":1591950732661},{"_id":"themes/Butterfly/scripts/helpers/aside_archives.js","hash":"45be3eda5fc8c3fcf70cb13beece28ae3884b721","modified":1591950732662},{"_id":"themes/Butterfly/scripts/helpers/aside_categories.js","hash":"625ef99594006b4ac6b721fa6a7da785b3dd4770","modified":1591950732662},{"_id":"themes/Butterfly/scripts/helpers/page.js","hash":"4e6cffc4ecf5c600dc50b5677a21c3569e2ed043","modified":1591950732663},{"_id":"themes/Butterfly/scripts/helpers/related_post.js","hash":"e770feb749ac76214ce1fb42579ecda68e80e433","modified":1591950732664},{"_id":"themes/Butterfly/scripts/tags/gallery.js","hash":"1735602a8da89b3ee961899c0eb4c9e6116b580c","modified":1591950732665},{"_id":"themes/Butterfly/scripts/tags/hide.js","hash":"92ee53c76906a2d661ccdf68058c20ab2c048b15","modified":1591950732666},{"_id":"themes/Butterfly/scripts/tags/mermaid.js","hash":"46d3c4c6a38d750d1ad9ca695d6c0df62b7107d6","modified":1591950732666},{"_id":"themes/Butterfly/scripts/tags/note.js","hash":"b6acc0f4f994692d124c7a251a2606afde3fcf9d","modified":1591950732666},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1591950732689},{"_id":"themes/Butterfly/source/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1591969585041},{"_id":"themes/Butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1591950732689},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1591950732689},{"_id":"themes/Butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1591950732691},{"_id":"themes/Butterfly/source/css/index.styl","hash":"14161794cdd22414641239a09e2db613f1999d00","modified":1591950732687},{"_id":"themes/Butterfly/source/css/var.styl","hash":"4314b50a909c4e47fc767e50e8f1798754436062","modified":1591950732688},{"_id":"themes/Butterfly/source/js/main.js","hash":"b6343a3fd916672bfad295f939504fe632ec1cd8","modified":1591950732694},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"0a48ec7f2b01f2ea3f86a12af63a7399cbfaccd6","modified":1591950732700},{"_id":"themes/Butterfly/source/js/utils.js","hash":"e640956180cc604948e76979cdaab40286e4a04e","modified":1591950732701},{"_id":"themes/Butterfly/layout/includes/comments/disqus.pug","hash":"5ae50a271fe5a49f4012555657db028b7113612b","modified":1591950732618},{"_id":"themes/Butterfly/layout/includes/comments/disqusjs.pug","hash":"e96dd925a1d17cfb4fe5ac13561982c9b13d6b53","modified":1591950732618},{"_id":"themes/Butterfly/layout/includes/comments/facebook_comments.pug","hash":"9d4ed57b91ad520b95d220980add8477ce968618","modified":1591950732619},{"_id":"themes/Butterfly/layout/includes/comments/gitalk.pug","hash":"bb4de1b40ae07b27dda4e3e529687f6c1a9196ca","modified":1591950732619},{"_id":"themes/Butterfly/layout/includes/comments/index.pug","hash":"43aa3a3087ffcf319a06043c00e1cd8fbd071d79","modified":1591950732620},{"_id":"themes/Butterfly/layout/includes/comments/laibili.pug","hash":"1d5d1b2cf17271cc6d69071f6df11fe477ae8bb3","modified":1591950732621},{"_id":"themes/Butterfly/layout/includes/comments/utterances.pug","hash":"8ef3dc1a27c19645ac054e30594ed1930b1c56f0","modified":1591950732621},{"_id":"themes/Butterfly/layout/includes/comments/valine.pug","hash":"6d930ef62b44f9789f25a81b1baae8f1a0988e1d","modified":1591950732622},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"6f6bc88b300d22b18c7b1a1ab3b75661040dcf44","modified":1591950732624},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"036213b05df9e51250c2734854de7a096a9ed8c2","modified":1591950732624},{"_id":"themes/Butterfly/layout/includes/head/comment.pug","hash":"2dbb3378929e2f1ead3bbc4a88fafd72c6632ff8","modified":1591950732625},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"9265b536774344e4e58747bba62286b361d0279d","modified":1591950732625},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"4dea5574fa33f688a2a80d4e070e6c0ba9a62480","modified":1591950732627},{"_id":"themes/Butterfly/layout/includes/head/darkmode.pug","hash":"e44d63ee21b7ee247927f0189a783ffa9ba075fd","modified":1591950732627},{"_id":"themes/Butterfly/layout/includes/head/dns_prefetch.pug","hash":"9e86a17cf4dfc9191bba550dd27f874f4c2180fb","modified":1591950732628},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"393e641a35174f26318b8724eddaf1a0b1386636","modified":1591950732628},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"a84dac02e9d30c9c8e7ed895214d46cf2d2af3db","modified":1591950732629},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"e4fb9e5c72ca05d595f0959893c2fe03b8f478e2","modified":1591950732629},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"2d267fcc926505fcc5ebc9f59146555b32654c7e","modified":1591950732631},{"_id":"themes/Butterfly/layout/includes/head/subtitle.pug","hash":"a305d861db7951ea8b7961f8528bca453d850b16","modified":1591950732631},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1591964356920},{"_id":"themes/Butterfly/layout/includes/header/header.pug","hash":"8011ca7bc0d218f6cfed2e84dd8b91be05886451","modified":1591950732632},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"12461e6c7efcf0135e0a6fd85f425606818d4f19","modified":1591950732633},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"4a57762f9b5ce4f30088d2552a61a016acdc93ca","modified":1591950732633},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"2bee87cc95078baeab85dd5efec9b0bebb2170f5","modified":1591950732633},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0758817464c300f785384ea21bf096f5010c4f96","modified":1591950732634},{"_id":"themes/Butterfly/layout/includes/loading/loading-js.pug","hash":"3a605e29a0607c315c0566f2a1c6487b4aa98140","modified":1591950732635},{"_id":"themes/Butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1591950732636},{"_id":"themes/Butterfly/layout/includes/math/index.pug","hash":"403601a903d02ef0a103d18909a6eb0b088fcb4c","modified":1591950732636},{"_id":"themes/Butterfly/layout/includes/math/katex.pug","hash":"60bd18e051a442d5ce25325a55982922ab15be04","modified":1591950732637},{"_id":"themes/Butterfly/layout/includes/math/mathjax.pug","hash":"9f10622c73c2c87d3502660eb933af654d2600b4","modified":1591950732637},{"_id":"themes/Butterfly/layout/includes/math/mermaid.pug","hash":"41f6c6c9d753ed97ab2adef47f13595f8aebb464","modified":1591950732638},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"15e2c600f7ded4ffdcaa94ef728f22d883fe6038","modified":1591950732639},{"_id":"themes/Butterfly/layout/includes/mixins/post-ui.pug","hash":"648b09cc1c2c1720033b4eab1936d44070e398db","modified":1591950732640},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1591950732692},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/index.pug","hash":"e9eacd936c259d8f10e1becdd6e3ca129ea0e942","modified":1591950732641},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"06e87ad69670c1090210b3e4df86a2ada98553bc","modified":1591950732641},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"547a2737cd3ac45272a75561f5b5438d72d10f6d","modified":1591950732642},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"ed228c196ceaae30e78818e06ce8f29617cf9ec7","modified":1591950732643},{"_id":"themes/Butterfly/layout/includes/search/algolia.pug","hash":"3d2b2de0e199ab1fb151f41f2bbaac909f3d3d12","modified":1591950732644},{"_id":"themes/Butterfly/layout/includes/search/index.pug","hash":"66b4f4e8119e987cd3f9907298689a1408a05859","modified":1591950732645},{"_id":"themes/Butterfly/layout/includes/search/local-search.pug","hash":"e24b08e7253e78d3088d7267188a1ca18b6b5315","modified":1591950732645},{"_id":"themes/Butterfly/layout/includes/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1591950732646},{"_id":"themes/Butterfly/layout/includes/share/addtoany.pug","hash":"4108ab6b91461254901f19ed3e5e082e437324aa","modified":1591950732646},{"_id":"themes/Butterfly/layout/includes/share/index.pug","hash":"af2f09d374a55983d1ac695848ccfae50629f439","modified":1591950732647},{"_id":"themes/Butterfly/layout/includes/share/share-js.pug","hash":"43643295be651fb3d2cd88ebf81544fde3131489","modified":1591950732647},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1591950732648},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1591950732648},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"74fc2a62e125f28947ec9cd60f968023da766adb","modified":1591950732649},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"2ea7c6070fc0f028b59c6ac4fbc80b4c3f36ced1","modified":1591950732649},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"44af3c7a67b86f048deacb451dd454b088631374","modified":1591950732650},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"c70faf9ac87bb168cf1107b2039eb6dda00fae47","modified":1591950732651},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"f7caa98b0da316e167a6ce07d659f85db81c64ae","modified":1591950732651},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"11704f1748e0316c89f09dd708f440d39ceef0cd","modified":1591950732653},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"bab10df1427b07a176afb28f1258080e4ab573ee","modified":1591950732653},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"348dc65683132b768f2340380a1ba71504aa8e43","modified":1591950732654},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"d4532e5f6417d9ba2ebe054521410f80f64a968b","modified":1591950732654},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"b31f88fff690ec8efbbb8163eb01abed98a6ae0f","modified":1591950732655},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"6ef8482c9e8b9ac3ab06e48e69853ac536836905","modified":1591950732656},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"043cadea27a7856d50fb64a83d3c50c21b8e5a14","modified":1591950732668},{"_id":"themes/Butterfly/source/css/_highlight/diff.styl","hash":"bb83b379954dc2e7f5a9915e5ed50da7223e3efa","modified":1591950732668},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"e56379c713d7e175a8486ee43940039f2f1c9fa6","modified":1591950732669},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"32b94940c8288020bb4245941ca587c8aad7c14c","modified":1591950732669},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"f5875982abf021213e1274f615b812b29b5fee56","modified":1591950732670},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"cf4ed5fe1e675f5440e07a6bc1afa49b53e38d5e","modified":1591950732671},{"_id":"themes/Butterfly/source/css/_layout/category.styl","hash":"b5bca389c3185b2794939f0f5dd889e1ed72f6cc","modified":1591950732672},{"_id":"themes/Butterfly/source/css/_layout/flink.styl","hash":"926d4ff56a0b19ae7d3d7ea39212aeb5d0f1841d","modified":1591950732672},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"2dace492e6da44e39ad5cc7eae8bc8bb5a34aaae","modified":1591950732673},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"c526b35696518d017211ab6fd84716ac2aca9135","modified":1591950732674},{"_id":"themes/Butterfly/source/css/_layout/loadding.styl","hash":"7acbbed062bf4070ef998e760491f436b2629738","modified":1591950732675},{"_id":"themes/Butterfly/source/css/_layout/mobile-sidebar.styl","hash":"92c7d42d2fc74f6eab4879a367c1b71634f4f493","modified":1591950732676},{"_id":"themes/Butterfly/source/css/_layout/page.styl","hash":"f2292e7fc76e8064bf442c34b31b0a237692cd60","modified":1591950732676},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"9181061f214ed8e2b48c203e1d3d524edc4b56e7","modified":1591950732677},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"8ee3929503586dc9a8d454cc30ee77f8258befd9","modified":1591950732678},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"1799a33e3f7cdc543227be833d59ef84bb038124","modified":1591950732678},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"0df33f37f7339df71b68a6b781c068e5a344c9cc","modified":1591950732679},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"4c27911ff1432870f328934cf6b171ecb16db1ce","modified":1591950732679},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"d1ad6bbdedf8bead2b0b18519629c731afbab49d","modified":1591950732680},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"583d22f17f1b1f823b757ef32b67f29f7442ea3d","modified":1591950732680},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"d63038b9b9b9eca05e566162d0a8877119768cac","modified":1591950732681},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"c5f6f2f4116a3c98fe70ae68717fccd081ccdf5b","modified":1591950732682},{"_id":"themes/Butterfly/source/css/_tags/gallery.styl","hash":"192bd09d0b6db688467ebead95d0ebec7d3eba06","modified":1591950732684},{"_id":"themes/Butterfly/source/css/_tags/hide.styl","hash":"b64752f484fa4503ba8303cfa7b1f89fbd5dfebb","modified":1591950732685},{"_id":"themes/Butterfly/source/css/_tags/note.styl","hash":"b522d071c320c0aa52fd56f30b0bc9cf923e46d7","modified":1591950732686},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1591950732687},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"55fc3a91dfbd8f15aab2595fb0c68d3981edb629","modified":1591950732682},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"f6f4a7bdaa7199fa521b0d67049a10473d792136","modified":1591950732683},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"a4aa32db60e5cc12bbe3b3a82209379bf8ab62ce","modified":1591950732694},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"0c293c8e72ec7e2432d46eef666b8db16ca6e826","modified":1591950732684},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"7ed0e03733127dd34dc251f5b36e3e7eadd73097","modified":1591950732695},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","hash":"2af6ddbabdd36979cc9c05b117452a1534702c6d","modified":1591950732696},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1591950732696},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","hash":"ed2a7dedc314eb1047d030be2e95d0d5679bc577","modified":1591950732697},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","hash":"8fe48c40c6147811cda154db8b7a3352132bfceb","modified":1591950732698},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","hash":"7295ee03e9ae40f855d0c494a9b84e76a36ffe20","modified":1591950732698},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","hash":"75b3d7025c01947f3d425e592e910458393ee621","modified":1591950732698},{"_id":"themes/Butterfly/source/js/third-party/piao.js","hash":"bc3d3f2afeefea55d9d6ba8dfa798435e1eb1062","modified":1591950732700},{"_id":"public/2020/06/19/GAMES101-学习笔记/index.html","hash":"29fd670c791ea6d1b63afed1b10a412ae3575818","modified":1592580244663},{"_id":"public/2020/06/16/unity-shader学习记录/index.html","hash":"faaf22a5ab6adca94d59b54dff4abe1aef3461c9","modified":1592579498726},{"_id":"public/2020/06/12/Hexo-Github/index.html","hash":"646d330ee6552ef5605c660d1aeb845279446fe2","modified":1592579951366},{"_id":"public/2020/06/12/hello-world/index.html","hash":"a0f254f436deb94bba583797aa94900248a2bd78","modified":1592579498726},{"_id":"public/archives/index.html","hash":"207750cd43ea50a352692e842efdd26ec76110a5","modified":1592583119879},{"_id":"public/archives/2020/index.html","hash":"f565d436faa25a50468773d3078e96bd45b75007","modified":1592583119879},{"_id":"public/archives/2020/06/index.html","hash":"038cc9d652c12186c5421bc0d89731272ccb64f8","modified":1592583119879},{"_id":"public/index.html","hash":"d175df50695c5eba3195094d40f765d8c37b6091","modified":1592583119879},{"_id":"public/tags/笔记/index.html","hash":"0e886f3bd8172466018eb6048ebb3b05a09ffc3c","modified":1592583119879},{"_id":"public/tags/config/index.html","hash":"25ff206574ea3f5b89498f71066a6be1b76745d6","modified":1592583119879},{"_id":"public/tags/教程/index.html","hash":"49a56f6b3b6359336da78cddaaefac54e0204377","modified":1592583119879},{"_id":"public/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1592577668386},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1592577668386},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1592577668386},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1592577668386},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1592577668386},{"_id":"public/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1592577668386},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1592577668386},{"_id":"public/css/index.css","hash":"817ba8be5bdd463183cbd107504640ecb21ca02d","modified":1592577668386},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1592577668386},{"_id":"public/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1592577668386},{"_id":"public/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1592577668386},{"_id":"public/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1592577668386},{"_id":"public/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1592577668386},{"_id":"public/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1592577668386},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1592577668386},{"_id":"public/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1592577668386},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1592577668386},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1592577668386},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1592577668386},{"_id":"public/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1592577668386},{"_id":"public/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1592577668386}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"unity-shader学习记录","date":"2020-06-16T15:05:44.000Z","top_img":"/img/cover/shader.jpg","cover":"/img/cover/shader.jpg","_content":"\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","source":"_posts/unity-shader学习记录.md","raw":"---\ntitle: unity-shader学习记录\ndate: 2020-06-16 23:05:44\ntop_img: /img/cover/shader.jpg\ncover: /img/cover/shader.jpg\ntags: 笔记\n---\n\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","slug":"unity-shader学习记录","published":1,"updated":"2020-06-17T16:14:24.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbmbml7700008wtp9ewtgntf","content":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n"},{"title":"GAMES101_学习笔记","date":"2020-06-19T13:45:43.000Z","top_img":"/img/cover/games101.webp","cover":"/img/cover/games101.webp","mathjax":true,"_content":"\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","source":"_posts/GAMES101-学习笔记.md","raw":"---\ntitle: GAMES101_学习笔记\ndate: 2020-06-19 21:45:43\ntop_img: /img/cover/games101.webp\ncover: /img/cover/games101.webp\ntags: 笔记\nmathjax: true\n---\n\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","slug":"GAMES101-学习笔记","published":1,"updated":"2020-06-19T15:23:35.242Z","_id":"ckbmbmlg500038wtp3qv38h2t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M_{persp-&gt;ortho}*M_{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u_0 = lerp(s, u_{00}, u_{10})$</li>\n<li>$u_1 = lerp(s, u_{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p_0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x_{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’_{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M_{persp-&gt;ortho}*M_{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u_0 = lerp(s, u_{00}, u_{10})$</li>\n<li>$u_1 = lerp(s, u_{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p_0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x_{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’_{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo + Github","date":"2020-06-12T14:11:13.000Z","top_img":"/img/cover/hexo_github.png","cover":"/img/cover/hexo_github.png","description":"配置个人专属博客网站，采坑小结","_content":"这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","source":"_posts/Hexo-Github.md","raw":"---\ntitle: Hexo + Github\ndate: 2020-06-12 22:11:13\ntop_img: /img/cover/hexo_github.png\ncover: /img/cover/hexo_github.png\ndescription: 配置个人专属博客网站，采坑小结\ntags: \n  - config\n  - 教程\n---\n这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","slug":"Hexo-Github","published":1,"updated":"2020-06-19T15:19:01.097Z","_id":"ckbmbmlg600048wtp6xtd2l5w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>"},{"title":"Hello World","top_img":"/img/cover/helloworld.png","cover":"/img/cover/helloworld.png","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntop_img: /img/cover/helloworld.png\ncover: /img/cover/helloworld.png\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-06-12T07:44:17.864Z","updated":"2020-06-16T16:24:51.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbmbmlg700068wtphqtp6c3w","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckbmbml7700008wtp9ewtgntf","tag_id":"ckbmbml7e00018wtp6y7sgxre","_id":"ckbmbml7j00028wtp0s0p7hix"},{"post_id":"ckbmbmlg500038wtp3qv38h2t","tag_id":"ckbmbml7e00018wtp6y7sgxre","_id":"ckbmbmlg700058wtpd1dv1e1n"},{"post_id":"ckbmbmlg600048wtp6xtd2l5w","tag_id":"ckbmbmlg900078wtp7jc2235b","_id":"ckbmbmlga00098wtp7uha5jva"},{"post_id":"ckbmbmlg600048wtp6xtd2l5w","tag_id":"ckbmbmlg900088wtpdbcsavhy","_id":"ckbmbmlga000a8wtpdvk219ef"}],"Tag":[{"name":"笔记","_id":"ckbmbml7e00018wtp6y7sgxre"},{"name":"config","_id":"ckbmbmlg900078wtp7jc2235b"},{"name":"教程","_id":"ckbmbmlg900088wtpdbcsavhy"}]}}