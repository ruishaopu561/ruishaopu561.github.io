{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Butterfly/_config.yml","hash":"2814fb85d7d7cdd7f26134fc95d5dec0fff4a75b","modified":1611130015326},{"_id":"themes/Butterfly/package.json","hash":"43a92e039fe98e01259dc84ee4066b5d5efb8e7f","modified":1594054864768},{"_id":"themes/Butterfly/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1594054864768},{"_id":"themes/Butterfly/README.md","hash":"8e4d01331f9a820ec30fca075c6956859772530e","modified":1594054864768},{"_id":"themes/Butterfly/languages/default.yml","hash":"8cc398208ebd0326d0bdac09cf96b8aeeed78fcc","modified":1594054864768},{"_id":"themes/Butterfly/languages/en.yml","hash":"8cc398208ebd0326d0bdac09cf96b8aeeed78fcc","modified":1594054864768},{"_id":"themes/Butterfly/.github/stale.yml","hash":"cd5a929ce25a6293a9f449e7b80dfe4307326797","modified":1594054864768},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"848871887cc5ea38c50292df7f7c9d9dbb07b5ca","modified":1594054864768},{"_id":"themes/Butterfly/README_CN.md","hash":"4fd3e96f5c18f721118c175c807e19ae874a7793","modified":1594054864768},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"6dc0abceee6a1c4b47d3ecdae81667ffb4a09f88","modified":1594054864768},{"_id":"themes/Butterfly/layout/404.pug","hash":"3ade9903e1e0dedfb11b46d7161f2100defba31e","modified":1594054864768},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE.md","hash":"bc427d7f13fec05cfd2dcc10953cbb2a96bc31be","modified":1594054864768},{"_id":"themes/Butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1594054864768},{"_id":"themes/Butterfly/layout/category.pug","hash":"d014234c26d2c07caaea6703f7b48cb69c51907d","modified":1594054864768},{"_id":"themes/Butterfly/layout/flink.pug","hash":"f922cafc12857cff327d6621ea5517976e85c229","modified":1594054864768},{"_id":"themes/Butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1594054864768},{"_id":"themes/Butterfly/layout/page.pug","hash":"130ab657a6acfe149dbc59e481dc05d4d7d926a3","modified":1594054864768},{"_id":"themes/Butterfly/layout/post.pug","hash":"2e34fd65d36508faec9fd015d6cdb108d4c29b58","modified":1594054864768},{"_id":"themes/Butterfly/layout/tag.pug","hash":"3bb2a700c6d709d2757d55d357eed1fca5644e24","modified":1594054864768},{"_id":"source/_posts/unity-shader学习记录.md","hash":"0ee009ec9da7d70421629f66734a923704eab2b0","modified":1592410464439},{"_id":"source/_posts/GAMES101-学习笔记.md","hash":"58086fd150891d398954b2455a1784ea601ae8ec","modified":1592580215242},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"5265bfbd6514fde10b42f5f5482776450e2bd582","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"855c5d7e427730178c2f6e4f3e816d7fbee40198","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"901122c065cb08589a52911773d9baf01c599faa","modified":1594054864768},{"_id":"source/_posts/Hexo-Github.md","hash":"12d25cf807f8fd8289b160a1be69251b5fdc38fe","modified":1592579941097},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"055747cdb64b27ac707402481e79c82ce946b0d3","modified":1594054864768},{"_id":"source/_posts/hello-world.md","hash":"951d6d2b455faae8e17dd454bf658de7f91ccc15","modified":1611141114007},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"385a186f0e77900db685b97d40bb4d26fa48a4d5","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"9ba725c0f9661a156f82dee35a422fdd4639a5ce","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"b41c97424c588209c0d24817f5120b50933135fd","modified":1594054864768},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1594054864768},{"_id":"themes/Butterfly/scripts/events/replace_config.js","hash":"537e556e76760ce2103f359d5a424c6e2b9a0710","modified":1594054864768},{"_id":"themes/Butterfly/scripts/filters/post_lazyload.js","hash":"4c7f4562183f28acb359b7e826eb0a198086e3f0","modified":1594054864768},{"_id":"themes/Butterfly/scripts/filters/random_cover.js","hash":"0b4775aaa955b75f03648fc1957fb88a6d440803","modified":1594054864768},{"_id":"themes/Butterfly/scripts/helpers/aside_archives.js","hash":"87c63d5b46fdc13724d5d213cdfde608af6a5bb3","modified":1594054864768},{"_id":"themes/Butterfly/scripts/helpers/aside_categories.js","hash":"21c89a1502e9964cb48d32ab0476427cc41b010d","modified":1594054864768},{"_id":"themes/Butterfly/scripts/helpers/page.js","hash":"729a9f40c5bf603036f6e9443db93b1704cf17d9","modified":1594054864768},{"_id":"themes/Butterfly/scripts/helpers/related_post.js","hash":"7ebe4dc2b42094a5b55799c0af5c28d6ab97d25f","modified":1594054864768},{"_id":"themes/Butterfly/scripts/tags/gallery.js","hash":"2fad0a9e6645613631aad36dc3473fe8e032809b","modified":1594054864768},{"_id":"themes/Butterfly/scripts/tags/hide.js","hash":"8c70135d5367b9a589ec92be66841488e9acdd29","modified":1594054864768},{"_id":"themes/Butterfly/scripts/tags/mermaid.js","hash":"53eaff19d8da32e04e2c871300ea495356d633cd","modified":1594054864768},{"_id":"themes/Butterfly/scripts/tags/note.js","hash":"c739846637c48b4779df2f62effb78e15100fd9f","modified":1594054864768},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1591950732689},{"_id":"themes/Butterfly/source/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1591969585041},{"_id":"themes/Butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1591950732689},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1594054864792},{"_id":"themes/Butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1591950732691},{"_id":"themes/Butterfly/source/css/index.styl","hash":"96eb343f77fc891ff5adedb1f4a3fb34ab4ee20f","modified":1594054864792},{"_id":"themes/Butterfly/source/css/var.styl","hash":"907b5ee1d5cb44ebb90493b068c00bef068ef748","modified":1594054864792},{"_id":"themes/Butterfly/source/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1594054864792},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1594054864792},{"_id":"themes/Butterfly/source/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1594054864792},{"_id":"themes/Butterfly/layout/includes/comments/disqus.pug","hash":"821d968122bab8ce1ce04dc553b731eaf8e0d181","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/comments/disqusjs.pug","hash":"050085054a68942e8833c6a4033fb437b6b01e52","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/comments/facebook_comments.pug","hash":"7b7bb7d2b39b639cc8e1edf1274148460796662e","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/comments/gitalk.pug","hash":"e98f5c199a76ad939a29a46c0dcbf7e85ec60ed2","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/comments/index.pug","hash":"f9556b40b00d5a566c64904afa833aa2e0d9449d","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/comments/laibili.pug","hash":"00022f763085b6852bc172b0ba91b0eacb403389","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/comments/utterances.pug","hash":"9427cb07bcfe2bc7198755eeebf60f9fe430a342","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/comments/valine.pug","hash":"4f6e49639896bc8a4d4fe2257502f98ab63f6a7d","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"6ba5794cffb47cfd2727e388b7cd7370c43e3559","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"8ec0609f14c284c3e6120940d7c4d7f1f201cd67","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/comment.pug","hash":"7de136bdce45afa81341b13e61b7a3926e15f03b","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"dd7cd1b3b20873044e0c0ed1280001a0e06ea358","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"2c7a5a097a2f815ba43a4e99c810405da3b9eebc","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/darkmode.pug","hash":"dcc8c01e1b0f8a4960ed873f49fb0f18d9912d21","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/dns_prefetch.pug","hash":"d2f81fadc68532cd27db8895c1834cdefb7e577e","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"ff4ceda534cdd711cfa2cb9e95e36258988674e1","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"47a10164395d8200c8d962df68a01e7deee4053b","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"be1ff710e4381fc684243313dcadf0140d7469de","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"f5c8ec73c797ff3455e732fa7c92c856692f3ce5","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/head/subtitle.pug","hash":"bbdb2280a74cd7b573b8e03e1c2b44c37571ad22","modified":1594054864768},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1591964356920},{"_id":"themes/Butterfly/layout/includes/header/header.pug","hash":"0b50e70efa91519e3ba7fa7a55e9603f33a8e6eb","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"e612fe17bbd8cb39772e9dac54df3fcd1da99ba6","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"addeb5765ab0635c665dcca99f7918561131ae09","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"9c50171335c65533af09a1c11648860b59be3299","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0d684f897fcdfe1e98300851b7fd955a30b68dd9","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/loading/loading-js.pug","hash":"3cf431a4f04997b55873f7099c1402155b19cc95","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/math/index.pug","hash":"ec97f284626b67208370b5084e5c5822844fa30a","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/math/katex.pug","hash":"73356f1068c7426597e268d6c4aefa2b0ac3a1d9","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/math/mathjax.pug","hash":"6ccfaa776fc913ccf8b34825d918ab2b4d457434","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/math/mermaid.pug","hash":"db848ff451d4c58670af415882ca6bb2e0da971b","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"53cd1b89dc4bc45c315a2f54bfce9d6c3a695f27","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/mixins/post-ui.pug","hash":"40108322ce7f5b5ac52765ca39901fa2c00348d6","modified":1594054864768},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1591950732692},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/index.pug","hash":"d12fab033fb32b55abbc9be9b04cc6ab6465b98e","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"b7f1b9ff32ea868965e5dbb533c0117ce195663f","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"8efc0b7886bdb5959e173b5e11f5ffb8d1c5230e","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"6612174871d833981f1a4a4ec67bc0fbd6913fd8","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/search/local-search.pug","hash":"a45b5453e35479e58cd44b6bd2af0e08789890af","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/share/addtoany.pug","hash":"bbf5b70460b17c4fecb9ee6880aa71cdb2d807a8","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/share/index.pug","hash":"c341aaa00113681b22f945f5004e6b22c8a0ca69","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/share/share-js.pug","hash":"828a04c6e8e3a56c3c7f3c9bb1ecf4f99ed842fe","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1591950732648},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1591950732648},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"b4acf48c98ba2a6a5a5fb5387a0fd610bdfd55ef","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"3f7de99f4307ac9bfd89e669aaa7c2ae54d5224a","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"2e940de1a6261fd378e16e4cd3362a9d69c12f50","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"edf9658dbb95c964e4c6d60bd71d1dc7ebfbb0ac","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"8274404ec2f83f1ba6439d42e8a4e29e932067ac","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"56d27e39fa050a4d311d92b572ce291d7618026a","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"9fe3e264236835cfb6a91f54ee96bb3a79e36539","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"07eebb9d024feba44a2c66e04aef19151df8991c","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"c0309c49a92c1176f008ad322f86a8a19031b41e","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"6caff3cb958ccb0da7d88b51d87e22d27fcd9625","modified":1594054864768},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"15fb3730f829e237c102a70ab9781178471fd786","modified":1594054864768},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"d9d19c2f5dbe671815b6048ff40b876e02d0fd7b","modified":1594054864768},{"_id":"themes/Butterfly/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1594054864768},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"4a61f436cd9a44a3bb4259549b05adf72cd941d7","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"efceb8105830544cef5e4afad3243326b3118fc1","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"964d16c30f307ec354b47375aa5f00f0417c7bf0","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"aeadbc2b3a057ab11f409b584d8c39c1d72ed0e7","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/category.styl","hash":"7267043e52a9e620adfa860bdb3e4de400ff2596","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/flink.styl","hash":"0631c50cdccd29ca41fbac3423b2fd91a9be49b8","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"d8709e29efcfa0a7356384026dfbaac8861d3baa","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"a23ff8c52bfc581a741158c75f3d4923c4cdf810","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/loadding.styl","hash":"144ef01b03ae34d3ede4b9aa18f4c8cd3d6651ea","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/mobile-sidebar.styl","hash":"5492d68c1c9bb85898d41b357f695d6fb17ec646","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/page.styl","hash":"970bd971b06411be85146c97ca30884ff3847910","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"d6f0b7d9dc10761c15a5a2b84cc63e914a10d339","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"e20057cc5a065078cb57821a63595ef9a0c36648","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"1103f2cead8ab1aa9945c20c7d608bb4b829d2cd","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"92b615795f02eff2a018edb425f923968c9e9814","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"9a44881bd4c2aea0b0774809d91d58e4067496ed","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"33da3da65715ce1a85b8ecab92e0eab6ce620a58","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"0fcfeef99c0bef8d48be9180b6fed5aace55acba","modified":1594054864772},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"fa20ccacd51b0c87f4a9ae107bb20b629d5953ab","modified":1594054864792},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"919f0a869203a03ca783dd3fc9df1aeb229de2c2","modified":1594054864792},{"_id":"themes/Butterfly/source/css/_tags/gallery.styl","hash":"d6af5c4f1966b5b575427c117712c173e23657ad","modified":1594054864792},{"_id":"themes/Butterfly/source/css/_tags/hide.styl","hash":"a1de1df9f3cff44bcee7822107ec1e51d9a1b0b1","modified":1594054864792},{"_id":"themes/Butterfly/source/css/_tags/note.styl","hash":"1ec06d5ac4148798babd2475a5d10f0d3a1b5870","modified":1594054864792},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1591950732687},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"641ef2bc7af135c17fd90f3f974e78ebbaf1ac13","modified":1594054864792},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"e31b475cbac2af8d3401fba6382d34968c8063ef","modified":1594054864792},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1594054864792},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"da791f46239eabbbf28eb30b9e441f1ac2a8ced1","modified":1594054864792},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1594054864792},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1594054864792},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1591950732696},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1594054864792},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1594054864792},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1594054864792},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1594054864792},{"_id":"themes/Butterfly/source/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1594054864792},{"_id":"public/2020/06/19/GAMES101-学习笔记/index.html","hash":"b570a49f3ca304c0b2003e450e734fa6aaba495a","modified":1611141149998},{"_id":"public/2020/06/16/unity-shader学习记录/index.html","hash":"7f6a6bd1bbd22251e830b59764cd7a93ae2cfc00","modified":1611140793523},{"_id":"public/2020/06/12/Hexo-Github/index.html","hash":"1102fcb83b728a2912c8b1ffe5263f7985060b53","modified":1611141149998},{"_id":"public/2020/06/12/hello-world/index.html","hash":"4e65790fc2e8494742df23986e51790289e78255","modified":1611141149998},{"_id":"public/archives/index.html","hash":"529f3ba361e4d4bf6e0930f240dfb7eeb4759204","modified":1611141149998},{"_id":"public/archives/2020/index.html","hash":"3c3ccbfc1dc254d605864819c15751596380f21e","modified":1611141149998},{"_id":"public/archives/2020/06/index.html","hash":"31e6fedfcad6b1143a529ff5c96d7ebc1b300a1b","modified":1611141149998},{"_id":"public/index.html","hash":"372ad901e3b40de22b46a2cefc72e3a3895f5d7f","modified":1611141149998},{"_id":"public/tags/笔记/index.html","hash":"3b85df899062cb0bdc580f03e6e770dcb1996aba","modified":1611141149998},{"_id":"public/tags/config/index.html","hash":"4af138054c7efd8e663db75f69473a653a768b6f","modified":1611141149998},{"_id":"public/tags/教程/index.html","hash":"7f90505f6fa7e2710b368b2f064f509dcebc5592","modified":1611141149998},{"_id":"public/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1592577668386},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1592577668386},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1592577668386},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1611128459329},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1592577668386},{"_id":"public/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1592577668386},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1592577668386},{"_id":"public/css/index.css","hash":"817ba8be5bdd463183cbd107504640ecb21ca02d","modified":1592577668386},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1592577668386},{"_id":"public/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1592577668386},{"_id":"public/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1592577668386},{"_id":"public/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1592577668386},{"_id":"public/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1592577668386},{"_id":"public/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1592577668386},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1592577668386},{"_id":"public/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1592577668386},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1592577668386},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1592577668386},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1592577668386},{"_id":"public/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1592577668386},{"_id":"public/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1592577668386},{"_id":"source/_posts/c++基础-1.md","hash":"9cb2d838ac5f3505bb4793ecd0f677697541fd0a","modified":1611129699080},{"_id":"public/2021/01/20/c++基础-1/index.html","hash":"cc242a80f13ae22075515b9dc9b760b66ef8b622","modified":1611141149998},{"_id":"public/2020/07/07/hello-world/index.html","hash":"a70ed05a468fef61881d671c1805493d4641ed0c","modified":1611132442193},{"_id":"public/archives/2020/07/index.html","hash":"b1a4052e77a21abf47f5607c4cb81f85a82bce8c","modified":1611140793523},{"_id":"public/archives/2021/index.html","hash":"e3e9a8bf4babf9364945bf0ba5a85a958625ce6a","modified":1611141149998},{"_id":"public/archives/2021/01/index.html","hash":"3c75188a63ec055765c785ede756313456ce8d7e","modified":1611141149998},{"_id":"public/tags/c/index.html","hash":"9c5a41d31c626ec19171c41d998a4ce8884742a5","modified":1611141149998},{"_id":"public/tags/intern/index.html","hash":"46c2dbcf17721716c760c69dadc972973bd3e1d2","modified":1611141149998},{"_id":"source/_posts/c++基础-2.md","hash":"6b583d1b918ffe1bf0c0f82733d6a200587910ae","modified":1611140760990},{"_id":"public/2021/01/20/c++基础-2/index.html","hash":"3a9a5e2ab262c6e78005b82fbeb895bfaa5772ed","modified":1611140793523}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"unity-shader学习记录","date":"2020-06-16T15:05:44.000Z","top_img":"/img/cover/shader.jpg","cover":"/img/cover/shader.jpg","_content":"\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","source":"_posts/unity-shader学习记录.md","raw":"---\ntitle: unity-shader学习记录\ndate: 2020-06-16 23:05:44\ntop_img: /img/cover/shader.jpg\ncover: /img/cover/shader.jpg\ntags: 笔记\n---\n\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","slug":"unity-shader学习记录","published":1,"updated":"2020-06-17T16:14:24.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbmbml7700008wtp9ewtgntf","content":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n"},{"title":"GAMES101_学习笔记","date":"2020-06-19T13:45:43.000Z","top_img":"/img/cover/games101.webp","cover":"/img/cover/games101.webp","mathjax":true,"_content":"\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","source":"_posts/GAMES101-学习笔记.md","raw":"---\ntitle: GAMES101_学习笔记\ndate: 2020-06-19 21:45:43\ntop_img: /img/cover/games101.webp\ncover: /img/cover/games101.webp\ntags: 笔记\nmathjax: true\n---\n\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","slug":"GAMES101-学习笔记","published":1,"updated":"2020-06-19T15:23:35.242Z","_id":"ckbmbmlg500038wtp3qv38h2t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M_{persp-&gt;ortho}*M_{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u_0 = lerp(s, u_{00}, u_{10})$</li>\n<li>$u_1 = lerp(s, u_{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p_0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x_{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’_{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M_{persp-&gt;ortho}*M_{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u_0 = lerp(s, u_{00}, u_{10})$</li>\n<li>$u_1 = lerp(s, u_{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p_0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L_o(a,\\omega_o)<br>  =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x_{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’_{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo + Github","date":"2020-06-12T14:11:13.000Z","top_img":"/img/cover/hexo_github.png","cover":"/img/cover/hexo_github.png","description":"配置个人专属博客网站，采坑小结","_content":"这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","source":"_posts/Hexo-Github.md","raw":"---\ntitle: Hexo + Github\ndate: 2020-06-12 22:11:13\ntop_img: /img/cover/hexo_github.png\ncover: /img/cover/hexo_github.png\ndescription: 配置个人专属博客网站，采坑小结\ntags: \n  - config\n  - 教程\n---\n这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","slug":"Hexo-Github","published":1,"updated":"2020-06-19T15:19:01.097Z","_id":"ckbmbmlg600048wtp6xtd2l5w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>"},{"title":"Hello World","date":"2020-06-12T08:46:15.000Z","top_img":"/img/cover/helloworld.png","cover":"/img/cover/helloworld.png","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2020-06-12 16:46:15\ntop_img: /img/cover/helloworld.png\ncover: /img/cover/helloworld.png\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2021-01-20T11:11:54.007Z","_id":"ckbmbmlg700068wtphqtp6c3w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"c++ 基础(1)","date":"2021-01-20T06:51:34.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### 说一下static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","source":"_posts/c++基础-1.md","raw":"---\ntitle: c++ 基础(1)\ndate: 2021-01-20 14:51:34\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### 说一下static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","slug":"c++基础-1","published":1,"updated":"2021-01-20T08:01:39.080Z","_id":"ckk54abzs0000rb6w5oxz0w3e","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"说一下static关键字的作用\"><a href=\"#说一下static关键字的作用\" class=\"headerlink\" title=\"说一下static关键字的作用\"></a>说一下static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"说一下static关键字的作用\"><a href=\"#说一下static关键字的作用\" class=\"headerlink\" title=\"说一下static关键字的作用\"></a>说一下static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n"},{"title":"c++基础(2)","date":"2021-01-20T08:46:15.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","source":"_posts/c++基础-2.md","raw":"---\ntitle: c++基础(2)\ndate: 2021-01-20 16:46:15\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","slug":"c++基础-2","published":1,"updated":"2021-01-20T11:06:00.990Z","_id":"ckk56np5f0000ef6w54gtdvb2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckbmbml7700008wtp9ewtgntf","tag_id":"ckbmbml7e00018wtp6y7sgxre","_id":"ckbmbml7j00028wtp0s0p7hix"},{"post_id":"ckbmbmlg500038wtp3qv38h2t","tag_id":"ckbmbml7e00018wtp6y7sgxre","_id":"ckbmbmlg700058wtpd1dv1e1n"},{"post_id":"ckbmbmlg600048wtp6xtd2l5w","tag_id":"ckbmbmlg900078wtp7jc2235b","_id":"ckbmbmlga00098wtp7uha5jva"},{"post_id":"ckbmbmlg600048wtp6xtd2l5w","tag_id":"ckbmbmlg900088wtpdbcsavhy","_id":"ckbmbmlga000a8wtpdvk219ef"},{"post_id":"ckk54abzs0000rb6w5oxz0w3e","tag_id":"ckk54qmlo00048e6we2o711hp","_id":"ckk54qmlp00058e6wgvzea4k9"},{"post_id":"ckk54abzs0000rb6w5oxz0w3e","tag_id":"ckbmbml7e00018wtp6y7sgxre","_id":"ckk54qmlp00068e6wetjw3vde"},{"post_id":"ckk54abzs0000rb6w5oxz0w3e","tag_id":"ckk54qxe200078e6w72sk9ibx","_id":"ckk54qxe300088e6w3naqazph"},{"post_id":"ckk56np5f0000ef6w54gtdvb2","tag_id":"ckk54qmlo00048e6we2o711hp","_id":"ckk56np5m0001ef6wd4fq1083"},{"post_id":"ckk56np5f0000ef6w54gtdvb2","tag_id":"ckk54qxe200078e6w72sk9ibx","_id":"ckk56np5m0002ef6w4hr3c43j"},{"post_id":"ckk56np5f0000ef6w54gtdvb2","tag_id":"ckbmbml7e00018wtp6y7sgxre","_id":"ckk56np5m0003ef6w8y065f0u"}],"Tag":[{"name":"笔记","_id":"ckbmbml7e00018wtp6y7sgxre"},{"name":"config","_id":"ckbmbmlg900078wtp7jc2235b"},{"name":"教程","_id":"ckbmbmlg900088wtpdbcsavhy"},{"name":"c++ 笔记","_id":"ckk54pz1200008e6wepfzf1fs"},{"name":"c++, 笔记","_id":"ckk54q83000028e6w8chi5eaf"},{"name":"c++","_id":"ckk54qmlo00048e6we2o711hp"},{"name":"intern","_id":"ckk54qxe200078e6w72sk9ibx"}]}}