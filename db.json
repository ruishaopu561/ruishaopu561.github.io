{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Butterfly/LICENSE","hash":"e7e7b7677bb19563a9013e936486bdefeb761d07","modified":1591950732609},{"_id":"themes/Butterfly/README.md","hash":"31708ead9c9a494d5fa2c8ec5fc3cf675f13240e","modified":1591950732610},{"_id":"themes/Butterfly/README_CN.md","hash":"6f42d4ab0dfd564eb7b434867812c9f4a4e163cc","modified":1591950732611},{"_id":"themes/Butterfly/_config.yml","hash":"55d07dcf34edb7eb6beb72ca83e14e1efe91647a","modified":1617007056754},{"_id":"themes/Butterfly/package.json","hash":"56e967481d2996e4618455cf372e592884f929b1","modified":1591950732658},{"_id":"source/_posts/GAMES101-学习笔记.md","hash":"ee3c555a41bbcf3ca6986311d413c69b4e969549","modified":1648210937112},{"_id":"source/_posts/Hexo-Github.md","hash":"34a895d0802dc9f2fd1bf02b0b42fd0fc396ac5c","modified":1648210937112},{"_id":"source/_posts/c++基础-1.md","hash":"4861408d4887673d42e7bad55ecf66208bdf3c5e","modified":1617007056749},{"_id":"source/_posts/c++基础-2.md","hash":"ce0fb71c153cd26e146f23968f4bcce9b5b273a2","modified":1617007056749},{"_id":"source/_posts/c++基础-3.md","hash":"e5f381ba43f76b9d78c932c9a06ccaf7304327ec","modified":1617007056750},{"_id":"source/_posts/hello-world.md","hash":"f8664e178f8ba2ce5f40ed30dbe1943f57a70877","modified":1617007056751},{"_id":"source/_posts/unity-shader学习记录.md","hash":"9869bda8caf78c5dc6dcfa63ec2dcffc090883a8","modified":1648210937117},{"_id":"source/_posts/数据库基础-1.md","hash":"80f99fc015d00da99d87af4ec9c766c994860690","modified":1617007056751},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE.md","hash":"8f7a0f8d4bfc97ba106128828a33a9cc0a295194","modified":1591950732604},{"_id":"themes/Butterfly/.github/stale.yml","hash":"70467ce772e68de57a4bf2ac285f1c0b122f25f5","modified":1591950732604},{"_id":"themes/Butterfly/languages/default.yml","hash":"3492594f5aed8ab7ee46c212bc1030b8140c4682","modified":1591950732612},{"_id":"themes/Butterfly/languages/en.yml","hash":"3492594f5aed8ab7ee46c212bc1030b8140c4682","modified":1591950732613},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"2471c83209aba78883ef1337a5a47b4a2654061d","modified":1591950732613},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"430789bde19a81103eddaa50b68376a3080a2cac","modified":1591950732614},{"_id":"themes/Butterfly/layout/404.pug","hash":"2d58b62240a5ea1119cc19e647e9a17efe1c7243","modified":1591950732614},{"_id":"themes/Butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1591950732615},{"_id":"themes/Butterfly/layout/category.pug","hash":"90e56274a7c853f6f30337011f9c9d6d035950dc","modified":1591950732615},{"_id":"themes/Butterfly/layout/flink.pug","hash":"391c3af22057ddd2a44da475710e6ff7866d954e","modified":1591950732615},{"_id":"themes/Butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1591950732656},{"_id":"themes/Butterfly/layout/page.pug","hash":"5cef945ed21199da6950cb3806d1faa45d3130c1","modified":1591950732657},{"_id":"themes/Butterfly/layout/post.pug","hash":"ace5cefcd90d34e09119bedb064c34238f653687","modified":1591950732657},{"_id":"themes/Butterfly/layout/tag.pug","hash":"e658aa76a11d1e18ec00131d9cec1a38b3d6a62e","modified":1591950732658},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"0537eb7e279c213430518e0674a380769d52f425","modified":1591950732616},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"9d98c38f1634987ef22a3cdb391b1f9fa2f806d2","modified":1591950732622},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"47b70ee674f8c6a07139f1915e6c4fc0d6f31ab5","modified":1591950732623},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"603a800d85acfd533fca8603fc49c86a4caa10a0","modified":1591950732635},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"fa6b9b365c75120b90e069e439843b9def8c7ee5","modified":1591950732642},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"418349c6a31f246d91aab53640ded1ae674463aa","modified":1591950732643},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"3981532dfffb57d00e3ebf5f590a2094d426898a","modified":1591950732647},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"5f6127ede7d139891208340b5cf5bf9314e4be7d","modified":1591950732659},{"_id":"themes/Butterfly/scripts/events/replace_config.js","hash":"39fabaae6943bbafb8248ee81ae9b32e1145c84a","modified":1591950732660},{"_id":"themes/Butterfly/scripts/filters/post_lazyload.js","hash":"e2bd91061e7481c6fa787de22257744172508ece","modified":1591950732661},{"_id":"themes/Butterfly/scripts/filters/random_cover.js","hash":"8e44ec5c9a50b01790186cb6c319b70a42581add","modified":1591950732661},{"_id":"themes/Butterfly/scripts/helpers/aside_archives.js","hash":"45be3eda5fc8c3fcf70cb13beece28ae3884b721","modified":1591950732662},{"_id":"themes/Butterfly/scripts/helpers/aside_categories.js","hash":"625ef99594006b4ac6b721fa6a7da785b3dd4770","modified":1591950732662},{"_id":"themes/Butterfly/scripts/helpers/page.js","hash":"4e6cffc4ecf5c600dc50b5677a21c3569e2ed043","modified":1591950732663},{"_id":"themes/Butterfly/scripts/helpers/related_post.js","hash":"e770feb749ac76214ce1fb42579ecda68e80e433","modified":1591950732664},{"_id":"themes/Butterfly/scripts/tags/gallery.js","hash":"1735602a8da89b3ee961899c0eb4c9e6116b580c","modified":1591950732665},{"_id":"themes/Butterfly/scripts/tags/hide.js","hash":"92ee53c76906a2d661ccdf68058c20ab2c048b15","modified":1591950732666},{"_id":"themes/Butterfly/scripts/tags/mermaid.js","hash":"46d3c4c6a38d750d1ad9ca695d6c0df62b7107d6","modified":1591950732666},{"_id":"themes/Butterfly/scripts/tags/note.js","hash":"b6acc0f4f994692d124c7a251a2606afde3fcf9d","modified":1591950732666},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1611198006744},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1591950732689},{"_id":"themes/Butterfly/source/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611198006744},{"_id":"themes/Butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1611198006744},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611198006744},{"_id":"themes/Butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1611198006744},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1611198006744},{"_id":"themes/Butterfly/source/css/index.styl","hash":"14161794cdd22414641239a09e2db613f1999d00","modified":1591950732687},{"_id":"themes/Butterfly/source/css/var.styl","hash":"4314b50a909c4e47fc767e50e8f1798754436062","modified":1591950732688},{"_id":"themes/Butterfly/source/js/main.js","hash":"b6343a3fd916672bfad295f939504fe632ec1cd8","modified":1591950732694},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"0a48ec7f2b01f2ea3f86a12af63a7399cbfaccd6","modified":1591950732700},{"_id":"themes/Butterfly/source/js/utils.js","hash":"e640956180cc604948e76979cdaab40286e4a04e","modified":1591950732701},{"_id":"themes/Butterfly/layout/includes/comments/disqus.pug","hash":"5ae50a271fe5a49f4012555657db028b7113612b","modified":1591950732618},{"_id":"themes/Butterfly/layout/includes/comments/disqusjs.pug","hash":"e96dd925a1d17cfb4fe5ac13561982c9b13d6b53","modified":1591950732618},{"_id":"themes/Butterfly/layout/includes/comments/facebook_comments.pug","hash":"9d4ed57b91ad520b95d220980add8477ce968618","modified":1591950732619},{"_id":"themes/Butterfly/layout/includes/comments/gitalk.pug","hash":"bb4de1b40ae07b27dda4e3e529687f6c1a9196ca","modified":1591950732619},{"_id":"themes/Butterfly/layout/includes/comments/index.pug","hash":"43aa3a3087ffcf319a06043c00e1cd8fbd071d79","modified":1591950732620},{"_id":"themes/Butterfly/layout/includes/comments/laibili.pug","hash":"1d5d1b2cf17271cc6d69071f6df11fe477ae8bb3","modified":1591950732621},{"_id":"themes/Butterfly/layout/includes/comments/utterances.pug","hash":"8ef3dc1a27c19645ac054e30594ed1930b1c56f0","modified":1591950732621},{"_id":"themes/Butterfly/layout/includes/comments/valine.pug","hash":"6d930ef62b44f9789f25a81b1baae8f1a0988e1d","modified":1591950732622},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"6f6bc88b300d22b18c7b1a1ab3b75661040dcf44","modified":1591950732624},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"036213b05df9e51250c2734854de7a096a9ed8c2","modified":1591950732624},{"_id":"themes/Butterfly/layout/includes/head/comment.pug","hash":"2dbb3378929e2f1ead3bbc4a88fafd72c6632ff8","modified":1591950732625},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"9265b536774344e4e58747bba62286b361d0279d","modified":1591950732625},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"4dea5574fa33f688a2a80d4e070e6c0ba9a62480","modified":1591950732627},{"_id":"themes/Butterfly/layout/includes/head/darkmode.pug","hash":"e44d63ee21b7ee247927f0189a783ffa9ba075fd","modified":1591950732627},{"_id":"themes/Butterfly/layout/includes/head/dns_prefetch.pug","hash":"9e86a17cf4dfc9191bba550dd27f874f4c2180fb","modified":1591950732628},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"393e641a35174f26318b8724eddaf1a0b1386636","modified":1591950732628},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"a84dac02e9d30c9c8e7ed895214d46cf2d2af3db","modified":1591950732629},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"e4fb9e5c72ca05d595f0959893c2fe03b8f478e2","modified":1591950732629},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"2d267fcc926505fcc5ebc9f59146555b32654c7e","modified":1591950732631},{"_id":"themes/Butterfly/layout/includes/head/subtitle.pug","hash":"a305d861db7951ea8b7961f8528bca453d850b16","modified":1591950732631},{"_id":"themes/Butterfly/layout/includes/header/header.pug","hash":"8011ca7bc0d218f6cfed2e84dd8b91be05886451","modified":1591950732632},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"12461e6c7efcf0135e0a6fd85f425606818d4f19","modified":1591950732633},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"4a57762f9b5ce4f30088d2552a61a016acdc93ca","modified":1591950732633},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"2bee87cc95078baeab85dd5efec9b0bebb2170f5","modified":1591950732633},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0758817464c300f785384ea21bf096f5010c4f96","modified":1591950732634},{"_id":"themes/Butterfly/layout/includes/loading/loading-js.pug","hash":"3a605e29a0607c315c0566f2a1c6487b4aa98140","modified":1591950732635},{"_id":"themes/Butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1591950732636},{"_id":"themes/Butterfly/layout/includes/math/index.pug","hash":"403601a903d02ef0a103d18909a6eb0b088fcb4c","modified":1591950732636},{"_id":"themes/Butterfly/layout/includes/math/katex.pug","hash":"60bd18e051a442d5ce25325a55982922ab15be04","modified":1591950732637},{"_id":"themes/Butterfly/layout/includes/math/mathjax.pug","hash":"9f10622c73c2c87d3502660eb933af654d2600b4","modified":1591950732637},{"_id":"themes/Butterfly/layout/includes/math/mermaid.pug","hash":"41f6c6c9d753ed97ab2adef47f13595f8aebb464","modified":1591950732638},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"15e2c600f7ded4ffdcaa94ef728f22d883fe6038","modified":1591950732639},{"_id":"themes/Butterfly/layout/includes/mixins/post-ui.pug","hash":"648b09cc1c2c1720033b4eab1936d44070e398db","modified":1591950732640},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/index.pug","hash":"e9eacd936c259d8f10e1becdd6e3ca129ea0e942","modified":1591950732641},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"06e87ad69670c1090210b3e4df86a2ada98553bc","modified":1591950732641},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"547a2737cd3ac45272a75561f5b5438d72d10f6d","modified":1591950732642},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"ed228c196ceaae30e78818e06ce8f29617cf9ec7","modified":1591950732643},{"_id":"themes/Butterfly/layout/includes/search/algolia.pug","hash":"3d2b2de0e199ab1fb151f41f2bbaac909f3d3d12","modified":1591950732644},{"_id":"themes/Butterfly/layout/includes/search/index.pug","hash":"66b4f4e8119e987cd3f9907298689a1408a05859","modified":1591950732645},{"_id":"themes/Butterfly/layout/includes/search/local-search.pug","hash":"e24b08e7253e78d3088d7267188a1ca18b6b5315","modified":1591950732645},{"_id":"themes/Butterfly/layout/includes/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1591950732646},{"_id":"themes/Butterfly/layout/includes/share/addtoany.pug","hash":"4108ab6b91461254901f19ed3e5e082e437324aa","modified":1591950732646},{"_id":"themes/Butterfly/layout/includes/share/index.pug","hash":"af2f09d374a55983d1ac695848ccfae50629f439","modified":1591950732647},{"_id":"themes/Butterfly/layout/includes/share/share-js.pug","hash":"43643295be651fb3d2cd88ebf81544fde3131489","modified":1591950732647},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"74fc2a62e125f28947ec9cd60f968023da766adb","modified":1591950732649},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"2ea7c6070fc0f028b59c6ac4fbc80b4c3f36ced1","modified":1591950732649},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"44af3c7a67b86f048deacb451dd454b088631374","modified":1591950732650},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"c70faf9ac87bb168cf1107b2039eb6dda00fae47","modified":1591950732651},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"f7caa98b0da316e167a6ce07d659f85db81c64ae","modified":1591950732651},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"11704f1748e0316c89f09dd708f440d39ceef0cd","modified":1591950732653},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"bab10df1427b07a176afb28f1258080e4ab573ee","modified":1591950732653},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"348dc65683132b768f2340380a1ba71504aa8e43","modified":1591950732654},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"d4532e5f6417d9ba2ebe054521410f80f64a968b","modified":1591950732654},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"b31f88fff690ec8efbbb8163eb01abed98a6ae0f","modified":1591950732655},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"6ef8482c9e8b9ac3ab06e48e69853ac536836905","modified":1591950732656},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"043cadea27a7856d50fb64a83d3c50c21b8e5a14","modified":1591950732668},{"_id":"themes/Butterfly/source/css/_highlight/diff.styl","hash":"bb83b379954dc2e7f5a9915e5ed50da7223e3efa","modified":1591950732668},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"e56379c713d7e175a8486ee43940039f2f1c9fa6","modified":1591950732669},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"32b94940c8288020bb4245941ca587c8aad7c14c","modified":1591950732669},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"f5875982abf021213e1274f615b812b29b5fee56","modified":1591950732670},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"cf4ed5fe1e675f5440e07a6bc1afa49b53e38d5e","modified":1591950732671},{"_id":"themes/Butterfly/source/css/_layout/category.styl","hash":"b5bca389c3185b2794939f0f5dd889e1ed72f6cc","modified":1591950732672},{"_id":"themes/Butterfly/source/css/_layout/flink.styl","hash":"926d4ff56a0b19ae7d3d7ea39212aeb5d0f1841d","modified":1591950732672},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"2dace492e6da44e39ad5cc7eae8bc8bb5a34aaae","modified":1591950732673},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"c526b35696518d017211ab6fd84716ac2aca9135","modified":1591950732674},{"_id":"themes/Butterfly/source/css/_layout/loadding.styl","hash":"7acbbed062bf4070ef998e760491f436b2629738","modified":1591950732675},{"_id":"themes/Butterfly/source/css/_layout/mobile-sidebar.styl","hash":"92c7d42d2fc74f6eab4879a367c1b71634f4f493","modified":1591950732676},{"_id":"themes/Butterfly/source/css/_layout/page.styl","hash":"f2292e7fc76e8064bf442c34b31b0a237692cd60","modified":1591950732676},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"9181061f214ed8e2b48c203e1d3d524edc4b56e7","modified":1591950732677},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"8ee3929503586dc9a8d454cc30ee77f8258befd9","modified":1591950732678},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"1799a33e3f7cdc543227be833d59ef84bb038124","modified":1591950732678},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"0df33f37f7339df71b68a6b781c068e5a344c9cc","modified":1591950732679},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"4c27911ff1432870f328934cf6b171ecb16db1ce","modified":1591950732679},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"d1ad6bbdedf8bead2b0b18519629c731afbab49d","modified":1591950732680},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"583d22f17f1b1f823b757ef32b67f29f7442ea3d","modified":1591950732680},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"d63038b9b9b9eca05e566162d0a8877119768cac","modified":1591950732681},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"c5f6f2f4116a3c98fe70ae68717fccd081ccdf5b","modified":1591950732682},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"55fc3a91dfbd8f15aab2595fb0c68d3981edb629","modified":1591950732682},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"f6f4a7bdaa7199fa521b0d67049a10473d792136","modified":1591950732683},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"0c293c8e72ec7e2432d46eef666b8db16ca6e826","modified":1591950732684},{"_id":"themes/Butterfly/source/css/_tags/gallery.styl","hash":"192bd09d0b6db688467ebead95d0ebec7d3eba06","modified":1591950732684},{"_id":"themes/Butterfly/source/css/_tags/hide.styl","hash":"b64752f484fa4503ba8303cfa7b1f89fbd5dfebb","modified":1591950732685},{"_id":"themes/Butterfly/source/css/_tags/note.styl","hash":"b522d071c320c0aa52fd56f30b0bc9cf923e46d7","modified":1591950732686},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1611198006744},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"a4aa32db60e5cc12bbe3b3a82209379bf8ab62ce","modified":1591950732694},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"7ed0e03733127dd34dc251f5b36e3e7eadd73097","modified":1591950732695},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","hash":"2af6ddbabdd36979cc9c05b117452a1534702c6d","modified":1591950732696},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","hash":"ed2a7dedc314eb1047d030be2e95d0d5679bc577","modified":1591950732697},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","hash":"8fe48c40c6147811cda154db8b7a3352132bfceb","modified":1591950732698},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","hash":"7295ee03e9ae40f855d0c494a9b84e76a36ffe20","modified":1591950732698},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","hash":"75b3d7025c01947f3d425e592e910458393ee621","modified":1591950732698},{"_id":"themes/Butterfly/source/js/third-party/piao.js","hash":"bc3d3f2afeefea55d9d6ba8dfa798435e1eb1062","modified":1591950732700},{"_id":"public/2021/01/21/数据库基础-1/index.html","hash":"c01af82350b49241953f9d93118eb5e5c34d694c","modified":1663758141427},{"_id":"public/2021/01/20/c++基础-3/index.html","hash":"6e165bb69846651678b9ee67497ff0ad10a1569c","modified":1663758141427},{"_id":"public/2021/01/20/c++基础-2/index.html","hash":"7c7ce18886c4d4758eb54db575460aee1437a8ee","modified":1663758141427},{"_id":"public/2021/01/20/c++基础-1/index.html","hash":"b6fe2c9fae2255d1d20908fdcd3acfbf577aef2b","modified":1663758141427},{"_id":"public/2020/06/19/GAMES101-学习笔记/index.html","hash":"74beb0e0ecad795c5b4e1d7270ef2d5bd1563128","modified":1663758141427},{"_id":"public/2020/06/16/unity-shader学习记录/index.html","hash":"1ea360f6bfa606a0813520dd71567588b7b8897d","modified":1663758141427},{"_id":"public/2020/06/12/Hexo-Github/index.html","hash":"83e302c4d7c82ec30527b8031e3b03a71bea0a20","modified":1663758141427},{"_id":"public/2020/06/12/hello-world/index.html","hash":"9b287156cdd4f96bb193bf8994100d311b749667","modified":1663758141427},{"_id":"public/archives/index.html","hash":"25561b84f52e78a335fb52fc5ee5c9e331082fed","modified":1663758141427},{"_id":"public/archives/2020/index.html","hash":"64be7e7f75b2630945294bc2aac73977d5d91bf5","modified":1663758141427},{"_id":"public/archives/2020/06/index.html","hash":"e14db4a1716e6cbc9a94d1152a91007a4c83cb8e","modified":1663758141427},{"_id":"public/archives/2021/index.html","hash":"eb31cfbcd4d5bf555983cc35d7e7091c9cd2b5dc","modified":1663758141427},{"_id":"public/archives/2021/01/index.html","hash":"31a2b05e80719e49e6a0b574b179222aa2c660c7","modified":1663758141427},{"_id":"public/index.html","hash":"1c9536e0bbc993622a24380ecb40a0f8eab6b11b","modified":1663758141427},{"_id":"public/tags/笔记/index.html","hash":"25683893f52968e54b5ba207550a5e6760523b12","modified":1663758141427},{"_id":"public/tags/config/index.html","hash":"8c4856d5c6b6cd4e5e48b9bd0d3f16f7d5a3881a","modified":1663758141427},{"_id":"public/tags/教程/index.html","hash":"81642d558d210d5e7d8a31db523f6fc139e2c810","modified":1663758141427},{"_id":"public/tags/c/index.html","hash":"b997d0f64cc2cbe0473b0d45c1375a40e53bc4c4","modified":1663758141427},{"_id":"public/tags/intern/index.html","hash":"a18cda628d2249912efa666371510993af58eb9e","modified":1663758141427},{"_id":"public/tags/Database/index.html","hash":"cdee6497db51ee5b2d33439d8527bf0e4696f6ac","modified":1663758141427},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1611238894689},{"_id":"public/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1623469965045},{"_id":"public/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611238894689},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1611238894689},{"_id":"public/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611238894689},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1611238894689},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1611238894689},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1611238894689},{"_id":"public/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1611238894689},{"_id":"public/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1611238894689},{"_id":"public/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1611238894689},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1611238894689},{"_id":"public/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1611238894689},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1611238894689},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1611238894689},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1611238894689},{"_id":"public/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1611238894689},{"_id":"public/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1611238894689},{"_id":"public/css/index.css","hash":"817ba8be5bdd463183cbd107504640ecb21ca02d","modified":1611238894689},{"_id":"public/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1611238894689},{"_id":"public/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1611238894689},{"_id":"themes/Butterfly/layout/_layout.swig","hash":"e69985f2fad6d9d9292e54fa5a6adb19c8d84d45","modified":1611414457424},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.eslintrc","hash":"9274e9ce5a031fc936330eb0aa35653b03e5c1bc","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.gitignore","hash":"082286dac7149a87a9b5073a562bb0661a6a78df","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.travis.yml","hash":"0f3c18d294110f9a27aeff0ebe7023bb07ad52f8","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/README.md","hash":"055903e391b19d4eceaf220f57e3a5ac6764e389","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/package.json","hash":"0da94ab339e666fb97fa9d0344603704f1045a51","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.github/ISSUE_TEMPLATE.md","hash":"24938de1141e8f26b6a2241f232b3e25129ac2e2","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/demo/demo.js","hash":"91511c265365b2d0b3e5fec44eed699ae5e35476","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/demo/index.html","hash":"05f752644aeb1a1d82ab113f76328eff0599f324","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/music.js","hash":"9fcf661ba67c3f932b9eb13261ab1e93a259b93c","modified":1611414312660},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/CNAME","hash":"5b5021c61cf084dc192c225d2532dba17d765d5a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/README.md","hash":"57fa2f31c725b96a287152b05c9e69ee185eef6a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/config.js","hash":"03ea6f8a9ee71aacca6ca30360951526f97e39de","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/ecosystem.md","hash":"9d51d4e6e6290d15cbf8c3444559a7c808f7e8dd","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/index.html","hash":"97fdf9b2508a04722b1544808ef5cbae7a02ef67","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/support.md","hash":"41424289691882abf0f61e51d4455059034a12d1","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/dev.config.js","hash":"f4c5ca8858374d7d457d4d20994b1e3c7151c19b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/postcss.config.js","hash":"b319d7a602418969bc434d16ae1476f781b1e758","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/prod.config.js","hash":"4e5e59d35c811165766664e5c75e7514e9628048","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/README.md","hash":"9d9945caa066db6235549c7c04577a0236bb1592","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/ecosystem.md","hash":"f279d4d931ab54ee30757750c4ea8abe7789a32f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/support.md","hash":"24818a7cd01332b244a36b48fb3953afc2e7bdf3","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/css/index.scss","hash":"8bf2b70ad24911997890528cadaa08ea385b8b24","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/bar.js","hash":"74a16047fc0da8486a33de6cf3ecc881b2568988","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/controller.js","hash":"3c911f91bbefa7ecba08f1ccccc1cc6b40c500d0","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/events.js","hash":"f9bbe87494ec4a43daadc1ecd39c8a0541f4e434","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/index.js","hash":"b06b620244638433bf0e7015b932bca02e3db19c","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/list.js","hash":"126cf10a75251627862d1effb86f3992deddfe5b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/lrc.js","hash":"3a550a5d506ef4fb0ece608853f73542f37542ba","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/options.js","hash":"a69e3f87d68466ce97588e43c4745f0192b843b1","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/player.js","hash":"6df7fa9653982d95e0f82974ccfc69a25f6953ba","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/storage.js","hash":"820619bc8d78de4d430ffb866e740b51cdd780c6","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/template.js","hash":"5846a37ee44ef0eaca4376b98149e78bfaac4b67","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/timer.js","hash":"05ccc546427a055712ddbf8e0136ffb6b9f9f33c","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/utils.js","hash":"c1c4eba6d261c132beed0cdd073e0adc65ed9a9f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/player.art","hash":"eda981e8ed56d6d7bc81182e969f4766869b2662","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/yarn.lock","hash":"5fe4573f0f6aaad024a40503520848f63cba1257","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1522338206000},{"_id":"public/APlayer-1.10.1/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/CNAME","hash":"5b5021c61cf084dc192c225d2532dba17d765d5a","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/css/index.scss","hash":"8bf2b70ad24911997890528cadaa08ea385b8b24","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/player.art","hash":"eda981e8ed56d6d7bc81182e969f4766869b2662","modified":1611414505367},{"_id":"public/APlayer-1.10.1/package.json","hash":"f711b300f93d6fafef0d69e379e124ce91c38769","modified":1611414505367},{"_id":"public/APlayer-1.10.1/demo/demo.js","hash":"91511c265365b2d0b3e5fec44eed699ae5e35476","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/music.js","hash":"9fcf661ba67c3f932b9eb13261ab1e93a259b93c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/config.js","hash":"03ea6f8a9ee71aacca6ca30360951526f97e39de","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/dev.config.js","hash":"f4c5ca8858374d7d457d4d20994b1e3c7151c19b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/postcss.config.js","hash":"b319d7a602418969bc434d16ae1476f781b1e758","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/prod.config.js","hash":"4e5e59d35c811165766664e5c75e7514e9628048","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/bar.js","hash":"74a16047fc0da8486a33de6cf3ecc881b2568988","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/controller.js","hash":"3c911f91bbefa7ecba08f1ccccc1cc6b40c500d0","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/events.js","hash":"f9bbe87494ec4a43daadc1ecd39c8a0541f4e434","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/index.js","hash":"b06b620244638433bf0e7015b932bca02e3db19c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/list.js","hash":"126cf10a75251627862d1effb86f3992deddfe5b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/lrc.js","hash":"3a550a5d506ef4fb0ece608853f73542f37542ba","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/options.js","hash":"a69e3f87d68466ce97588e43c4745f0192b843b1","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/player.js","hash":"6df7fa9653982d95e0f82974ccfc69a25f6953ba","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/storage.js","hash":"820619bc8d78de4d430ffb866e740b51cdd780c6","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/template.js","hash":"5846a37ee44ef0eaca4376b98149e78bfaac4b67","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/timer.js","hash":"05ccc546427a055712ddbf8e0136ffb6b9f9f33c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/utils.js","hash":"c1c4eba6d261c132beed0cdd073e0adc65ed9a9f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/README.html","hash":"d4a83e323a294d8b05e89d5251c667f5808c4931","modified":1611414505367},{"_id":"public/APlayer-1.10.1/demo/index.html","hash":"efc650972f5415453c25d48fdf40afbe35256602","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/ecosystem.html","hash":"62798ead4a2a974c856f2779cff2e3f20e314e20","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/index.html","hash":"1cfe6294406deaea3b3b78a9a5ff9ec5f58ae96d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/support.html","hash":"61ea2536908b167d20deb1849820e3462d8d6176","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/ecosystem.html","hash":"69ea6483810741c04359a2573ad47764f7e2aad4","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/support.html","hash":"a2268752ed7678a3cfbc59e7555ad352c13db872","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/README.html","hash":"54cac2cd9a05a02d5bc392f4274534e91dc5a39c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/README.html","hash":"5ab4ebe380e311c888793479a3b87929b85dad4d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1611414505367},{"_id":"public/APlayer-1.10.1/yarn.lock","hash":"5fe4573f0f6aaad024a40503520848f63cba1257","modified":1611414505367},{"_id":"source/tags/index.md","hash":"f77453b0c0b79277a86fc8b18125e0d7123a4f54","modified":1617007056753},{"_id":"public/tags/index.html","hash":"593efc8c82679608eb5a5c32cc67cb2e86e2ae01","modified":1663758141427},{"_id":"source/_posts/数据库基础-2.md","hash":"56c0564c7acbe9693d3bd7a6337c7d0092287f94","modified":1617007056752},{"_id":"public/2021/01/24/数据库基础-2/index.html","hash":"0497749883fd423f55972efd741ab76a92848649","modified":1663758141427},{"_id":"source/_posts/数据库基础-3.md","hash":"b7b42733ade606042402ad6f342a271fe1d2020f","modified":1617007056752},{"_id":"public/2021/02/02/数据库基础-3/index.html","hash":"27cb4b84af0bcbe59bb7fc631409a33623cb7b09","modified":1663758141427},{"_id":"public/archives/2021/02/index.html","hash":"3a0b97799ad3b0d6ded91857f3bd60c7f9b7da5c","modified":1663758141427},{"_id":"source/_posts/c-11-14-1.md","hash":"6e22223e9b6b081079592b40c40fa7e95eff38c3","modified":1648210937115},{"_id":"source/_posts/Makefile-Record.md","hash":"f870b054738bf82ce1b70d1cb6e6dabcf09df3f7","modified":1648210937112},{"_id":"source/_posts/Spring-1.md","hash":"5e9822a57c533ccf739ac840776d3faa256d7103","modified":1648210937113},{"_id":"public/2021/06/08/c-11-14-1/index.html","hash":"de59a4e746fb4b698dd4e8805f2cc45e03f6ac5f","modified":1663758141427},{"_id":"public/2021/05/25/Spring-1/index.html","hash":"2af009a707a34d1d0a8fe405b8c37849d2f246cf","modified":1663758141427},{"_id":"public/2021/03/29/Makefile-Record/index.html","hash":"8a780000a32141c52e029dd23112e0dccb5efd32","modified":1663758141427},{"_id":"public/archives/page/2/index.html","hash":"1428f2406991baf8853b0d4606eb02d313bdc488","modified":1663758141427},{"_id":"public/archives/2021/03/index.html","hash":"278f49ce08f1bf9a5afb94aec000680fa0f608df","modified":1663758141427},{"_id":"public/archives/2021/05/index.html","hash":"90e57a39ebe09ec9fd8cd7ca18c0ba2348293db9","modified":1663758141427},{"_id":"public/archives/2021/06/index.html","hash":"75794f2e776dc5543c70846b507f49a25c3bf90a","modified":1663758141427},{"_id":"public/page/2/index.html","hash":"5739354abed02e37071491cbe30604bd90c2df84","modified":1663758141427},{"_id":"public/tags/makefile/index.html","hash":"e61381a28b8603f669337f6a7c5862378dfa7f97","modified":1663758141427},{"_id":"public/tags/Spring/index.html","hash":"74c575b542c44e74f4a2fb63687d9df42c53cb8f","modified":1663758141427},{"_id":"source/_posts/c-11-14-2.md","hash":"c40fc531c850faf102a15849474bab921e60d7c1","modified":1648210937116},{"_id":"source/_posts/设计模式.md","hash":"6ab787ad56934bc7e7b58cdd1f736a3177e79f73","modified":1648210937119},{"_id":"public/2021/06/12/设计模式/index.html","hash":"9783cb713419d2fd598663bdc290e4e66af0953c","modified":1663758141427},{"_id":"public/2021/06/12/c-11-14-2/index.html","hash":"bf231cc4e254a07d97115bd537451d057ea5ba4c","modified":1663758141427},{"_id":"public/archives/2021/page/2/index.html","hash":"6aff39fedf2449fb220b613e6829546f6c898042","modified":1663758141427},{"_id":"public/tags/设计模式/index.html","hash":"e8f47bf3d285f1bc599f778dd6ddb2e03960e6ab","modified":1663758141427},{"_id":"source/_posts/自动内存管理.md","hash":"c31c09d0ec4fb85275a28116e6e7c2cbad8affd1","modified":1663745446940},{"_id":"public/2022/03/27/自动内存管理/index.html","hash":"67453045f467d4851281dfa9f91d97e3371679ed","modified":1663758141427},{"_id":"public/archives/2022/index.html","hash":"9e1f5f1126354a2ddd709beb92ba9b58fb4a7094","modified":1663758141427},{"_id":"public/archives/2022/03/index.html","hash":"c94129137fb39b006677740dd64a4dae51dfdcef","modified":1663758141427},{"_id":"public/tags/Java/index.html","hash":"6099890a33a17b7627afe230dea5d3082cfa1bc1","modified":1663758141427},{"_id":"source/_posts/虚拟机执行.md","hash":"65f08a778865c224703a73f45db4b534ab6ee40e","modified":1663745446940},{"_id":"public/2022/03/28/虚拟机执行/index.html","hash":"e5fa47ccd2e752dfc74da2f7b8da39289261b8c5","modified":1663758141427},{"_id":"public/tags/笔记/page/2/index.html","hash":"410bdd898dbd86506b001fac855b3459d858529b","modified":1663758141427},{"_id":"source/_posts/方法调用.md","hash":"4060f71cf8f7d54fcd33905792b4c0b46d504b5e","modified":1663745446940},{"_id":"public/2022/03/29/方法调用/index.html","hash":"673adfe5fdb3898d872d2a2b4e34bc42a30b45e2","modified":1663758141427},{"_id":"source/_posts/内存模型与线程.md","hash":"cb4735fef7a36f76aafc50f0d41e3cfde6b940e4","modified":1663745446940},{"_id":"public/2022/03/29/内存模型与线程/index.html","hash":"aed047b3279107fa8369d024958dde2d9f153568","modified":1663758141427},{"_id":"source/_posts/并发编程.md","hash":"45776f98965c8ceef7e5626208c57cd4efe864ac","modified":1663745446940},{"_id":"public/2022/03/30/并发编程/index.html","hash":"8a583b68a82a1060365b474b1083af4b8b4bf979","modified":1663758141427},{"_id":"source/_posts/线程池与并发工具.md","hash":"8da39041e327903912109c2a28f0539adc530bb8","modified":1663745446940},{"_id":"public/2022/03/31/线程池与并发工具/index.html","hash":"e2a1da2a56c0f89fc32c1b662df57de7708297fa","modified":1663758141427},{"_id":"public/archives/page/3/index.html","hash":"f19be8376881de45cf730577d13f573bd7c06222","modified":1663758141427},{"_id":"public/page/3/index.html","hash":"b1d170621bce1ce869748f754183b324070f629c","modified":1663758141427},{"_id":"source/_posts/MyBatis-1.md","hash":"f317262169a32c7d1f1b3981527af5a66cae7478","modified":1663758033742},{"_id":"public/2022/09/21/MyBatis-1/index.html","hash":"128d82be513558df2f4d2ebf81b4879bccfa2727","modified":1663758042194},{"_id":"public/archives/2022/09/index.html","hash":"86b97f1bcf09f405090f65e30f995c1e6b25b4c5","modified":1663758141427},{"_id":"public/tags/MyBatis/index.html","hash":"e9c87dc209af6370edf89a5c52e45de1875028b0","modified":1663758141427},{"_id":"source/_posts/MyBatis.md","hash":"d6bb342c3f0b637a6d6297fbba262fba5b624e7c","modified":1663758122454},{"_id":"public/2022/09/21/MyBatis/index.html","hash":"a4d51018e128ca484f9ba3dcb2d20ef7d9d0f589","modified":1663758141427}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2021-01-23T15:27:35.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-01-23 23:27:35\ntype: tags\nlayout: tags\n---\n","updated":"2021-03-29T08:37:36.753Z","path":"tags/index.html","_id":"ckk9vex080000g26wf4mf8ihy","comments":1,"content":"","site":{"data":{}},"cover":"https://i.imgur.com/RRUe0Mo.png","excerpt":"","more":""}],"Post":[{"title":"GAMES101_学习笔记","date":"2020-06-19T13:45:43.000Z","top_img":"/img/cover/games101.webp","cover":"/img/cover/games101.webp","mathjax":true,"_content":"\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","source":"_posts/GAMES101-学习笔记.md","raw":"---\ntitle: GAMES101_学习笔记\ndate: 2020-06-19 21:45:43\ntop_img: /img/cover/games101.webp\ncover: /img/cover/games101.webp\ntags: 笔记\nmathjax: true\n---\n\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","slug":"GAMES101-学习笔记","published":1,"updated":"2022-03-25T12:22:17.112Z","_id":"ckk6y1e2x00003a6w2zzn7o85","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M<em>{persp-&gt;ortho}*M</em>{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u<em>0 = lerp(s, u</em>{00}, u_{10})$</li>\n<li>$u<em>1 = lerp(s, u</em>{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p<em>0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p</em>{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p<em>0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum</em>{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\ b_1 \\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\ S_1 \\cdot S \\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\  E_2 = p_2 - p_0 \\ S = O-p_0 \\ S_1=D \\times E_2 \\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\ 0 \\le b_1 \\le 1 \\ 0 \\le b_2 \\le 1 \\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L<em>r(p, \\omega_r) = \\int</em>{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L<em>o(p,\\omega_o) = L_e(p, \\omega_o) + \\int</em>{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L<em>i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum</em>{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F<em>{Schlick} = C</em>{spec} + (1-C<em>{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C</em>{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x<em>{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’</em>{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y<em>{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t</em>{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\ k_2 \\ k_3 \\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M<em>{persp-&gt;ortho}*M</em>{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u<em>0 = lerp(s, u</em>{00}, u_{10})$</li>\n<li>$u<em>1 = lerp(s, u</em>{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p<em>0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p</em>{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p<em>0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum</em>{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\ b_1 \\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\ S_1 \\cdot S \\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\  E_2 = p_2 - p_0 \\ S = O-p_0 \\ S_1=D \\times E_2 \\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\ 0 \\le b_1 \\le 1 \\ 0 \\le b_2 \\le 1 \\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L<em>r(p, \\omega_r) = \\int</em>{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L<em>o(p,\\omega_o) = L_e(p, \\omega_o) + \\int</em>{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L<em>i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum</em>{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F<em>{Schlick} = C</em>{spec} + (1-C<em>{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C</em>{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x<em>{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’</em>{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y<em>{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t</em>{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\ k_2 \\ k_3 \\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo + Github","date":"2020-06-12T14:11:13.000Z","top_img":"/img/cover/hexo_github.png","cover":"/img/cover/hexo_github.png","description":"配置个人专属博客网站，采坑小结","_content":"这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","source":"_posts/Hexo-Github.md","raw":"---\ntitle: Hexo + Github\ndate: 2020-06-12 22:11:13\ntop_img: /img/cover/hexo_github.png\ncover: /img/cover/hexo_github.png\ndescription: 配置个人专属博客网站，采坑小结\ntags: \n  - config\n  - 教程\n---\n这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","slug":"Hexo-Github","published":1,"updated":"2022-03-25T12:22:17.112Z","_id":"ckk6y1e3500013a6wag7x5ncv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>"},{"title":"c++ 基础(1)","date":"2021-01-20T06:51:34.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### struct和class的区别\n在C++中，可以用`struct`和`class`定义类，都可以继承。区别在于：\n`struct`的默认继承权限和默认访问权限是**public**，而`class`的默认继承权限和默认访问权限是**private**。\n\n另外，`class`还可以定义模板类形参，比如\n```c++\ntemplate <class T, int i>\n```\n\n### static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","source":"_posts/c++基础-1.md","raw":"---\ntitle: c++ 基础(1)\ndate: 2021-01-20 14:51:34\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### struct和class的区别\n在C++中，可以用`struct`和`class`定义类，都可以继承。区别在于：\n`struct`的默认继承权限和默认访问权限是**public**，而`class`的默认继承权限和默认访问权限是**private**。\n\n另外，`class`还可以定义模板类形参，比如\n```c++\ntemplate <class T, int i>\n```\n\n### static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","slug":"c++基础-1","published":1,"updated":"2021-03-29T08:37:36.749Z","_id":"ckk6y1e3n00033a6w6rm5b4e1","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"struct和class的区别\"><a href=\"#struct和class的区别\" class=\"headerlink\" title=\"struct和class的区别\"></a>struct和class的区别</h3><p>在C++中，可以用<code>struct</code>和<code>class</code>定义类，都可以继承。区别在于：<br><code>struct</code>的默认继承权限和默认访问权限是<strong>public</strong>，而<code>class</code>的默认继承权限和默认访问权限是<strong>private</strong>。</p>\n<p>另外，<code>class</code>还可以定义模板类形参，比如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">int</span> <span class=\"title\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"static关键字的作用\"><a href=\"#static关键字的作用\" class=\"headerlink\" title=\"static关键字的作用\"></a>static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"struct和class的区别\"><a href=\"#struct和class的区别\" class=\"headerlink\" title=\"struct和class的区别\"></a>struct和class的区别</h3><p>在C++中，可以用<code>struct</code>和<code>class</code>定义类，都可以继承。区别在于：<br><code>struct</code>的默认继承权限和默认访问权限是<strong>public</strong>，而<code>class</code>的默认继承权限和默认访问权限是<strong>private</strong>。</p>\n<p>另外，<code>class</code>还可以定义模板类形参，比如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">int</span> <span class=\"title\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"static关键字的作用\"><a href=\"#static关键字的作用\" class=\"headerlink\" title=\"static关键字的作用\"></a>static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n"},{"title":"c++ 基础(2)","date":"2021-01-20T08:46:15.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","source":"_posts/c++基础-2.md","raw":"---\ntitle: c++ 基础(2)\ndate: 2021-01-20 16:46:15\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","slug":"c++基础-2","published":1,"updated":"2021-03-29T08:37:36.749Z","_id":"ckk6y1e3o00043a6w03n32plb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n"},{"title":"c++ 基础(3)","date":"2021-01-20T14:00:05.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（3）\n### 右值引用\n#### 左值和右值\n根据《C++ Primer》的说法，左值和右值可以这样区分：\n\n> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如\n```c++\nint foo(42);\nint bar;\n\n// 将 foo 的值赋给 bar，保存在 bar 对应的内存中\n// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值\n// 但是 foo 作为对象，既可以充当左值又可以充当右值\nbar = foo;\n```\n\n因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即\n\n+ 在大多数情况下，需要右值的地方可以用左值来替代，但\n+ 需要左值的地方，一定不能用右值来替代。\n\n又有一个重要的特点，即\n\n+ 左值存放在对象中，有持久的状态；而\n+ 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。\n\n#### 常量左值引用\n常量左值引用，即const的左值引用。\n\n右值只能绑定到右值引用上，左值引用不能绑定右值，例如：\n```c++\nint i = 42;\nint &&rr = i;     // ERR: i 是左值\nint &r = i * 2;   // ERR: i * 2 是右值\n```\n\n但是常量左值引用可以绑定右值：\n```c++\nint i = 42;\nconst int &r = i * 42;  // OK: 可以将 const 引用绑定到右值上\n```\n\n可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 `int &r = 42` 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：\n```c++\n// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么\ndouble dval = 3.14;\nconst int &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 先将双精度浮点数变成一个整型常量\nconst int &ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上\n```\n\n这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。\n\n我们再来看看如果 ri 不是常量引用会发生什么：\n```c++\ndouble dval = 3.14; \nint &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 还是先将双精度浮点数变成一个整型常量\nint &ri = tmp;          // 再让这个普通引用和 tmp 绑定\n```\n\n可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：\n\n+ tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。\n+ 就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。\n\n于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。\n\n通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。\n\n同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。\n\n#### 左值引用和右值引用\n在 C++ 中，有两种对对象的引用：左值引用和右值引用。\n\n左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。\n\n```c++\n// lvalue-reference\nint foo(42);\nint& bar = foo;  // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起\nint& baz = 42;   // Err: 42 是右值，不能将它绑定在左值引用上\nconst int& qux = 42;  // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上\n```\n右值引用也是引用，但是它只能且必须绑定在右值上。\n\n```c++\n// rvalue-reference\nint foo(42);\nint& bar = foo;        // OK: 将 foo 绑定在左值引用上\nint&& baz = foo;       // Err: foo 可以是左值，所以不能将它绑定在右值引用上\nint&& qux = 42;        // OK: 将右值 42 绑定在右值引用上\nint&& quux = foo * 1;  // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上\nint& garply = foo++;   // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上\nint&& waldo = foo--;   // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上\n```\n\n由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：\n\n+ 右值引用的对象，是临时的，即将被销毁；并且\n+ 右值引用的对象，不会在其它地方使用。\n\n> 敲黑板：这是重点！\n\n这两个特性意味着：**接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏**。\n\n需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：\n```c++\nint &&rr1 = 42;   // OK: 字面量是右值\nint &&rr2 = rr1;  // ERR: rr1 是变量，虽然它是右值引用，但仍然是左值\n```\n\n#### 右值的作用\n##### 标准库 move 函数\n虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：\n```c++\nint&& rr1 = 42;                 // 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值\nint&& rr2 = std::move(rr1);     // 使用 std::move() 而不是 move()\n```\n\n需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。\n\n##### 移动构造函数\n有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。\n\n和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。\n\n详见\n\n##### 移动赋值运算符\n移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：\n```c++\nMyString& Mystring::operator=(MyString&& rhs) noexcept {\n  if (this != &rhs) {\n    if (string) free(string);  // 先将原有资源释放\n    string = rhs.string;\n    rhs.string = nullptr;\n  }\n  return *this;\n}\n```\n只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。\n\n#### 转发\n转发与 std::forward 的内容详见[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。\n\n## 参考链接\n[struct和class的区别](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[C++ 引用、移动、转发 (一)](https://guodong.plus/2020/0307-190855/)\n[C++ 引用、移动、转发 (二)](https://guodong.plus/2020/0311-225314/)\n[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)\n[谈谈c++中的右值引用](https://liam.page/2016/12/11/rvalue-reference-in-Cpp/)","source":"_posts/c++基础-3.md","raw":"---\ntitle: c++ 基础(3)\ndate: 2021-01-20 22:00:05\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（3）\n### 右值引用\n#### 左值和右值\n根据《C++ Primer》的说法，左值和右值可以这样区分：\n\n> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如\n```c++\nint foo(42);\nint bar;\n\n// 将 foo 的值赋给 bar，保存在 bar 对应的内存中\n// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值\n// 但是 foo 作为对象，既可以充当左值又可以充当右值\nbar = foo;\n```\n\n因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即\n\n+ 在大多数情况下，需要右值的地方可以用左值来替代，但\n+ 需要左值的地方，一定不能用右值来替代。\n\n又有一个重要的特点，即\n\n+ 左值存放在对象中，有持久的状态；而\n+ 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。\n\n#### 常量左值引用\n常量左值引用，即const的左值引用。\n\n右值只能绑定到右值引用上，左值引用不能绑定右值，例如：\n```c++\nint i = 42;\nint &&rr = i;     // ERR: i 是左值\nint &r = i * 2;   // ERR: i * 2 是右值\n```\n\n但是常量左值引用可以绑定右值：\n```c++\nint i = 42;\nconst int &r = i * 42;  // OK: 可以将 const 引用绑定到右值上\n```\n\n可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 `int &r = 42` 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：\n```c++\n// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么\ndouble dval = 3.14;\nconst int &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 先将双精度浮点数变成一个整型常量\nconst int &ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上\n```\n\n这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。\n\n我们再来看看如果 ri 不是常量引用会发生什么：\n```c++\ndouble dval = 3.14; \nint &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 还是先将双精度浮点数变成一个整型常量\nint &ri = tmp;          // 再让这个普通引用和 tmp 绑定\n```\n\n可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：\n\n+ tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。\n+ 就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。\n\n于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。\n\n通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。\n\n同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。\n\n#### 左值引用和右值引用\n在 C++ 中，有两种对对象的引用：左值引用和右值引用。\n\n左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。\n\n```c++\n// lvalue-reference\nint foo(42);\nint& bar = foo;  // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起\nint& baz = 42;   // Err: 42 是右值，不能将它绑定在左值引用上\nconst int& qux = 42;  // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上\n```\n右值引用也是引用，但是它只能且必须绑定在右值上。\n\n```c++\n// rvalue-reference\nint foo(42);\nint& bar = foo;        // OK: 将 foo 绑定在左值引用上\nint&& baz = foo;       // Err: foo 可以是左值，所以不能将它绑定在右值引用上\nint&& qux = 42;        // OK: 将右值 42 绑定在右值引用上\nint&& quux = foo * 1;  // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上\nint& garply = foo++;   // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上\nint&& waldo = foo--;   // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上\n```\n\n由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：\n\n+ 右值引用的对象，是临时的，即将被销毁；并且\n+ 右值引用的对象，不会在其它地方使用。\n\n> 敲黑板：这是重点！\n\n这两个特性意味着：**接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏**。\n\n需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：\n```c++\nint &&rr1 = 42;   // OK: 字面量是右值\nint &&rr2 = rr1;  // ERR: rr1 是变量，虽然它是右值引用，但仍然是左值\n```\n\n#### 右值的作用\n##### 标准库 move 函数\n虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：\n```c++\nint&& rr1 = 42;                 // 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值\nint&& rr2 = std::move(rr1);     // 使用 std::move() 而不是 move()\n```\n\n需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。\n\n##### 移动构造函数\n有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。\n\n和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。\n\n详见\n\n##### 移动赋值运算符\n移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：\n```c++\nMyString& Mystring::operator=(MyString&& rhs) noexcept {\n  if (this != &rhs) {\n    if (string) free(string);  // 先将原有资源释放\n    string = rhs.string;\n    rhs.string = nullptr;\n  }\n  return *this;\n}\n```\n只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。\n\n#### 转发\n转发与 std::forward 的内容详见[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。\n\n## 参考链接\n[struct和class的区别](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[C++ 引用、移动、转发 (一)](https://guodong.plus/2020/0307-190855/)\n[C++ 引用、移动、转发 (二)](https://guodong.plus/2020/0311-225314/)\n[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)\n[谈谈c++中的右值引用](https://liam.page/2016/12/11/rvalue-reference-in-Cpp/)","slug":"c++基础-3","published":1,"updated":"2021-03-29T08:37:36.750Z","_id":"ckk6y1e3p00053a6w57ht8r87","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（3）\"><a href=\"#C-基础知识（3）\" class=\"headerlink\" title=\"C++ 基础知识（3）\"></a>C++ 基础知识（3）</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><h4 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h4><p>根据《C++ Primer》的说法，左值和右值可以这样区分：</p>\n<blockquote>\n<p>一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 的值赋给 bar，保存在 bar 对应的内存中</span></span><br><span class=\"line\"><span class=\"comment\">// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值</span></span><br><span class=\"line\"><span class=\"comment\">// 但是 foo 作为对象，既可以充当左值又可以充当右值</span></span><br><span class=\"line\">bar = foo;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即</p>\n<ul>\n<li>在大多数情况下，需要右值的地方可以用左值来替代，但</li>\n<li>需要左值的地方，一定不能用右值来替代。</li>\n</ul>\n<p>又有一个重要的特点，即</p>\n<ul>\n<li>左值存放在对象中，有持久的状态；而</li>\n<li>右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。</li>\n</ul>\n<h4 id=\"常量左值引用\"><a href=\"#常量左值引用\" class=\"headerlink\" title=\"常量左值引用\"></a>常量左值引用</h4><p>常量左值引用，即const的左值引用。</p>\n<p>右值只能绑定到右值引用上，左值引用不能绑定右值，例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i;     <span class=\"comment\">// ERR: i 是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">2</span>;   <span class=\"comment\">// ERR: i * 2 是右值</span></span><br></pre></td></tr></table></figure></p>\n<p>但是常量左值引用可以绑定右值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 可以将 const 引用绑定到右值上</span></span><br></pre></td></tr></table></figure></p>\n<p>可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 <code>int &amp;r = 42</code> 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = tmp;    <span class=\"comment\">// 让常量引用 ri 绑定到这个临时变量上</span></span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。</p>\n<p>我们再来看看如果 ri 不是常量引用会发生什么：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>; </span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 还是先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = tmp;          <span class=\"comment\">// 再让这个普通引用和 tmp 绑定</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：</p>\n<ul>\n<li>tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。</li>\n<li>就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。</li>\n</ul>\n<p>于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。</p>\n<p>通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。</p>\n<p>同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。</p>\n<h4 id=\"左值引用和右值引用\"><a href=\"#左值引用和右值引用\" class=\"headerlink\" title=\"左值引用和右值引用\"></a>左值引用和右值引用</h4><p>在 C++ 中，有两种对对象的引用：左值引用和右值引用。</p>\n<p>左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;  <span class=\"comment\">// OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; baz = <span class=\"number\">42</span>;   <span class=\"comment\">// Err: 42 是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; qux = <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上</span></span><br></pre></td></tr></table></figure>\n<p>右值引用也是引用，但是它只能且必须绑定在右值上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;        <span class=\"comment\">// OK: 将 foo 绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; baz = foo;       <span class=\"comment\">// Err: foo 可以是左值，所以不能将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; qux = <span class=\"number\">42</span>;        <span class=\"comment\">// OK: 将右值 42 绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; quux = foo * <span class=\"number\">1</span>;  <span class=\"comment\">// OK: foo * 1 的结果是一个右值，将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; garply = foo++;   <span class=\"comment\">// Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; waldo = foo--;   <span class=\"comment\">// OK: 后置自减运算符返回的是右值，将它绑定在右值引用上</span></span><br></pre></td></tr></table></figure>\n<p>由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：</p>\n<ul>\n<li>右值引用的对象，是临时的，即将被销毁；并且</li>\n<li>右值引用的对象，不会在其它地方使用。</li>\n</ul>\n<blockquote>\n<p>敲黑板：这是重点！</p>\n</blockquote>\n<p>这两个特性意味着：<strong>接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏</strong>。</p>\n<p>需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">// OK: 字面量是右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;  <span class=\"comment\">// ERR: rr1 是变量，虽然它是右值引用，但仍然是左值</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"右值的作用\"><a href=\"#右值的作用\" class=\"headerlink\" title=\"右值的作用\"></a>右值的作用</h4><h5 id=\"标准库-move-函数\"><a href=\"#标准库-move-函数\" class=\"headerlink\" title=\"标准库 move 函数\"></a>标准库 move 函数</h5><p>虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr1 = <span class=\"number\">42</span>;                 <span class=\"comment\">// 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr2 = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(rr1);     <span class=\"comment\">// 使用 std::move() 而不是 move()</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。</p>\n<h5 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h5><p>有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。</p>\n<p>和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。</p>\n<p>详见</p>\n<h5 id=\"移动赋值运算符\"><a href=\"#移动赋值运算符\" class=\"headerlink\" title=\"移动赋值运算符\"></a>移动赋值运算符</h5><p>移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyString&amp; Mystring::<span class=\"keyword\">operator</span>=(MyString&amp;&amp; rhs) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>) <span class=\"built_in\">free</span>(<span class=\"built_in\">string</span>);  <span class=\"comment\">// 先将原有资源释放</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> = rhs.<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    rhs.<span class=\"built_in\">string</span> = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。</p>\n<h4 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h4><p>转发与 std::forward 的内容详见<a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a>，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">struct和class的区别</a><br><a href=\"https://guodong.plus/2020/0307-190855/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (一)</a><br><a href=\"https://guodong.plus/2020/0311-225314/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (二)</a><br><a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a><br><a href=\"https://liam.page/2016/12/11/rvalue-reference-in-Cpp/\" target=\"_blank\" rel=\"noopener\">谈谈c++中的右值引用</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（3）\"><a href=\"#C-基础知识（3）\" class=\"headerlink\" title=\"C++ 基础知识（3）\"></a>C++ 基础知识（3）</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><h4 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h4><p>根据《C++ Primer》的说法，左值和右值可以这样区分：</p>\n<blockquote>\n<p>一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 的值赋给 bar，保存在 bar 对应的内存中</span></span><br><span class=\"line\"><span class=\"comment\">// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值</span></span><br><span class=\"line\"><span class=\"comment\">// 但是 foo 作为对象，既可以充当左值又可以充当右值</span></span><br><span class=\"line\">bar = foo;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即</p>\n<ul>\n<li>在大多数情况下，需要右值的地方可以用左值来替代，但</li>\n<li>需要左值的地方，一定不能用右值来替代。</li>\n</ul>\n<p>又有一个重要的特点，即</p>\n<ul>\n<li>左值存放在对象中，有持久的状态；而</li>\n<li>右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。</li>\n</ul>\n<h4 id=\"常量左值引用\"><a href=\"#常量左值引用\" class=\"headerlink\" title=\"常量左值引用\"></a>常量左值引用</h4><p>常量左值引用，即const的左值引用。</p>\n<p>右值只能绑定到右值引用上，左值引用不能绑定右值，例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i;     <span class=\"comment\">// ERR: i 是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">2</span>;   <span class=\"comment\">// ERR: i * 2 是右值</span></span><br></pre></td></tr></table></figure></p>\n<p>但是常量左值引用可以绑定右值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 可以将 const 引用绑定到右值上</span></span><br></pre></td></tr></table></figure></p>\n<p>可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 <code>int &amp;r = 42</code> 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = tmp;    <span class=\"comment\">// 让常量引用 ri 绑定到这个临时变量上</span></span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。</p>\n<p>我们再来看看如果 ri 不是常量引用会发生什么：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>; </span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 还是先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = tmp;          <span class=\"comment\">// 再让这个普通引用和 tmp 绑定</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：</p>\n<ul>\n<li>tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。</li>\n<li>就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。</li>\n</ul>\n<p>于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。</p>\n<p>通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。</p>\n<p>同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。</p>\n<h4 id=\"左值引用和右值引用\"><a href=\"#左值引用和右值引用\" class=\"headerlink\" title=\"左值引用和右值引用\"></a>左值引用和右值引用</h4><p>在 C++ 中，有两种对对象的引用：左值引用和右值引用。</p>\n<p>左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;  <span class=\"comment\">// OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; baz = <span class=\"number\">42</span>;   <span class=\"comment\">// Err: 42 是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; qux = <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上</span></span><br></pre></td></tr></table></figure>\n<p>右值引用也是引用，但是它只能且必须绑定在右值上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;        <span class=\"comment\">// OK: 将 foo 绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; baz = foo;       <span class=\"comment\">// Err: foo 可以是左值，所以不能将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; qux = <span class=\"number\">42</span>;        <span class=\"comment\">// OK: 将右值 42 绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; quux = foo * <span class=\"number\">1</span>;  <span class=\"comment\">// OK: foo * 1 的结果是一个右值，将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; garply = foo++;   <span class=\"comment\">// Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; waldo = foo--;   <span class=\"comment\">// OK: 后置自减运算符返回的是右值，将它绑定在右值引用上</span></span><br></pre></td></tr></table></figure>\n<p>由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：</p>\n<ul>\n<li>右值引用的对象，是临时的，即将被销毁；并且</li>\n<li>右值引用的对象，不会在其它地方使用。</li>\n</ul>\n<blockquote>\n<p>敲黑板：这是重点！</p>\n</blockquote>\n<p>这两个特性意味着：<strong>接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏</strong>。</p>\n<p>需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">// OK: 字面量是右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;  <span class=\"comment\">// ERR: rr1 是变量，虽然它是右值引用，但仍然是左值</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"右值的作用\"><a href=\"#右值的作用\" class=\"headerlink\" title=\"右值的作用\"></a>右值的作用</h4><h5 id=\"标准库-move-函数\"><a href=\"#标准库-move-函数\" class=\"headerlink\" title=\"标准库 move 函数\"></a>标准库 move 函数</h5><p>虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr1 = <span class=\"number\">42</span>;                 <span class=\"comment\">// 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr2 = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(rr1);     <span class=\"comment\">// 使用 std::move() 而不是 move()</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。</p>\n<h5 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h5><p>有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。</p>\n<p>和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。</p>\n<p>详见</p>\n<h5 id=\"移动赋值运算符\"><a href=\"#移动赋值运算符\" class=\"headerlink\" title=\"移动赋值运算符\"></a>移动赋值运算符</h5><p>移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyString&amp; Mystring::<span class=\"keyword\">operator</span>=(MyString&amp;&amp; rhs) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>) <span class=\"built_in\">free</span>(<span class=\"built_in\">string</span>);  <span class=\"comment\">// 先将原有资源释放</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> = rhs.<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    rhs.<span class=\"built_in\">string</span> = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。</p>\n<h4 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h4><p>转发与 std::forward 的内容详见<a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a>，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">struct和class的区别</a><br><a href=\"https://guodong.plus/2020/0307-190855/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (一)</a><br><a href=\"https://guodong.plus/2020/0311-225314/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (二)</a><br><a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a><br><a href=\"https://liam.page/2016/12/11/rvalue-reference-in-Cpp/\" target=\"_blank\" rel=\"noopener\">谈谈c++中的右值引用</a></p>\n"},{"title":"Hello World","date":"2020-06-12T08:46:15.000Z","top_img":"/img/cover/helloworld.png","cover":"/img/cover/helloworld.png","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2020-06-12 16:46:15\ntop_img: /img/cover/helloworld.png\ncover: /img/cover/helloworld.png\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2021-03-29T08:37:36.751Z","_id":"ckk6y1e3r00083a6wcazw9ebi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"unity-shader学习记录","date":"2020-06-16T15:05:44.000Z","top_img":"/img/cover/shader.jpg","cover":"/img/cover/shader.jpg","_content":"\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","source":"_posts/unity-shader学习记录.md","raw":"---\ntitle: unity-shader学习记录\ndate: 2020-06-16 23:05:44\ntop_img: /img/cover/shader.jpg\ncover: /img/cover/shader.jpg\ntags: 笔记\n---\n\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","slug":"unity-shader学习记录","published":1,"updated":"2022-03-25T12:22:17.117Z","_id":"ckk6y1e3s00093a6w36me16r3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n"},{"title":"数据库基础-1","date":"2021-01-21T11:50:55.000Z","top_img":"/img/cover/database.jpg","cover":"/img/cover/database.jpg","_content":"\n## 数据库基础知识（1）\n### 事务\n数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。\n\n#### 原子性(Atomicity)\n原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。\n\n#### 一致性(Consistency)\n一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。\n\n当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。\n\n#### 隔离性(Isolation)\n隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。\n\n隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n1. 脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。\n2. 不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。\n3. 幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。\n\nSQL 标准定义了四个隔离级别：\n1. **读取未提交**(Read Uncommited)\n    + 最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致**脏读、幻读或不可重复读**。\n2. **读取已提交**(Read Commited)\n    + 事务智能读取到其他事务已提交的修改。**可以阻止脏读，但不能阻止幻读和不可重复读**。\n3. **可重复读**(Repeatable Read)\n    + 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但不能阻止幻读**。\n4. **串行化**(Serializable)\n    + 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别**可以防止脏读、不可重复读以及幻读**。\n\n#### 持久性(Durability)\n持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 范式\n1. 第一范式(1NF)：无重复的列。\n    在关系模型中，对于添加的一个规范要求，**所有的域都应该是原子性**的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。\n2. 第二范式(2NF)：属性完全依赖于主键\n    第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。\n3. 第三范式(3NF)：任何非主属性不依赖于其它非主属性\n    第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。\n4. BCNF：主属性不能对主键子集依赖\n    巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。\n\n### 索引\n#### 索引的工作原理\n**数据库索引**，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。\n\n在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。\n\n+ 索引的优点：\n    1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n    2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\n    3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。\n    4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。\n    5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，**提高系统的性能**。\n\n+ 索引的缺点：\n    1. **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加。\n    2. 索引需要**占物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。\n    3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。\n\n+ 推荐建立索引的列：\n    1. 在**经常需要搜索**的列上，可以加快搜索的速度；\n    2. 在**作为主键**的列上，强制该列的唯一性和组织表中数据的排列结构；\n    3. 在**经常用在连接**的列上，这些列主要是一些外键，可以加快连接的速度；\n    4. 在**经常需要根据范围进行搜索**的列上创建索引，因为索引已经排序，其指定的范围是连续的；\n    5. 在**经常需要排序**的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；\n    6. 在**经常在 where 子句中使用**的列上面创建索引，加快条件的判断速度。\n\n+ 不应该创建索引的的列：\n    1. 对于那些**在查询中很少使用或者参考的列**不应该创建索引\n        这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。\n    2. 对于那些**只有很少数据值的列**也不应该增加索引\n        这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。\n    3. 对于那些**定义为 text, image 和 bit 数据类型的列**不应该增加索引\n        这是因为，这些列的数据量要么相当大，要么取值很少。\n    4. 当**修改性能远远大于检索性能时**，不应该创建索引\n        这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。\n\n#### 索引结构——B+树与B-树\nMySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。\n\n先简单介绍一下B-树和B+树的结构以及区别。\n\nB-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。\n\n而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。\n\n再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。\n\n而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。\n\n由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。\n\n#### 索引的种类\n根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。\n\n1. 唯一索引\n    唯一索引是不允许其中任何两行具有相同索引值的索引。\n    当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓\n\n2. 主键索引\n    数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。\n    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。\n\n3. 聚集索引\n    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。\n\n##### 聚簇索引与非聚簇索引\n索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n详细可见[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab)\n[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)\n[数据库范式解析](https://blog.csdn.net/GarfieldEr007/article/details/54319026)\n[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n[为什么Mongodb索引用B树，而Mysql用B+树](https://my.oschina.net/u/4365362/blog/4523180)","source":"_posts/数据库基础-1.md","raw":"---\ntitle: 数据库基础-1\ndate: 2021-01-21 19:50:55\ntop_img: /img/cover/database.jpg\ncover: /img/cover/database.jpg\ntags: [Database, intern, 笔记]\n---\n\n## 数据库基础知识（1）\n### 事务\n数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。\n\n#### 原子性(Atomicity)\n原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。\n\n#### 一致性(Consistency)\n一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。\n\n当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。\n\n#### 隔离性(Isolation)\n隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。\n\n隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n1. 脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。\n2. 不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。\n3. 幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。\n\nSQL 标准定义了四个隔离级别：\n1. **读取未提交**(Read Uncommited)\n    + 最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致**脏读、幻读或不可重复读**。\n2. **读取已提交**(Read Commited)\n    + 事务智能读取到其他事务已提交的修改。**可以阻止脏读，但不能阻止幻读和不可重复读**。\n3. **可重复读**(Repeatable Read)\n    + 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但不能阻止幻读**。\n4. **串行化**(Serializable)\n    + 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别**可以防止脏读、不可重复读以及幻读**。\n\n#### 持久性(Durability)\n持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 范式\n1. 第一范式(1NF)：无重复的列。\n    在关系模型中，对于添加的一个规范要求，**所有的域都应该是原子性**的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。\n2. 第二范式(2NF)：属性完全依赖于主键\n    第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。\n3. 第三范式(3NF)：任何非主属性不依赖于其它非主属性\n    第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。\n4. BCNF：主属性不能对主键子集依赖\n    巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。\n\n### 索引\n#### 索引的工作原理\n**数据库索引**，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。\n\n在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。\n\n+ 索引的优点：\n    1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n    2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\n    3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。\n    4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。\n    5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，**提高系统的性能**。\n\n+ 索引的缺点：\n    1. **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加。\n    2. 索引需要**占物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。\n    3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。\n\n+ 推荐建立索引的列：\n    1. 在**经常需要搜索**的列上，可以加快搜索的速度；\n    2. 在**作为主键**的列上，强制该列的唯一性和组织表中数据的排列结构；\n    3. 在**经常用在连接**的列上，这些列主要是一些外键，可以加快连接的速度；\n    4. 在**经常需要根据范围进行搜索**的列上创建索引，因为索引已经排序，其指定的范围是连续的；\n    5. 在**经常需要排序**的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；\n    6. 在**经常在 where 子句中使用**的列上面创建索引，加快条件的判断速度。\n\n+ 不应该创建索引的的列：\n    1. 对于那些**在查询中很少使用或者参考的列**不应该创建索引\n        这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。\n    2. 对于那些**只有很少数据值的列**也不应该增加索引\n        这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。\n    3. 对于那些**定义为 text, image 和 bit 数据类型的列**不应该增加索引\n        这是因为，这些列的数据量要么相当大，要么取值很少。\n    4. 当**修改性能远远大于检索性能时**，不应该创建索引\n        这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。\n\n#### 索引结构——B+树与B-树\nMySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。\n\n先简单介绍一下B-树和B+树的结构以及区别。\n\nB-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。\n\n而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。\n\n再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。\n\n而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。\n\n由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。\n\n#### 索引的种类\n根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。\n\n1. 唯一索引\n    唯一索引是不允许其中任何两行具有相同索引值的索引。\n    当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓\n\n2. 主键索引\n    数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。\n    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。\n\n3. 聚集索引\n    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。\n\n##### 聚簇索引与非聚簇索引\n索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n详细可见[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab)\n[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)\n[数据库范式解析](https://blog.csdn.net/GarfieldEr007/article/details/54319026)\n[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n[为什么Mongodb索引用B树，而Mysql用B+树](https://my.oschina.net/u/4365362/blog/4523180)","slug":"数据库基础-1","published":1,"updated":"2021-03-29T08:37:36.751Z","_id":"ckk6y1e3u000b3a6w8cmy0sm7","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"数据库基础知识（1）\"><a href=\"#数据库基础知识（1）\" class=\"headerlink\" title=\"数据库基础知识（1）\"></a>数据库基础知识（1）</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。</p>\n<h4 id=\"原子性-Atomicity\"><a href=\"#原子性-Atomicity\" class=\"headerlink\" title=\"原子性(Atomicity)\"></a>原子性(Atomicity)</h4><p>原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。</p>\n<h4 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h4><p>一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。</p>\n<p>当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。</p>\n<h4 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h4><p>隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。</p>\n<p>隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ol>\n<li>脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。</li>\n<li>不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。</li>\n<li>幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。</li>\n</ol>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ol>\n<li><strong>读取未提交</strong>(Read Uncommited)<ul>\n<li>最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致<strong>脏读、幻读或不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>读取已提交</strong>(Read Commited)<ul>\n<li>事务智能读取到其他事务已提交的修改。<strong>可以阻止脏读，但不能阻止幻读和不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>(Repeatable Read)<ul>\n<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但不能阻止幻读</strong>。</li>\n</ul>\n</li>\n<li><strong>串行化</strong>(Serializable)<ul>\n<li>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h4><p>持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h3 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h3><ol>\n<li>第一范式(1NF)：无重复的列。<br> 在关系模型中，对于添加的一个规范要求，<strong>所有的域都应该是原子性</strong>的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。</li>\n<li>第二范式(2NF)：属性完全依赖于主键<br> 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。</li>\n<li>第三范式(3NF)：任何非主属性不依赖于其它非主属性<br> 第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</li>\n<li>BCNF：主属性不能对主键子集依赖<br> 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。</li>\n</ol>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"索引的工作原理\"><a href=\"#索引的工作原理\" class=\"headerlink\" title=\"索引的工作原理\"></a>索引的工作原理</h4><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>\n<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>\n<ul>\n<li><p>索引的优点：</p>\n<ol>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>\n<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>\n<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，<strong>提高系统的性能</strong>。</li>\n</ol>\n</li>\n<li><p>索引的缺点：</p>\n<ol>\n<li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加。</li>\n<li>索引需要<strong>占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>\n</ol>\n</li>\n<li><p>推荐建立索引的列：</p>\n<ol>\n<li>在<strong>经常需要搜索</strong>的列上，可以加快搜索的速度；</li>\n<li>在<strong>作为主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</li>\n<li>在<strong>经常用在连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</li>\n<li>在<strong>经常需要根据范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>\n<li>在<strong>经常需要排序</strong>的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>\n<li>在<strong>经常在 where 子句中使用</strong>的列上面创建索引，加快条件的判断速度。</li>\n</ol>\n</li>\n<li><p>不应该创建索引的的列：</p>\n<ol>\n<li>对于那些<strong>在查询中很少使用或者参考的列</strong>不应该创建索引<br> 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>\n<li>对于那些<strong>只有很少数据值的列</strong>也不应该增加索引<br> 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>\n<li>对于那些<strong>定义为 text, image 和 bit 数据类型的列</strong>不应该增加索引<br> 这是因为，这些列的数据量要么相当大，要么取值很少。</li>\n<li>当<strong>修改性能远远大于检索性能时</strong>，不应该创建索引<br> 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"索引结构——B-树与B-树\"><a href=\"#索引结构——B-树与B-树\" class=\"headerlink\" title=\"索引结构——B+树与B-树\"></a>索引结构——B+树与B-树</h4><p>MySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。</p>\n<p>先简单介绍一下B-树和B+树的结构以及区别。</p>\n<p>B-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。</p>\n<p>而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。</p>\n<p>再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。</p>\n<p>而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。</p>\n<p>由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。</p>\n<h4 id=\"索引的种类\"><a href=\"#索引的种类\" class=\"headerlink\" title=\"索引的种类\"></a>索引的种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p>\n<ol>\n<li><p>唯一索引<br> 唯一索引是不允许其中任何两行具有相同索引值的索引。<br> 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓</p>\n</li>\n<li><p>主键索引<br> 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。<br> 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>\n</li>\n<li><p>聚集索引<br> 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>\n</li>\n</ol>\n<h5 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h5><p>索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>\n<p>详细可见<a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://zhuanlan.zhihu.com/p/23624390\" target=\"_blank\" rel=\"noopener\">深入浅出数据库索引原理</a><br><a href=\"https://blog.csdn.net/GarfieldEr007/article/details/54319026\" target=\"_blank\" rel=\"noopener\">数据库范式解析</a><br><a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a><br><a href=\"https://my.oschina.net/u/4365362/blog/4523180\" target=\"_blank\" rel=\"noopener\">为什么Mongodb索引用B树，而Mysql用B+树</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据库基础知识（1）\"><a href=\"#数据库基础知识（1）\" class=\"headerlink\" title=\"数据库基础知识（1）\"></a>数据库基础知识（1）</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。</p>\n<h4 id=\"原子性-Atomicity\"><a href=\"#原子性-Atomicity\" class=\"headerlink\" title=\"原子性(Atomicity)\"></a>原子性(Atomicity)</h4><p>原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。</p>\n<h4 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h4><p>一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。</p>\n<p>当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。</p>\n<h4 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h4><p>隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。</p>\n<p>隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ol>\n<li>脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。</li>\n<li>不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。</li>\n<li>幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。</li>\n</ol>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ol>\n<li><strong>读取未提交</strong>(Read Uncommited)<ul>\n<li>最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致<strong>脏读、幻读或不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>读取已提交</strong>(Read Commited)<ul>\n<li>事务智能读取到其他事务已提交的修改。<strong>可以阻止脏读，但不能阻止幻读和不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>(Repeatable Read)<ul>\n<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但不能阻止幻读</strong>。</li>\n</ul>\n</li>\n<li><strong>串行化</strong>(Serializable)<ul>\n<li>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h4><p>持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h3 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h3><ol>\n<li>第一范式(1NF)：无重复的列。<br> 在关系模型中，对于添加的一个规范要求，<strong>所有的域都应该是原子性</strong>的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。</li>\n<li>第二范式(2NF)：属性完全依赖于主键<br> 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。</li>\n<li>第三范式(3NF)：任何非主属性不依赖于其它非主属性<br> 第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</li>\n<li>BCNF：主属性不能对主键子集依赖<br> 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。</li>\n</ol>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"索引的工作原理\"><a href=\"#索引的工作原理\" class=\"headerlink\" title=\"索引的工作原理\"></a>索引的工作原理</h4><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>\n<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>\n<ul>\n<li><p>索引的优点：</p>\n<ol>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>\n<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>\n<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，<strong>提高系统的性能</strong>。</li>\n</ol>\n</li>\n<li><p>索引的缺点：</p>\n<ol>\n<li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加。</li>\n<li>索引需要<strong>占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>\n</ol>\n</li>\n<li><p>推荐建立索引的列：</p>\n<ol>\n<li>在<strong>经常需要搜索</strong>的列上，可以加快搜索的速度；</li>\n<li>在<strong>作为主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</li>\n<li>在<strong>经常用在连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</li>\n<li>在<strong>经常需要根据范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>\n<li>在<strong>经常需要排序</strong>的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>\n<li>在<strong>经常在 where 子句中使用</strong>的列上面创建索引，加快条件的判断速度。</li>\n</ol>\n</li>\n<li><p>不应该创建索引的的列：</p>\n<ol>\n<li>对于那些<strong>在查询中很少使用或者参考的列</strong>不应该创建索引<br> 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>\n<li>对于那些<strong>只有很少数据值的列</strong>也不应该增加索引<br> 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>\n<li>对于那些<strong>定义为 text, image 和 bit 数据类型的列</strong>不应该增加索引<br> 这是因为，这些列的数据量要么相当大，要么取值很少。</li>\n<li>当<strong>修改性能远远大于检索性能时</strong>，不应该创建索引<br> 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"索引结构——B-树与B-树\"><a href=\"#索引结构——B-树与B-树\" class=\"headerlink\" title=\"索引结构——B+树与B-树\"></a>索引结构——B+树与B-树</h4><p>MySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。</p>\n<p>先简单介绍一下B-树和B+树的结构以及区别。</p>\n<p>B-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。</p>\n<p>而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。</p>\n<p>再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。</p>\n<p>而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。</p>\n<p>由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。</p>\n<h4 id=\"索引的种类\"><a href=\"#索引的种类\" class=\"headerlink\" title=\"索引的种类\"></a>索引的种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p>\n<ol>\n<li><p>唯一索引<br> 唯一索引是不允许其中任何两行具有相同索引值的索引。<br> 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓</p>\n</li>\n<li><p>主键索引<br> 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。<br> 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>\n</li>\n<li><p>聚集索引<br> 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>\n</li>\n</ol>\n<h5 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h5><p>索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>\n<p>详细可见<a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://zhuanlan.zhihu.com/p/23624390\" target=\"_blank\" rel=\"noopener\">深入浅出数据库索引原理</a><br><a href=\"https://blog.csdn.net/GarfieldEr007/article/details/54319026\" target=\"_blank\" rel=\"noopener\">数据库范式解析</a><br><a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a><br><a href=\"https://my.oschina.net/u/4365362/blog/4523180\" target=\"_blank\" rel=\"noopener\">为什么Mongodb索引用B树，而Mysql用B+树</a></p>\n"},{"title":"数据库基础-2","date":"2021-01-24T14:59:00.000Z","top_img":"/img/cover/database.jpg","cover":"/img/cover/database.jpg","_content":"\n## 数据库基础知识（2）\n### Mysql\n#### 超键 候选键 主键 外键\n**超键(super key)**：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。\n**候选键(candidate key)**：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。\n**主键(primary key)**：用户选作元组标识的一个候选键。\n**外键(foreign key)**：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。\n\n#### 视图\n基本语法：\n```sql\ncreate view view_name as select_sql;                -- 创建视图\nselect * from view_name;                            -- 查看视图\ncreate or replace view name as select_sql;          -- 更新视图，不更新表\nupdate view_name;                                   -- 更新视图，也更新表\ndrop view view_name;                                -- 删除视图\n```\n\n视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。\n\n一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。\n\n视图和表的区别：\n1. 视图是已经编译好的sql语句；而表不是。  \n2. 视图没有实际的物理记录；而表有。\n3. 表是内容；视图是窗口。\n4. 表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。\n5. 表是内模式；视图是外模式。\n6. 视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。\n7. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。\n8. 视图的建立和删除只影响视图本身，不影响对应的基本表。\n\n视图和表的联系：\n    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。\n\n#### drop delete truncate\n基本语法：\n```sql\ndrop table table_name                           -- 直接删掉表\ntruncate table table_name                       -- 删除表中数据，再插入时自增长id又从1开始\ndelete from table_name where_sql                -- 删除表中数据，可以加where字句\n```\n\n1. 一般而言，drop > truncate > delete\n2. 应用范围：truncate 只能对 table；delete 可以是 table 和 view 。\n3. truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。\n4. 表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。\n5. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。\n6. delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。\n7. truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。\n8. truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。\n9. truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。\n10. 对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。\n\n#### 连接的种类\n查询分析器中执行：\n```sql\n--建表table1,table2：\ncreate table table1(id int,name varchar(10));\ncreate table table2(id int,score int);\n\ninsert into table1 select 1,'lee';\ninsert into table1 select 2,'zhang';\ninsert into table1 select 4,'wang';\ninsert into table2 select 1,90;\ninsert into table2 select 2,100;\ninsert into table2 select 3,70;\n```\n\n如表:\n```sql\n-------------------------------------------------\n|  table1  |  table2  |\n-------------------------------------------------\n| id  name | id score |\n| 1    lee | 1     90 |\n| 2  zhang | 2    100 |\n| 4   wang | 3     70 |\n-------------------------------------------------\n```\n\n以下均在查询分析器中执行\n##### 一、外连接\n概念：包括左向外联接、右向外联接和完整外部联接\n\n1. 左连接：`left join`或`left outer join`\n    左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。\n\n    ```sql\n    select * from table1 left join table2 on table1.id=table2.id\n    -----------result------------\n    | id  name   id  score |\n    -----------------------------\n    | 1    lee    1     90 |\n    | 2  zhang    2    100 |\n    | 4   wang  NULL  NULL |\n    -----------------------------\n    -- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示\n    ```\n\n2. 右连接：`right join`或`right outer join`\n    右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。\n\n    ```sql\n    select * from table1 right join table2 on table1.id=table2.id\n    ------------result------------\n    | id    name id  score |\n    ------------------------------\n    |   1    lee  1     90 |\n    |   2  zhang  2    100 |\n    | NULL  NULL  3     70 |\n    ------------------------------\n    -- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示\n    ```\n\n3. 完整外部联接:`full join`或`full outer join`\n    完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。\n    ```sql\n    select * from table1 full join table2 on table1.id=table2.id\n    -------------结果-------------\n    | id   name   id score |\n    ------------------------------\n    | 1     lee    1    90 |\n    | 2   zhang    2   100 |\n    | 4    wang NULL  NULL |\n    | NULL NULL    3    70 |\n    ------------------------------\n    -- 注释：返回左右连接的和（见上左、右连接）\n    ```\n\n##### 二、内连接\n概念：内联接是用比较运算符比较要联接列的值的联接\n\n内连接：`join`或`inner join`\n```sql\nselect * from table1 join table2 on table1.id=table2.id\n-------------结果-------------\n| id  name  id  score |\n------------------------------\n|  1   lee   1     90 |\n|  2 zhang   2    100 |\n------------------------------\n-- 注释：只返回符合条件的table1和table2的列\n```\n等价（与下列执行效果相同）\n```sql\nA: select a.*, b.* from table1 a, table2 b where a.id=b.id\nB: select * from table1 cross join table2 where table1.id=table2.id\n-- 注：cross join后加条件只能用where, 不能用on\n```\n\n##### 三、交叉连接(完全)\n概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）\n\n交叉连接：`cross join`(不带条件where...)\n\n```sql\nselect * from table1 cross join table2\n-------------结果-------------\n| id  name  id score |\n------------------------------\n| 1    lee   1    90 |\n| 2  zhang   1    90 |\n| 4   wang   1    90 |\n| 1    lee   2   100 |\n| 2  zhang   2   100 |\n| 4   wang   2   100 |\n| 1    lee   3    70 |\n| 2  zhang   3    70 |\n| 4   wang   3    70 |\n------------------------------\n-- 注释：返回3*3=9条记录，即笛卡尔积\n```\n\n等价\n```sql\nA: select * from table1, table2\n```\n\n#### 数据库优化的思路\n##### 1. SQL语句优化\n- 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描。  \n- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n    ```sql\n    select id from t where num is null\n    ```\n    可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：\n    ```sql\n    select id from t where num=0\n    ```\n- 很多时候用 exists 代替 in 是一个好的选择。\n- 用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。\n\n##### 2. 索引优化\n详见[数据库基础-1](https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/)索引部分\n\n##### 3. 数据库结构优化\n1. 范式优化： 比如消除冗余（节省空间......）\n2. 反范式优化：比如适当加冗余等（减少join）\n3. 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。\n\n- 拆分其实又分垂直拆分和水平拆分：\n    + **垂直拆分**：\n    解决问题：表与表之间的io竞争 \n    不解决问题：单表中数据量增长出现的压力 \n    + **水平拆分**：    \n    解决问题：单表中数据量增长出现的压力 \n    不解决问题：表与表之间的io争夺\n\n    + 案例： 简单购物系统暂设涉及如下表：\n        1. 产品表（数据量10w，稳定） \n        2. 订单表（数据量200w，且有增长趋势）\n        3. 用户表 （数据量100w，且有增长趋势）    \n    \n        + 垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上\n        + 水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)\n\n##### 4. 服务器硬件优化\n这个么，多花钱咯\n\n#### 存储过程与触发器的区别\n触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。\n\n触发器是在一个修改了指定表中的数据时执行的存储过程。\n\n通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。\n\n触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。\n\n#### 锁\n在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。\n\nMySQL中这3种锁的特性可大致归纳如下:\n\n| 模式 | 开锁、加锁速度、死锁、粒度、并发性能 |\n| --- | --- |\n| 行级锁 | 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 |\n| 页面锁 | 开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 |\n| 表级锁 | 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 |\n\n而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。\n\n#### 事务日志\n事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。\n如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。\n\nMySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：\n+ Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的\n+ Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。\n+ Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c)\n[SQL视图](https://www.w3school.com.cn/sql/sql_view.asp)\n[视图和表的区别](https://www.cnblogs.com/binyao/p/4899970.html)\n[Mysql常见的三种存储引擎](https://segmentfault.com/a/1190000012588602)\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)","source":"_posts/数据库基础-2.md","raw":"---\ntitle: 数据库基础-2\ndate: 2021-01-24 22:59:00\ntop_img: /img/cover/database.jpg\ncover: /img/cover/database.jpg\ntags: [Database, intern, 笔记]\n---\n\n## 数据库基础知识（2）\n### Mysql\n#### 超键 候选键 主键 外键\n**超键(super key)**：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。\n**候选键(candidate key)**：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。\n**主键(primary key)**：用户选作元组标识的一个候选键。\n**外键(foreign key)**：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。\n\n#### 视图\n基本语法：\n```sql\ncreate view view_name as select_sql;                -- 创建视图\nselect * from view_name;                            -- 查看视图\ncreate or replace view name as select_sql;          -- 更新视图，不更新表\nupdate view_name;                                   -- 更新视图，也更新表\ndrop view view_name;                                -- 删除视图\n```\n\n视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。\n\n一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。\n\n视图和表的区别：\n1. 视图是已经编译好的sql语句；而表不是。  \n2. 视图没有实际的物理记录；而表有。\n3. 表是内容；视图是窗口。\n4. 表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。\n5. 表是内模式；视图是外模式。\n6. 视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。\n7. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。\n8. 视图的建立和删除只影响视图本身，不影响对应的基本表。\n\n视图和表的联系：\n    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。\n\n#### drop delete truncate\n基本语法：\n```sql\ndrop table table_name                           -- 直接删掉表\ntruncate table table_name                       -- 删除表中数据，再插入时自增长id又从1开始\ndelete from table_name where_sql                -- 删除表中数据，可以加where字句\n```\n\n1. 一般而言，drop > truncate > delete\n2. 应用范围：truncate 只能对 table；delete 可以是 table 和 view 。\n3. truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。\n4. 表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。\n5. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。\n6. delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。\n7. truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。\n8. truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。\n9. truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。\n10. 对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。\n\n#### 连接的种类\n查询分析器中执行：\n```sql\n--建表table1,table2：\ncreate table table1(id int,name varchar(10));\ncreate table table2(id int,score int);\n\ninsert into table1 select 1,'lee';\ninsert into table1 select 2,'zhang';\ninsert into table1 select 4,'wang';\ninsert into table2 select 1,90;\ninsert into table2 select 2,100;\ninsert into table2 select 3,70;\n```\n\n如表:\n```sql\n-------------------------------------------------\n|  table1  |  table2  |\n-------------------------------------------------\n| id  name | id score |\n| 1    lee | 1     90 |\n| 2  zhang | 2    100 |\n| 4   wang | 3     70 |\n-------------------------------------------------\n```\n\n以下均在查询分析器中执行\n##### 一、外连接\n概念：包括左向外联接、右向外联接和完整外部联接\n\n1. 左连接：`left join`或`left outer join`\n    左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。\n\n    ```sql\n    select * from table1 left join table2 on table1.id=table2.id\n    -----------result------------\n    | id  name   id  score |\n    -----------------------------\n    | 1    lee    1     90 |\n    | 2  zhang    2    100 |\n    | 4   wang  NULL  NULL |\n    -----------------------------\n    -- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示\n    ```\n\n2. 右连接：`right join`或`right outer join`\n    右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。\n\n    ```sql\n    select * from table1 right join table2 on table1.id=table2.id\n    ------------result------------\n    | id    name id  score |\n    ------------------------------\n    |   1    lee  1     90 |\n    |   2  zhang  2    100 |\n    | NULL  NULL  3     70 |\n    ------------------------------\n    -- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示\n    ```\n\n3. 完整外部联接:`full join`或`full outer join`\n    完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。\n    ```sql\n    select * from table1 full join table2 on table1.id=table2.id\n    -------------结果-------------\n    | id   name   id score |\n    ------------------------------\n    | 1     lee    1    90 |\n    | 2   zhang    2   100 |\n    | 4    wang NULL  NULL |\n    | NULL NULL    3    70 |\n    ------------------------------\n    -- 注释：返回左右连接的和（见上左、右连接）\n    ```\n\n##### 二、内连接\n概念：内联接是用比较运算符比较要联接列的值的联接\n\n内连接：`join`或`inner join`\n```sql\nselect * from table1 join table2 on table1.id=table2.id\n-------------结果-------------\n| id  name  id  score |\n------------------------------\n|  1   lee   1     90 |\n|  2 zhang   2    100 |\n------------------------------\n-- 注释：只返回符合条件的table1和table2的列\n```\n等价（与下列执行效果相同）\n```sql\nA: select a.*, b.* from table1 a, table2 b where a.id=b.id\nB: select * from table1 cross join table2 where table1.id=table2.id\n-- 注：cross join后加条件只能用where, 不能用on\n```\n\n##### 三、交叉连接(完全)\n概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）\n\n交叉连接：`cross join`(不带条件where...)\n\n```sql\nselect * from table1 cross join table2\n-------------结果-------------\n| id  name  id score |\n------------------------------\n| 1    lee   1    90 |\n| 2  zhang   1    90 |\n| 4   wang   1    90 |\n| 1    lee   2   100 |\n| 2  zhang   2   100 |\n| 4   wang   2   100 |\n| 1    lee   3    70 |\n| 2  zhang   3    70 |\n| 4   wang   3    70 |\n------------------------------\n-- 注释：返回3*3=9条记录，即笛卡尔积\n```\n\n等价\n```sql\nA: select * from table1, table2\n```\n\n#### 数据库优化的思路\n##### 1. SQL语句优化\n- 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描。  \n- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n    ```sql\n    select id from t where num is null\n    ```\n    可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：\n    ```sql\n    select id from t where num=0\n    ```\n- 很多时候用 exists 代替 in 是一个好的选择。\n- 用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。\n\n##### 2. 索引优化\n详见[数据库基础-1](https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/)索引部分\n\n##### 3. 数据库结构优化\n1. 范式优化： 比如消除冗余（节省空间......）\n2. 反范式优化：比如适当加冗余等（减少join）\n3. 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。\n\n- 拆分其实又分垂直拆分和水平拆分：\n    + **垂直拆分**：\n    解决问题：表与表之间的io竞争 \n    不解决问题：单表中数据量增长出现的压力 \n    + **水平拆分**：    \n    解决问题：单表中数据量增长出现的压力 \n    不解决问题：表与表之间的io争夺\n\n    + 案例： 简单购物系统暂设涉及如下表：\n        1. 产品表（数据量10w，稳定） \n        2. 订单表（数据量200w，且有增长趋势）\n        3. 用户表 （数据量100w，且有增长趋势）    \n    \n        + 垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上\n        + 水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)\n\n##### 4. 服务器硬件优化\n这个么，多花钱咯\n\n#### 存储过程与触发器的区别\n触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。\n\n触发器是在一个修改了指定表中的数据时执行的存储过程。\n\n通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。\n\n触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。\n\n#### 锁\n在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。\n\nMySQL中这3种锁的特性可大致归纳如下:\n\n| 模式 | 开锁、加锁速度、死锁、粒度、并发性能 |\n| --- | --- |\n| 行级锁 | 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 |\n| 页面锁 | 开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 |\n| 表级锁 | 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 |\n\n而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。\n\n#### 事务日志\n事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。\n如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。\n\nMySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：\n+ Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的\n+ Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。\n+ Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c)\n[SQL视图](https://www.w3school.com.cn/sql/sql_view.asp)\n[视图和表的区别](https://www.cnblogs.com/binyao/p/4899970.html)\n[Mysql常见的三种存储引擎](https://segmentfault.com/a/1190000012588602)\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)","slug":"数据库基础-2","published":1,"updated":"2021-03-29T08:37:36.752Z","_id":"ckkca6rbr0000w46wa4iverw0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"数据库基础知识（2）\"><a href=\"#数据库基础知识（2）\" class=\"headerlink\" title=\"数据库基础知识（2）\"></a>数据库基础知识（2）</h2><h3 id=\"Mysql\"><a href=\"#Mysql\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h3><h4 id=\"超键-候选键-主键-外键\"><a href=\"#超键-候选键-主键-外键\" class=\"headerlink\" title=\"超键 候选键 主键 外键\"></a>超键 候选键 主键 外键</h4><p><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。<br><strong>候选键(candidate key)</strong>：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。<br><strong>主键(primary key)</strong>：用户选作元组标识的一个候选键。<br><strong>外键(foreign key)</strong>：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</p>\n<h4 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> view_name <span class=\"keyword\">as</span> select_sql;                <span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> view_name;                            <span class=\"comment\">-- 查看视图</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">or</span> <span class=\"keyword\">replace</span> <span class=\"keyword\">view</span> <span class=\"keyword\">name</span> <span class=\"keyword\">as</span> select_sql;          <span class=\"comment\">-- 更新视图，不更新表</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> view_name;                                   <span class=\"comment\">-- 更新视图，也更新表</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> view_name;                                <span class=\"comment\">-- 删除视图</span></span><br></pre></td></tr></table></figure></p>\n<p>视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。</p>\n<p>一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。</p>\n<p>视图和表的区别：</p>\n<ol>\n<li>视图是已经编译好的sql语句；而表不是。  </li>\n<li>视图没有实际的物理记录；而表有。</li>\n<li>表是内容；视图是窗口。</li>\n<li>表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。</li>\n<li>表是内模式；视图是外模式。</li>\n<li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。</li>\n<li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li>\n<li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li>\n</ol>\n<p>视图和表的联系：<br>    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p>\n<h4 id=\"drop-delete-truncate\"><a href=\"#drop-delete-truncate\" class=\"headerlink\" title=\"drop delete truncate\"></a>drop delete truncate</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> table_name                           <span class=\"comment\">-- 直接删掉表</span></span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">table</span> table_name                       <span class=\"comment\">-- 删除表中数据，再插入时自增长id又从1开始</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> table_name where_sql                <span class=\"comment\">-- 删除表中数据，可以加where字句</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>一般而言，drop &gt; truncate &gt; delete</li>\n<li>应用范围：truncate 只能对 table；delete 可以是 table 和 view 。</li>\n<li>truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。</li>\n<li>表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。</li>\n<li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。</li>\n<li>delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。</li>\n<li>truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。</li>\n<li>truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。</li>\n<li>truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。</li>\n<li>对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。</li>\n</ol>\n<h4 id=\"连接的种类\"><a href=\"#连接的种类\" class=\"headerlink\" title=\"连接的种类\"></a>连接的种类</h4><p>查询分析器中执行：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--建表table1,table2：</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table1(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,<span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table2(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,score <span class=\"built_in\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"string\">'lee'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"string\">'zhang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">4</span>,<span class=\"string\">'wang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"number\">90</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">3</span>,<span class=\"number\">70</span>;</span><br></pre></td></tr></table></figure></p>\n<p>如表:<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">|  table1  |  table2  |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">| id  name | id score |</span><br><span class=\"line\">| 1    lee | 1     90 |</span><br><span class=\"line\">| 2  zhang | 2    100 |</span><br><span class=\"line\">| 4   wang | 3     70 |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br></pre></td></tr></table></figure></p>\n<p>以下均在查询分析器中执行</p>\n<h5 id=\"一、外连接\"><a href=\"#一、外连接\" class=\"headerlink\" title=\"一、外连接\"></a>一、外连接</h5><p>概念：包括左向外联接、右向外联接和完整外部联接</p>\n<ol>\n<li><p>左连接：<code>left join</code>或<code>left outer join</code><br> 左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-----------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee    <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang    <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang  <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>右连接：<code>right join</code>或<code>right outer join</code><br> 右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">------------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>    <span class=\"keyword\">name</span> <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|   <span class=\"number\">1</span>    lee  <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|   <span class=\"number\">2</span>  zhang  <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span>  <span class=\"number\">3</span>     <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完整外部联接:<code>full join</code>或<code>full outer join</code><br> 完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">full</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>   <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>     lee    <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>   zhang    <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>    wang <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span> <span class=\"literal\">NULL</span>    <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回左右连接的和（见上左、右连接）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"二、内连接\"><a href=\"#二、内连接\" class=\"headerlink\" title=\"二、内连接\"></a>二、内连接</h5><p>概念：内联接是用比较运算符比较要联接列的值的联接</p>\n<p>内连接：<code>join</code>或<code>inner join</code><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|  <span class=\"number\">1</span>   lee   <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|  <span class=\"number\">2</span> zhang   <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：只返回符合条件的table1和table2的列</span></span><br></pre></td></tr></table></figure><br>等价（与下列执行效果相同）<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> a.*, b.* <span class=\"keyword\">from</span> table1 a, table2 b <span class=\"keyword\">where</span> a.id=b.id</span><br><span class=\"line\">B: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">where</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-- 注：cross join后加条件只能用where, 不能用on</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"三、交叉连接-完全\"><a href=\"#三、交叉连接-完全\" class=\"headerlink\" title=\"三、交叉连接(完全)\"></a>三、交叉连接(完全)</h5><p>概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）</p>\n<p>交叉连接：<code>cross join</code>(不带条件where…)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回3*3=9条记录，即笛卡尔积</span></span><br></pre></td></tr></table></figure>\n<p>等价<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1, table2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数据库优化的思路\"><a href=\"#数据库优化的思路\" class=\"headerlink\" title=\"数据库优化的思路\"></a>数据库优化的思路</h4><h5 id=\"1-SQL语句优化\"><a href=\"#1-SQL语句优化\" class=\"headerlink\" title=\"1. SQL语句优化\"></a>1. SQL语句优化</h5><ul>\n<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将导致引擎放弃使用索引而进行全表扫描。  </li>\n<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span> <span class=\"keyword\">is</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span>=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n<li>很多时候用 exists 代替 in 是一个好的选择。</li>\n<li>用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。</li>\n</ul>\n<h5 id=\"2-索引优化\"><a href=\"#2-索引优化\" class=\"headerlink\" title=\"2. 索引优化\"></a>2. 索引优化</h5><p>详见<a href=\"https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/\">数据库基础-1</a>索引部分</p>\n<h5 id=\"3-数据库结构优化\"><a href=\"#3-数据库结构优化\" class=\"headerlink\" title=\"3. 数据库结构优化\"></a>3. 数据库结构优化</h5><ol>\n<li>范式优化： 比如消除冗余（节省空间……）</li>\n<li>反范式优化：比如适当加冗余等（减少join）</li>\n<li>拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。</li>\n</ol>\n<ul>\n<li><p>拆分其实又分垂直拆分和水平拆分：</p>\n<ul>\n<li><strong>垂直拆分</strong>：<br>解决问题：表与表之间的io竞争<br>不解决问题：单表中数据量增长出现的压力 </li>\n<li><p><strong>水平拆分</strong>：<br>解决问题：单表中数据量增长出现的压力<br>不解决问题：表与表之间的io争夺</p>\n</li>\n<li><p>案例： 简单购物系统暂设涉及如下表：</p>\n<ol>\n<li>产品表（数据量10w，稳定） </li>\n<li>订单表（数据量200w，且有增长趋势）</li>\n<li>用户表 （数据量100w，且有增长趋势）    </li>\n</ol>\n<ul>\n<li>垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上</li>\n<li>水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"4-服务器硬件优化\"><a href=\"#4-服务器硬件优化\" class=\"headerlink\" title=\"4. 服务器硬件优化\"></a>4. 服务器硬件优化</h5><p>这个么，多花钱咯</p>\n<h4 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h4><p>触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。</p>\n<p>触发器是在一个修改了指定表中的数据时执行的存储过程。</p>\n<p>通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p>\n<p>触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p>\n<h4 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h4><p>在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。</p>\n<p>MySQL中这3种锁的特性可大致归纳如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>开锁、加锁速度、死锁、粒度、并发性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>行级锁</td>\n<td>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td>\n</tr>\n<tr>\n<td>页面锁</td>\n<td>开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td>\n</tr>\n<tr>\n<td>表级锁</td>\n<td>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。</p>\n<h4 id=\"事务日志\"><a href=\"#事务日志\" class=\"headerlink\" title=\"事务日志\"></a>事务日志</h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。<br>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>\n<p>MySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：</p>\n<ul>\n<li>Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的</li>\n<li>Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。</li>\n<li>Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://www.w3school.com.cn/sql/sql_view.asp\" target=\"_blank\" rel=\"noopener\">SQL视图</a><br><a href=\"https://www.cnblogs.com/binyao/p/4899970.html\" target=\"_blank\" rel=\"noopener\">视图和表的区别</a><br><a href=\"https://segmentfault.com/a/1190000012588602\" target=\"_blank\" rel=\"noopener\">Mysql常见的三种存储引擎</a><br><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据库基础知识（2）\"><a href=\"#数据库基础知识（2）\" class=\"headerlink\" title=\"数据库基础知识（2）\"></a>数据库基础知识（2）</h2><h3 id=\"Mysql\"><a href=\"#Mysql\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h3><h4 id=\"超键-候选键-主键-外键\"><a href=\"#超键-候选键-主键-外键\" class=\"headerlink\" title=\"超键 候选键 主键 外键\"></a>超键 候选键 主键 外键</h4><p><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。<br><strong>候选键(candidate key)</strong>：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。<br><strong>主键(primary key)</strong>：用户选作元组标识的一个候选键。<br><strong>外键(foreign key)</strong>：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</p>\n<h4 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> view_name <span class=\"keyword\">as</span> select_sql;                <span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> view_name;                            <span class=\"comment\">-- 查看视图</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">or</span> <span class=\"keyword\">replace</span> <span class=\"keyword\">view</span> <span class=\"keyword\">name</span> <span class=\"keyword\">as</span> select_sql;          <span class=\"comment\">-- 更新视图，不更新表</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> view_name;                                   <span class=\"comment\">-- 更新视图，也更新表</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> view_name;                                <span class=\"comment\">-- 删除视图</span></span><br></pre></td></tr></table></figure></p>\n<p>视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。</p>\n<p>一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。</p>\n<p>视图和表的区别：</p>\n<ol>\n<li>视图是已经编译好的sql语句；而表不是。  </li>\n<li>视图没有实际的物理记录；而表有。</li>\n<li>表是内容；视图是窗口。</li>\n<li>表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。</li>\n<li>表是内模式；视图是外模式。</li>\n<li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。</li>\n<li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li>\n<li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li>\n</ol>\n<p>视图和表的联系：<br>    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p>\n<h4 id=\"drop-delete-truncate\"><a href=\"#drop-delete-truncate\" class=\"headerlink\" title=\"drop delete truncate\"></a>drop delete truncate</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> table_name                           <span class=\"comment\">-- 直接删掉表</span></span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">table</span> table_name                       <span class=\"comment\">-- 删除表中数据，再插入时自增长id又从1开始</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> table_name where_sql                <span class=\"comment\">-- 删除表中数据，可以加where字句</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>一般而言，drop &gt; truncate &gt; delete</li>\n<li>应用范围：truncate 只能对 table；delete 可以是 table 和 view 。</li>\n<li>truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。</li>\n<li>表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。</li>\n<li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。</li>\n<li>delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。</li>\n<li>truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。</li>\n<li>truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。</li>\n<li>truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。</li>\n<li>对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。</li>\n</ol>\n<h4 id=\"连接的种类\"><a href=\"#连接的种类\" class=\"headerlink\" title=\"连接的种类\"></a>连接的种类</h4><p>查询分析器中执行：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--建表table1,table2：</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table1(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,<span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table2(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,score <span class=\"built_in\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"string\">'lee'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"string\">'zhang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">4</span>,<span class=\"string\">'wang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"number\">90</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">3</span>,<span class=\"number\">70</span>;</span><br></pre></td></tr></table></figure></p>\n<p>如表:<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">|  table1  |  table2  |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">| id  name | id score |</span><br><span class=\"line\">| 1    lee | 1     90 |</span><br><span class=\"line\">| 2  zhang | 2    100 |</span><br><span class=\"line\">| 4   wang | 3     70 |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br></pre></td></tr></table></figure></p>\n<p>以下均在查询分析器中执行</p>\n<h5 id=\"一、外连接\"><a href=\"#一、外连接\" class=\"headerlink\" title=\"一、外连接\"></a>一、外连接</h5><p>概念：包括左向外联接、右向外联接和完整外部联接</p>\n<ol>\n<li><p>左连接：<code>left join</code>或<code>left outer join</code><br> 左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-----------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee    <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang    <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang  <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>右连接：<code>right join</code>或<code>right outer join</code><br> 右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">------------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>    <span class=\"keyword\">name</span> <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|   <span class=\"number\">1</span>    lee  <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|   <span class=\"number\">2</span>  zhang  <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span>  <span class=\"number\">3</span>     <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完整外部联接:<code>full join</code>或<code>full outer join</code><br> 完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">full</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>   <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>     lee    <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>   zhang    <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>    wang <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span> <span class=\"literal\">NULL</span>    <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回左右连接的和（见上左、右连接）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"二、内连接\"><a href=\"#二、内连接\" class=\"headerlink\" title=\"二、内连接\"></a>二、内连接</h5><p>概念：内联接是用比较运算符比较要联接列的值的联接</p>\n<p>内连接：<code>join</code>或<code>inner join</code><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|  <span class=\"number\">1</span>   lee   <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|  <span class=\"number\">2</span> zhang   <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：只返回符合条件的table1和table2的列</span></span><br></pre></td></tr></table></figure><br>等价（与下列执行效果相同）<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> a.*, b.* <span class=\"keyword\">from</span> table1 a, table2 b <span class=\"keyword\">where</span> a.id=b.id</span><br><span class=\"line\">B: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">where</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-- 注：cross join后加条件只能用where, 不能用on</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"三、交叉连接-完全\"><a href=\"#三、交叉连接-完全\" class=\"headerlink\" title=\"三、交叉连接(完全)\"></a>三、交叉连接(完全)</h5><p>概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）</p>\n<p>交叉连接：<code>cross join</code>(不带条件where…)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回3*3=9条记录，即笛卡尔积</span></span><br></pre></td></tr></table></figure>\n<p>等价<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1, table2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数据库优化的思路\"><a href=\"#数据库优化的思路\" class=\"headerlink\" title=\"数据库优化的思路\"></a>数据库优化的思路</h4><h5 id=\"1-SQL语句优化\"><a href=\"#1-SQL语句优化\" class=\"headerlink\" title=\"1. SQL语句优化\"></a>1. SQL语句优化</h5><ul>\n<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将导致引擎放弃使用索引而进行全表扫描。  </li>\n<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span> <span class=\"keyword\">is</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span>=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n<li>很多时候用 exists 代替 in 是一个好的选择。</li>\n<li>用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。</li>\n</ul>\n<h5 id=\"2-索引优化\"><a href=\"#2-索引优化\" class=\"headerlink\" title=\"2. 索引优化\"></a>2. 索引优化</h5><p>详见<a href=\"https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/\">数据库基础-1</a>索引部分</p>\n<h5 id=\"3-数据库结构优化\"><a href=\"#3-数据库结构优化\" class=\"headerlink\" title=\"3. 数据库结构优化\"></a>3. 数据库结构优化</h5><ol>\n<li>范式优化： 比如消除冗余（节省空间……）</li>\n<li>反范式优化：比如适当加冗余等（减少join）</li>\n<li>拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。</li>\n</ol>\n<ul>\n<li><p>拆分其实又分垂直拆分和水平拆分：</p>\n<ul>\n<li><strong>垂直拆分</strong>：<br>解决问题：表与表之间的io竞争<br>不解决问题：单表中数据量增长出现的压力 </li>\n<li><p><strong>水平拆分</strong>：<br>解决问题：单表中数据量增长出现的压力<br>不解决问题：表与表之间的io争夺</p>\n</li>\n<li><p>案例： 简单购物系统暂设涉及如下表：</p>\n<ol>\n<li>产品表（数据量10w，稳定） </li>\n<li>订单表（数据量200w，且有增长趋势）</li>\n<li>用户表 （数据量100w，且有增长趋势）    </li>\n</ol>\n<ul>\n<li>垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上</li>\n<li>水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"4-服务器硬件优化\"><a href=\"#4-服务器硬件优化\" class=\"headerlink\" title=\"4. 服务器硬件优化\"></a>4. 服务器硬件优化</h5><p>这个么，多花钱咯</p>\n<h4 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h4><p>触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。</p>\n<p>触发器是在一个修改了指定表中的数据时执行的存储过程。</p>\n<p>通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p>\n<p>触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p>\n<h4 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h4><p>在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。</p>\n<p>MySQL中这3种锁的特性可大致归纳如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>开锁、加锁速度、死锁、粒度、并发性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>行级锁</td>\n<td>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td>\n</tr>\n<tr>\n<td>页面锁</td>\n<td>开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td>\n</tr>\n<tr>\n<td>表级锁</td>\n<td>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。</p>\n<h4 id=\"事务日志\"><a href=\"#事务日志\" class=\"headerlink\" title=\"事务日志\"></a>事务日志</h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。<br>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>\n<p>MySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：</p>\n<ul>\n<li>Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的</li>\n<li>Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。</li>\n<li>Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://www.w3school.com.cn/sql/sql_view.asp\" target=\"_blank\" rel=\"noopener\">SQL视图</a><br><a href=\"https://www.cnblogs.com/binyao/p/4899970.html\" target=\"_blank\" rel=\"noopener\">视图和表的区别</a><br><a href=\"https://segmentfault.com/a/1190000012588602\" target=\"_blank\" rel=\"noopener\">Mysql常见的三种存储引擎</a><br><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a></p>\n"},{"title":"数据库基础-3","date":"2021-02-02T13:13:24.000Z","top_img":"/img/cover/database.jpg","cover":"/img/cover/database.jpg","_content":"\n## 数据库基础知识（3）\n### 当前读与快照读\n1. 当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；\n\n    使用当前读的操作主要包括：**显式加锁的读操作与插入/更新/删除等写操作**，如下所示：\n\n    ```sql\n    select * from table where ? lock in share mode;          -- 显式加锁的读操作\n    select * from table where ? for update;                  -- 显式加锁的读操作\n    insert into table values (…);                            -- 插入操作\n    update table set ? where ?;                              -- 更新操作\n    delete from table where ?;                               -- 删除操作\n    ```\n\n    > 注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。\n\n2. 快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；\n\n    InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；\n\n### MVCC 原理\nMVCC（多版本并发控制）的最大好处：**读不加任何锁**，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；\n\n**MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。**\n\n在REPEATABLE READ隔离级别下，MVCC的操作方式如下：\n+ **SELECT**\n    InnoDB会根据以下两个条件检查每行记录：\n    1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。\n    2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。\n    只有符合上述两个条件的记录，才能返回作为查询结果\n+ **INSERT**\n    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。\n+ **DELETE**\n    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。\n+ **UPDATE**\n    InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。\n\n保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。\n\n### MySQL存储引擎\n```sql\nshow engines;                                            -- 查看存储引擎\nshow variables like 'storage_engine';                    -- 查看数据库默认使用的引擎\ncreate table table_name()engine=engine_name;             -- 建表时设置引擎\n\nshow status like '%table_lock%'                          -- 查看表级锁争用情况\nshow status like 'innodb_row_lock'                       -- 查看InnoDB行级锁争用情况\n```\n\nMysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。\n\n#### InnoDB存储引擎\nInnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用\n\n> InnoDB主要特性\n+ 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合\n+ 为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上\n+ InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键\n\n+ InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高\n+ 共享锁和排他锁是InnoDB实现的两种标准的行锁\n+ InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)\n\n##### InnoDB 锁算法\nInnoDB 的三种锁算法：\n\n| 行锁算法 | 锁定内容 |\n| --- | --- |\n| Record Lock | 记录锁，锁定一个行记录 |\n| Gap Lock | 间隙锁，锁定一个区间 |\n| Next-key Lock | 记录锁+间隙锁，锁定行记录+区间 |\n\nInnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；\n\n不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：\n\n| 等值查询使用的索引类型 | 锁定内容 |\n| --- | --- |\n| 主键(聚簇索引) | 对聚簇索引记录 + 记录锁 |\n| 唯一索引 | 对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁 |\n| 普通索引 | 对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁 |\n| 不使用索引 | 对聚簇索引全表 + next-key锁 |\n\n行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。\n\n#### MyISAM存储引擎\nMyISAM 基于`ISAM存储引擎`，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有**较高的插入、查询速度，但不支持事务**。\n\n> MyISAM主要特性：\n+ 被大文件系统和操作系统支持\n+ 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成\n+ 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16\n+ 最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上\n+ BLOB和TEXT列可以被索引\n+ NULL被允许在索引的列中，这个值占每个键的0~1个字节\n+ 所有数字键值以高字节优先被存储以允许一个更高的索引压缩\n+ 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快\n+ 可以把数据文件和索引文件放在不同目录\n+ 每个字符列可以有不同的字符集\n+ 有VARCHAR的表可以固定或动态记录长度\n+ VARCHAR和CHAR列可以多达64KB\n\n与默认支持行级锁的InnoDB不同，MyISAM使用**表级锁**，表级锁也可细分为共享锁和排他锁。\n\nMyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中**写操作的优先级更高**。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。\n\n+ 调节MyISAM调度方式的一些方法\n    + 通过指定启动参数`low-priority-updates`，使MyISAM引擎默认给予读请求以优先的权利。\n    + 通过执行命令`SET LOW_PRIORITY_UPDATES=1`，使该连接发出的更新请求优先级降低。\n    + 通过指定INSERT、UPDATE、DELETE语句的`LOW_PRIORITY`属性，降低该语句的优先级。\n\nMySQL也提供了一种折中的办法来调节读写冲突，即给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。\n\n#### 存储引擎的比较与选择\n在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。\n\n| 特性 | InnoDB | MyISAM |\n| --- | :---: | :---: |\n| 事务安全 | 支持 | 无 |\n| 存储限制 | 64TB | 有 |\n| 空间使用 | 高 | 低 |\n| 内存使用 | 高 | 低 |\n| 插入数据的速度 | 低 | 高 |\n| 对外键的支持 | 支持 | 无 |\n\n**InnoDB**： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。\n\n**MyISAM**： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。\n\n## 参考链接\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)\n[MyISAM表锁](https://segmentfault.com/a/1190000019899944)\n[InnoDB行锁](https://segmentfault.com/a/1190000014133576)","source":"_posts/数据库基础-3.md","raw":"---\ntitle: 数据库基础-3\ndate: 2021-02-02 21:13:24\ntop_img: /img/cover/database.jpg\ncover: /img/cover/database.jpg\ntags: [Database, intern, 笔记]\n---\n\n## 数据库基础知识（3）\n### 当前读与快照读\n1. 当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；\n\n    使用当前读的操作主要包括：**显式加锁的读操作与插入/更新/删除等写操作**，如下所示：\n\n    ```sql\n    select * from table where ? lock in share mode;          -- 显式加锁的读操作\n    select * from table where ? for update;                  -- 显式加锁的读操作\n    insert into table values (…);                            -- 插入操作\n    update table set ? where ?;                              -- 更新操作\n    delete from table where ?;                               -- 删除操作\n    ```\n\n    > 注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。\n\n2. 快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；\n\n    InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；\n\n### MVCC 原理\nMVCC（多版本并发控制）的最大好处：**读不加任何锁**，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；\n\n**MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。**\n\n在REPEATABLE READ隔离级别下，MVCC的操作方式如下：\n+ **SELECT**\n    InnoDB会根据以下两个条件检查每行记录：\n    1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。\n    2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。\n    只有符合上述两个条件的记录，才能返回作为查询结果\n+ **INSERT**\n    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。\n+ **DELETE**\n    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。\n+ **UPDATE**\n    InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。\n\n保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。\n\n### MySQL存储引擎\n```sql\nshow engines;                                            -- 查看存储引擎\nshow variables like 'storage_engine';                    -- 查看数据库默认使用的引擎\ncreate table table_name()engine=engine_name;             -- 建表时设置引擎\n\nshow status like '%table_lock%'                          -- 查看表级锁争用情况\nshow status like 'innodb_row_lock'                       -- 查看InnoDB行级锁争用情况\n```\n\nMysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。\n\n#### InnoDB存储引擎\nInnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用\n\n> InnoDB主要特性\n+ 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合\n+ 为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上\n+ InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键\n\n+ InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高\n+ 共享锁和排他锁是InnoDB实现的两种标准的行锁\n+ InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)\n\n##### InnoDB 锁算法\nInnoDB 的三种锁算法：\n\n| 行锁算法 | 锁定内容 |\n| --- | --- |\n| Record Lock | 记录锁，锁定一个行记录 |\n| Gap Lock | 间隙锁，锁定一个区间 |\n| Next-key Lock | 记录锁+间隙锁，锁定行记录+区间 |\n\nInnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；\n\n不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：\n\n| 等值查询使用的索引类型 | 锁定内容 |\n| --- | --- |\n| 主键(聚簇索引) | 对聚簇索引记录 + 记录锁 |\n| 唯一索引 | 对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁 |\n| 普通索引 | 对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁 |\n| 不使用索引 | 对聚簇索引全表 + next-key锁 |\n\n行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。\n\n#### MyISAM存储引擎\nMyISAM 基于`ISAM存储引擎`，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有**较高的插入、查询速度，但不支持事务**。\n\n> MyISAM主要特性：\n+ 被大文件系统和操作系统支持\n+ 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成\n+ 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16\n+ 最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上\n+ BLOB和TEXT列可以被索引\n+ NULL被允许在索引的列中，这个值占每个键的0~1个字节\n+ 所有数字键值以高字节优先被存储以允许一个更高的索引压缩\n+ 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快\n+ 可以把数据文件和索引文件放在不同目录\n+ 每个字符列可以有不同的字符集\n+ 有VARCHAR的表可以固定或动态记录长度\n+ VARCHAR和CHAR列可以多达64KB\n\n与默认支持行级锁的InnoDB不同，MyISAM使用**表级锁**，表级锁也可细分为共享锁和排他锁。\n\nMyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中**写操作的优先级更高**。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。\n\n+ 调节MyISAM调度方式的一些方法\n    + 通过指定启动参数`low-priority-updates`，使MyISAM引擎默认给予读请求以优先的权利。\n    + 通过执行命令`SET LOW_PRIORITY_UPDATES=1`，使该连接发出的更新请求优先级降低。\n    + 通过指定INSERT、UPDATE、DELETE语句的`LOW_PRIORITY`属性，降低该语句的优先级。\n\nMySQL也提供了一种折中的办法来调节读写冲突，即给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。\n\n#### 存储引擎的比较与选择\n在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。\n\n| 特性 | InnoDB | MyISAM |\n| --- | :---: | :---: |\n| 事务安全 | 支持 | 无 |\n| 存储限制 | 64TB | 有 |\n| 空间使用 | 高 | 低 |\n| 内存使用 | 高 | 低 |\n| 插入数据的速度 | 低 | 高 |\n| 对外键的支持 | 支持 | 无 |\n\n**InnoDB**： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。\n\n**MyISAM**： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。\n\n## 参考链接\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)\n[MyISAM表锁](https://segmentfault.com/a/1190000019899944)\n[InnoDB行锁](https://segmentfault.com/a/1190000014133576)","slug":"数据库基础-3","published":1,"updated":"2021-03-29T08:37:36.752Z","_id":"ckko43nia0000n26w9yf5eza0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"数据库基础知识（3）\"><a href=\"#数据库基础知识（3）\" class=\"headerlink\" title=\"数据库基础知识（3）\"></a>数据库基础知识（3）</h2><h3 id=\"当前读与快照读\"><a href=\"#当前读与快照读\" class=\"headerlink\" title=\"当前读与快照读\"></a>当前读与快照读</h3><ol>\n<li><p>当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；</p>\n<p> 使用当前读的操作主要包括：<strong>显式加锁的读操作与插入/更新/删除等写操作</strong>，如下所示：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span>;          <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;                  <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> <span class=\"keyword\">values</span> (…);                            <span class=\"comment\">-- 插入操作</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">table</span> <span class=\"keyword\">set</span> ? <span class=\"keyword\">where</span> ?;                              <span class=\"comment\">-- 更新操作</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ?;                               <span class=\"comment\">-- 删除操作</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>\n</blockquote>\n</li>\n<li><p>快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；</p>\n<p> InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p>\n</li>\n</ol>\n<h3 id=\"MVCC-原理\"><a href=\"#MVCC-原理\" class=\"headerlink\" title=\"MVCC 原理\"></a>MVCC 原理</h3><p>MVCC（多版本并发控制）的最大好处：<strong>读不加任何锁</strong>，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；</p>\n<p><strong>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong></p>\n<p>在REPEATABLE READ隔离级别下，MVCC的操作方式如下：</p>\n<ul>\n<li><strong>SELECT</strong><br>  InnoDB会根据以下两个条件检查每行记录：<ol>\n<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>\n<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的记录，才能返回作为查询结果</li>\n</ol>\n</li>\n<li><strong>INSERT</strong><br>  InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>\n<li><strong>DELETE</strong><br>  InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>\n<li><strong>UPDATE</strong><br>  InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。</li>\n</ul>\n<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>\n<h3 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;                                            <span class=\"comment\">-- 查看存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'storage_engine'</span>;                    <span class=\"comment\">-- 查看数据库默认使用的引擎</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table_name()<span class=\"keyword\">engine</span>=engine_name;             <span class=\"comment\">-- 建表时设置引擎</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'%table_lock%'</span>                          <span class=\"comment\">-- 查看表级锁争用情况</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'innodb_row_lock'</span>                       <span class=\"comment\">-- 查看InnoDB行级锁争用情况</span></span><br></pre></td></tr></table></figure>\n<p>Mysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。</p>\n<h4 id=\"InnoDB存储引擎\"><a href=\"#InnoDB存储引擎\" class=\"headerlink\" title=\"InnoDB存储引擎\"></a>InnoDB存储引擎</h4><p>InnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用</p>\n<blockquote>\n<p>InnoDB主要特性</p>\n<ul>\n<li>为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>\n<li>为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</li>\n<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>\n</ul>\n</blockquote>\n<ul>\n<li>InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高</li>\n<li>共享锁和排他锁是InnoDB实现的两种标准的行锁</li>\n<li>InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)</li>\n</ul>\n<h5 id=\"InnoDB-锁算法\"><a href=\"#InnoDB-锁算法\" class=\"headerlink\" title=\"InnoDB 锁算法\"></a>InnoDB 锁算法</h5><p>InnoDB 的三种锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>行锁算法</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Record Lock</td>\n<td>记录锁，锁定一个行记录</td>\n</tr>\n<tr>\n<td>Gap Lock</td>\n<td>间隙锁，锁定一个区间</td>\n</tr>\n<tr>\n<td>Next-key Lock</td>\n<td>记录锁+间隙锁，锁定行记录+区间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；</p>\n<p>不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>等值查询使用的索引类型</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主键(聚簇索引)</td>\n<td>对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>普通索引</td>\n<td>对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>不使用索引</td>\n<td>对聚簇索引全表 + next-key锁</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。</p>\n<h4 id=\"MyISAM存储引擎\"><a href=\"#MyISAM存储引擎\" class=\"headerlink\" title=\"MyISAM存储引擎\"></a>MyISAM存储引擎</h4><p>MyISAM 基于<code>ISAM存储引擎</code>，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有<strong>较高的插入、查询速度，但不支持事务</strong>。</p>\n<blockquote>\n<p>MyISAM主要特性：</p>\n<ul>\n<li>被大文件系统和操作系统支持</li>\n<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成</li>\n<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>\n<li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li>\n<li>BLOB和TEXT列可以被索引</li>\n<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li>\n<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>\n<li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</li>\n<li>可以把数据文件和索引文件放在不同目录</li>\n<li>每个字符列可以有不同的字符集</li>\n<li>有VARCHAR的表可以固定或动态记录长度</li>\n<li>VARCHAR和CHAR列可以多达64KB</li>\n</ul>\n</blockquote>\n<p>与默认支持行级锁的InnoDB不同，MyISAM使用<strong>表级锁</strong>，表级锁也可细分为共享锁和排他锁。</p>\n<p>MyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中<strong>写操作的优先级更高</strong>。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。</p>\n<ul>\n<li>调节MyISAM调度方式的一些方法<ul>\n<li>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。</li>\n<li>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。</li>\n<li>通过指定INSERT、UPDATE、DELETE语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级。</li>\n</ul>\n</li>\n</ul>\n<p>MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p>\n<h4 id=\"存储引擎的比较与选择\"><a href=\"#存储引擎的比较与选择\" class=\"headerlink\" title=\"存储引擎的比较与选择\"></a>存储引擎的比较与选择</h4><p>在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th style=\"text-align:center\">InnoDB</th>\n<th style=\"text-align:center\">MyISAM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>事务安全</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td>存储限制</td>\n<td style=\"text-align:center\">64TB</td>\n<td style=\"text-align:center\">有</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>插入数据的速度</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n<tr>\n<td>对外键的支持</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>InnoDB</strong>： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>\n<p><strong>MyISAM</strong>： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a><br><a href=\"https://segmentfault.com/a/1190000019899944\" target=\"_blank\" rel=\"noopener\">MyISAM表锁</a><br><a href=\"https://segmentfault.com/a/1190000014133576\" target=\"_blank\" rel=\"noopener\">InnoDB行锁</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据库基础知识（3）\"><a href=\"#数据库基础知识（3）\" class=\"headerlink\" title=\"数据库基础知识（3）\"></a>数据库基础知识（3）</h2><h3 id=\"当前读与快照读\"><a href=\"#当前读与快照读\" class=\"headerlink\" title=\"当前读与快照读\"></a>当前读与快照读</h3><ol>\n<li><p>当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；</p>\n<p> 使用当前读的操作主要包括：<strong>显式加锁的读操作与插入/更新/删除等写操作</strong>，如下所示：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span>;          <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;                  <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> <span class=\"keyword\">values</span> (…);                            <span class=\"comment\">-- 插入操作</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">table</span> <span class=\"keyword\">set</span> ? <span class=\"keyword\">where</span> ?;                              <span class=\"comment\">-- 更新操作</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ?;                               <span class=\"comment\">-- 删除操作</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>\n</blockquote>\n</li>\n<li><p>快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；</p>\n<p> InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p>\n</li>\n</ol>\n<h3 id=\"MVCC-原理\"><a href=\"#MVCC-原理\" class=\"headerlink\" title=\"MVCC 原理\"></a>MVCC 原理</h3><p>MVCC（多版本并发控制）的最大好处：<strong>读不加任何锁</strong>，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；</p>\n<p><strong>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong></p>\n<p>在REPEATABLE READ隔离级别下，MVCC的操作方式如下：</p>\n<ul>\n<li><strong>SELECT</strong><br>  InnoDB会根据以下两个条件检查每行记录：<ol>\n<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>\n<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的记录，才能返回作为查询结果</li>\n</ol>\n</li>\n<li><strong>INSERT</strong><br>  InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>\n<li><strong>DELETE</strong><br>  InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>\n<li><strong>UPDATE</strong><br>  InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。</li>\n</ul>\n<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>\n<h3 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;                                            <span class=\"comment\">-- 查看存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'storage_engine'</span>;                    <span class=\"comment\">-- 查看数据库默认使用的引擎</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table_name()<span class=\"keyword\">engine</span>=engine_name;             <span class=\"comment\">-- 建表时设置引擎</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'%table_lock%'</span>                          <span class=\"comment\">-- 查看表级锁争用情况</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'innodb_row_lock'</span>                       <span class=\"comment\">-- 查看InnoDB行级锁争用情况</span></span><br></pre></td></tr></table></figure>\n<p>Mysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。</p>\n<h4 id=\"InnoDB存储引擎\"><a href=\"#InnoDB存储引擎\" class=\"headerlink\" title=\"InnoDB存储引擎\"></a>InnoDB存储引擎</h4><p>InnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用</p>\n<blockquote>\n<p>InnoDB主要特性</p>\n<ul>\n<li>为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>\n<li>为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</li>\n<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>\n</ul>\n</blockquote>\n<ul>\n<li>InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高</li>\n<li>共享锁和排他锁是InnoDB实现的两种标准的行锁</li>\n<li>InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)</li>\n</ul>\n<h5 id=\"InnoDB-锁算法\"><a href=\"#InnoDB-锁算法\" class=\"headerlink\" title=\"InnoDB 锁算法\"></a>InnoDB 锁算法</h5><p>InnoDB 的三种锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>行锁算法</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Record Lock</td>\n<td>记录锁，锁定一个行记录</td>\n</tr>\n<tr>\n<td>Gap Lock</td>\n<td>间隙锁，锁定一个区间</td>\n</tr>\n<tr>\n<td>Next-key Lock</td>\n<td>记录锁+间隙锁，锁定行记录+区间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；</p>\n<p>不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>等值查询使用的索引类型</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主键(聚簇索引)</td>\n<td>对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>普通索引</td>\n<td>对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>不使用索引</td>\n<td>对聚簇索引全表 + next-key锁</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。</p>\n<h4 id=\"MyISAM存储引擎\"><a href=\"#MyISAM存储引擎\" class=\"headerlink\" title=\"MyISAM存储引擎\"></a>MyISAM存储引擎</h4><p>MyISAM 基于<code>ISAM存储引擎</code>，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有<strong>较高的插入、查询速度，但不支持事务</strong>。</p>\n<blockquote>\n<p>MyISAM主要特性：</p>\n<ul>\n<li>被大文件系统和操作系统支持</li>\n<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成</li>\n<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>\n<li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li>\n<li>BLOB和TEXT列可以被索引</li>\n<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li>\n<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>\n<li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</li>\n<li>可以把数据文件和索引文件放在不同目录</li>\n<li>每个字符列可以有不同的字符集</li>\n<li>有VARCHAR的表可以固定或动态记录长度</li>\n<li>VARCHAR和CHAR列可以多达64KB</li>\n</ul>\n</blockquote>\n<p>与默认支持行级锁的InnoDB不同，MyISAM使用<strong>表级锁</strong>，表级锁也可细分为共享锁和排他锁。</p>\n<p>MyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中<strong>写操作的优先级更高</strong>。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。</p>\n<ul>\n<li>调节MyISAM调度方式的一些方法<ul>\n<li>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。</li>\n<li>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。</li>\n<li>通过指定INSERT、UPDATE、DELETE语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级。</li>\n</ul>\n</li>\n</ul>\n<p>MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p>\n<h4 id=\"存储引擎的比较与选择\"><a href=\"#存储引擎的比较与选择\" class=\"headerlink\" title=\"存储引擎的比较与选择\"></a>存储引擎的比较与选择</h4><p>在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th style=\"text-align:center\">InnoDB</th>\n<th style=\"text-align:center\">MyISAM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>事务安全</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td>存储限制</td>\n<td style=\"text-align:center\">64TB</td>\n<td style=\"text-align:center\">有</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>插入数据的速度</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n<tr>\n<td>对外键的支持</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>InnoDB</strong>： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>\n<p><strong>MyISAM</strong>： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a><br><a href=\"https://segmentfault.com/a/1190000019899944\" target=\"_blank\" rel=\"noopener\">MyISAM表锁</a><br><a href=\"https://segmentfault.com/a/1190000014133576\" target=\"_blank\" rel=\"noopener\">InnoDB行锁</a></p>\n"},{"title":"c++11/14-1","date":"2021-06-08T14:41:44.000Z","top_img":"/img/cover/c11.jpg","cover":"/img/cover/c11.jpg","_content":"\n## 变参模板\n变参模板（Variadic Templates），能够接受任意参数的模板\n```cpp\n// example 1\nvoid print() {}\n\ntemplate <typename T, typename... Types>\nvoid print(const T& firstArg, const Types&... args)\n{\n    cout << firstArg << \" \" << sizeof...(args) << endl; // 每次能处理的只有 firstArg\n    print(args...); // args...只能往下传递\n}\n\n// ----------------------------------------------------\n// ...就是一个所谓的 pack(包)\n// 用于 template parameters，就是 template parameters pack (模板参数包)\n// 用于 function parameter types，就是 function parameter types pack (函数参数类型包)\n// 用于 function parameters，就是 function parameters pack (函数参数包)\n\n// 加上...表示可以接受任意个参数，要注意其位置；\n// 一定要写一个处理最后情况的函数，这其实就像是递归，必须处理最简单的情况\n```\n\n实际使用1：\n```cpp\n#include <functional>\n\nclass CustomerHash {\npublic:\n    std::size_t operator()(const Customer& c) const {\n        return hash_val(c.fname, c.lname, c.no);\n    }\n};\n\n// 1. 最泛化的，设置 seed 后开始递归，不设置 seed 根本进不去 2.\ntemplate <typename... Types>\ninline size_t hash_val(const Types&... args) {\n    size_t seed = 0;\n    hash_val(seed, args...);\n    return seed;\n}\n\n// 2. 递归函数\ntemplate <typename T, typename... Types>\ninline void hash_val(size_t& seed, const T& val, const Types&... args) {\n    hash_combine(seed, val);\n    hash_val(seed, args...);\n}\n\n// 3. 递归函数的结尾\ntemplate <typename T>\ninline void hash_val(size_t& seed, const T& val) {\n    hash_combine(seed, val);\n}\n\n// 4. 实际计算 hash 的函数\ntemplate <typename T>\ninline void hash_val(size_t& seed, const T& val) {\n    seed ^= std::hash<T>(val) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n```\n\n实际使用2：\n```cpp\ntemplate <typename... Values> class tuple;  // 泛化\ntemplate <> class tuple<> {};       // 特化\n\ntemplate <typename Head, typename... Tail>\nclass tuple<Head, Tail...> : private tuple<Tail...>\n{\n    typedef tuple<Tail...> inherited;\npublic:\n    tuple() {};\n    tuple(Head v, Tail... vtail):m_head(v), inherited(vtail...) {};\n\n    typename Head::type head() { return m_head; }\n    inherited& tail() { return *this; }\nprotected:\n    Head m_head;\n};\n```\n\n## 模板表达式里的空间\n### nullptr 和 std::nullptr_t\n一个新的关键字，空指针\n```cpp\nvoid f(int);\nvoid f(void *);\nf(0);           // calls f(int)\nf(NULL);        // calls f(int)\nf(nullptr);     // calls f(void *)\n```\n\n### 自动类型推断 auto\n尽量只在类型过于复杂、书写太长，或者类型难以推断的地方\n```cpp\nauto i = 42; // i has type int\ndouble f();\nauto d = f(); // d has type double\n\nvector<string> v;\nauto pos = v.begin();       // pos has type vector<string>::iterator，类型太长，懒得写\nauto l = [](int x)->bool{   // l has type of a lambda，类型过于复杂\n    ...,\n};\n```\n\n### Uniform Initialization\n初始化可能在小括号、大括号和赋值操作符之间发生\n```c++\nint value[] {1,2,3};\t// initializer_list<T>\nvector<int> v {2,3,5,7,11,13,17};\t// \t容器中有可以接受initializer_list<T>的ctor\ncomplex<double> c{4.0, 3.0};\n\nRect r1 = { 3,7,20,25,&area, &print };\nRect r1(3,7,20,25);\nint ia[6] = { 27,210,12,47,109,83 };\n```\n\n#### Initializer Lists\n\nInitializer Lists的一些示例\n\n```c++\nint i;\t\t// i 的值不确定\nint j{};\t// j 被初始化为 0\nint* p;\t\t// p 的值不确定\nint* q{};\t// q 被初始化为 nullptr\n//\nint x1(5.3);\t// OK, x1==5\nint x2 = 5.3;\t// OK, x2==5\nint x3{5.3};\t// ERROR: narrowing\nint x4 = {5.3};\t// ERROR: narrowing\nchar c1{7};\t\t// OK: 这里没有narrowing\nchar c2{99999};\t// ERROR“ narrowing(99999不符合char的范围)\nstd::vector<int> v1{1,2,4,5}; // OK\nstd::vector<int> v2{1, 2.3, 4, 5.6};\t// ERROR: narrowing\n```\n\n模板类std::initializer_list<>\n\n```c++\n// 示例1\nvoid print(std::initializer_list<int> vals)\n{\n    for (auto p=vals.begin(); p!=vals.end(); p++) {\n        std::cout << *p << \"\\n\";\n    }\n}\nprint({12,3,5,7,11,13,17});\t// 传递a list of value给print()\n\n// 示例2\nclass P\n{\n  public:\n    P(int a, int b)\n    {\n        cout << \"p(int, int), a=\" << a << \", b=\" << b << endl;\n    }\n    P(initializer_list<int> initlist)\n    {\n        cout << \"P(initializer_list<int>), values= \";\n        for (auto i : initlist)\n            cout << i << ' ';\n       \tcout << endl;\n    }\n};\n\nP p(77,5);\t\t// P(int, int), a=77, b=5\nP q{77,5};\t\t// P(initializer_list<int>), values= 77 5 42\nP r{77,5,42};\t// P(initializer_list<int>), values= 77 5\nP s={77,5};\t\t// P(initializer_list<int>), values= 77 5\n// 如果没有initializer_list的ctor，q和s可以运行，但是r不行\n```\n\n### explicit\n\nexplicit for ctors，表示这个ctor必须被明确调用才行，不允许编译器做隐式转换。\n\n示例如下：\n\n```c++\nstruct Complex\n{\n    int real, image;\n    \n    explicit\n    Complex(int re, int im=0): real(re), image(im){}\n    \n    Complex operator+(const Complex& x){\n        return Complex((real + x.real), (image + x.image));\n    }\n}\n\nComplex c1(12, 5);\nComplex c2 = c1 + 5; // [Error] no match for 'operator+' (operand types are 'Complex' and 'int')\n// 如果ctor没有explicit关键字，那么编译器就会把5隐式转换为5+0i，然后进行运算；\n```\n\n### range-based for statement\n\n```c++\nfor ( decl : coll ) {\n    statement\n}\n```\n\n```c++\nfor (int i : { 2, 3, 5, 7, 9, 13, 17, 19}) {\n    cout << i << endl;\n}\n```\n\n```c++\nvector<double> vec;\n...\nfor ( auto elem : vec ) {\n    cout << elem << endl;\n}\n// 取引用，可以直接修改值\nfor (auto& elem : vec) {\n    elem *= 3;\n}\n```\n\n### =default, =delete\n\n如果自行定义了一个ctor，那么编译器就不会再给你一个default ctor；\n\n如果你强制加上 =default，就可以重新获得并使用 default ctor；\n\n```c++\nclass Zoo\n{\npublic:\n    Zoo(int i1, int i2): d1(i1), d2(i2) {}\n    Zoo(const Zoo&) =delete;\t\t\t\t// 拷贝构造\n    Zoo(Zoo&&) =default;\n    Zoo& operator=(const Zoo&) =default;\t// 拷贝赋值\n    Zoo& operator=(const Zoo&&) =delete;\n    virtual ~Zoo() {}\nprivate:\n    int d1, d2;\n}\n```\n\n  ### Alias Template (template typedef)\n\nAlias：化名，别名\n\n```c++\ntemplate <typename T>\nusing Vec = std::vector<T, MyAlloc<T>>;\nVec<int> coll;\n```\n\n等价于：\n\n```c++\nstd::vector<int, MyAlloc<int>> coll;\n```\n\ntypedef 没法指定类型参数\n\n```c++\ntypedef std::vector<int, MyAlloc<int>> Vec;\n```\n\n### Type Alias\n\n和 typedef 相似\n\n```c++\n// typedef void (*func)(int, int); 等价于下式\nusing func = void(*)(int, int);\n// func 表示函数指针\nvoid example(int, int) {}\nfunc fn = example;\n```\n\n### using关键字\n\n```c++\nusing namespace std;\t// 命名空间\nusing std::cout;\t\t// 声明 namespace members\n// type alias和alias template声明\nusing func = void(*)(int, int);\ntemplate<typename T>\nstruct Container {\n    using value_type = T;\n};\ntemplate <class CharT> using mystring=std::basic_string<CharT, std::char_traits<CharT>>;\n```\n\n### noexcept关键字\n\n```c++\nvoid foo() noexcept; <=> void foo() noexcept(true);\n\nvoid swap(Type& x, Type& y) npexcept(noexcept(x.swap(y)))\n{\n    x.swap(y);\n}\n```\n\n保证函数不会丢出异常；`noexcept(...)`中可以指定boolean表达式，表面在某种情况下不丢出异常；\n\n### override关键字\n\n作用于虚函数\n\n```c++\nstruct Base{\n    virtual void vfunc(float) {}\n};\nstruct Derived1: Base {\n    virtual void vfunc(int) {}\t// 本意是重写父类函数的，结果参数不对，编译器会认为是新的虚函数\n}\n```\n\n```c++\nstruct Derived2: Base {\n    virtual void vfunc(int) override {}\t\t// 报错，想重写还传这个参数...\n    virtual void vfunc(float) override {}\t// 重写成功，参数一致\n}\n```\n\n### final关键字\n\n用于类，则该类不能被继承；用于函数，则该函数不能被重写；\n\n```c++\nstruct Base1 final {};\nstruct Derived1 : Base1 {};\t\t// ERROR\n```\n\n```c++\nstruct Base2 {\n    virtual void f() final;\n}\n\nstruct Derived2 : Base2 {\n    void f();\t// ERROR\n}\n```\n\n### decltype\n\n使用decltype，可以让编译器找到一个expression的类型\n\n```c++\nmap<string, float> coll;\ndecltype(coll)::value_type elem;\n// 等价于c++ 11之前的写法\nmap<string, float>::value_type elem;\n```\n\n用法：\n\n1. 声明返回类型\n\n   ```c++\n   template <typename T1, typename T2>\n   decltype(x+y) add(T1 x, T2 y);\t// 编译出错：编译器先看到x,y，但是前面没出现过\n   =>\n       template <typename T1, typename T2>\n       auto add(T1 x, T2 y) -> decltype(x+y);\n   ```\n\n   \n\n2. 适用于metaprogramming\n\n   ```c++\n   template <typename T>\n   void test_decltype(T obj){}\t\t// T必须是容器\n   \n   typedef typename T::iterator iType;\n   => typedef typename decltype(obj)::iterator iType;\n   ```\n\n3. 传递 lambda 的类型\n\n   ```c++\n   auto cmp = [](const Person& p1, const Person& p2) { ... };\n   // 必须传递cmp给coll；否则coll会调用cmp的默认ctor，但cmp是lambda，没有默认构造函数，就会报错。所以必须这么传递\n   std::set<Person, decltype(cmp)> coll(cmp);\n   ```\n\n### Lambda\n\nlambda就是可以在语句或表达式中定义的函数，这个函数可以被作为参数或者局部变量；\n\nlambda是一个对象，功能上是一个函数；\n\n```c++\n[...](...) mutable throwSpec -> retType { ... }\n\n[]：里面放取用的外部变量，值or引用都可\n()：标识重载的()操作符的参数，mutable,throwSpec,retType都省略的话()也可以省略\nmutable：表示变量以value形式传入，且值可以修改，不加则传入的值只可读\nthrowSpec：指定函数抛出的异常，如 throw(int)\nretType：返回类型，没有则编译器自己推断\n{}：函数体\n```\n\n```c++\n// 示例\nauto I = []{\n    std::cout << \"hello lambda\" << std::endl;\n};\nI();\t// prints \"hello lambda\"\n```\n\n","source":"_posts/c-11-14-1.md","raw":"---\ntitle: c++11/14-1\ndate: 2021-06-08 22:41:44\ntop_img: /img/cover/c11.jpg\ncover: /img/cover/c11.jpg\ntags: [c++]\n---\n\n## 变参模板\n变参模板（Variadic Templates），能够接受任意参数的模板\n```cpp\n// example 1\nvoid print() {}\n\ntemplate <typename T, typename... Types>\nvoid print(const T& firstArg, const Types&... args)\n{\n    cout << firstArg << \" \" << sizeof...(args) << endl; // 每次能处理的只有 firstArg\n    print(args...); // args...只能往下传递\n}\n\n// ----------------------------------------------------\n// ...就是一个所谓的 pack(包)\n// 用于 template parameters，就是 template parameters pack (模板参数包)\n// 用于 function parameter types，就是 function parameter types pack (函数参数类型包)\n// 用于 function parameters，就是 function parameters pack (函数参数包)\n\n// 加上...表示可以接受任意个参数，要注意其位置；\n// 一定要写一个处理最后情况的函数，这其实就像是递归，必须处理最简单的情况\n```\n\n实际使用1：\n```cpp\n#include <functional>\n\nclass CustomerHash {\npublic:\n    std::size_t operator()(const Customer& c) const {\n        return hash_val(c.fname, c.lname, c.no);\n    }\n};\n\n// 1. 最泛化的，设置 seed 后开始递归，不设置 seed 根本进不去 2.\ntemplate <typename... Types>\ninline size_t hash_val(const Types&... args) {\n    size_t seed = 0;\n    hash_val(seed, args...);\n    return seed;\n}\n\n// 2. 递归函数\ntemplate <typename T, typename... Types>\ninline void hash_val(size_t& seed, const T& val, const Types&... args) {\n    hash_combine(seed, val);\n    hash_val(seed, args...);\n}\n\n// 3. 递归函数的结尾\ntemplate <typename T>\ninline void hash_val(size_t& seed, const T& val) {\n    hash_combine(seed, val);\n}\n\n// 4. 实际计算 hash 的函数\ntemplate <typename T>\ninline void hash_val(size_t& seed, const T& val) {\n    seed ^= std::hash<T>(val) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n}\n```\n\n实际使用2：\n```cpp\ntemplate <typename... Values> class tuple;  // 泛化\ntemplate <> class tuple<> {};       // 特化\n\ntemplate <typename Head, typename... Tail>\nclass tuple<Head, Tail...> : private tuple<Tail...>\n{\n    typedef tuple<Tail...> inherited;\npublic:\n    tuple() {};\n    tuple(Head v, Tail... vtail):m_head(v), inherited(vtail...) {};\n\n    typename Head::type head() { return m_head; }\n    inherited& tail() { return *this; }\nprotected:\n    Head m_head;\n};\n```\n\n## 模板表达式里的空间\n### nullptr 和 std::nullptr_t\n一个新的关键字，空指针\n```cpp\nvoid f(int);\nvoid f(void *);\nf(0);           // calls f(int)\nf(NULL);        // calls f(int)\nf(nullptr);     // calls f(void *)\n```\n\n### 自动类型推断 auto\n尽量只在类型过于复杂、书写太长，或者类型难以推断的地方\n```cpp\nauto i = 42; // i has type int\ndouble f();\nauto d = f(); // d has type double\n\nvector<string> v;\nauto pos = v.begin();       // pos has type vector<string>::iterator，类型太长，懒得写\nauto l = [](int x)->bool{   // l has type of a lambda，类型过于复杂\n    ...,\n};\n```\n\n### Uniform Initialization\n初始化可能在小括号、大括号和赋值操作符之间发生\n```c++\nint value[] {1,2,3};\t// initializer_list<T>\nvector<int> v {2,3,5,7,11,13,17};\t// \t容器中有可以接受initializer_list<T>的ctor\ncomplex<double> c{4.0, 3.0};\n\nRect r1 = { 3,7,20,25,&area, &print };\nRect r1(3,7,20,25);\nint ia[6] = { 27,210,12,47,109,83 };\n```\n\n#### Initializer Lists\n\nInitializer Lists的一些示例\n\n```c++\nint i;\t\t// i 的值不确定\nint j{};\t// j 被初始化为 0\nint* p;\t\t// p 的值不确定\nint* q{};\t// q 被初始化为 nullptr\n//\nint x1(5.3);\t// OK, x1==5\nint x2 = 5.3;\t// OK, x2==5\nint x3{5.3};\t// ERROR: narrowing\nint x4 = {5.3};\t// ERROR: narrowing\nchar c1{7};\t\t// OK: 这里没有narrowing\nchar c2{99999};\t// ERROR“ narrowing(99999不符合char的范围)\nstd::vector<int> v1{1,2,4,5}; // OK\nstd::vector<int> v2{1, 2.3, 4, 5.6};\t// ERROR: narrowing\n```\n\n模板类std::initializer_list<>\n\n```c++\n// 示例1\nvoid print(std::initializer_list<int> vals)\n{\n    for (auto p=vals.begin(); p!=vals.end(); p++) {\n        std::cout << *p << \"\\n\";\n    }\n}\nprint({12,3,5,7,11,13,17});\t// 传递a list of value给print()\n\n// 示例2\nclass P\n{\n  public:\n    P(int a, int b)\n    {\n        cout << \"p(int, int), a=\" << a << \", b=\" << b << endl;\n    }\n    P(initializer_list<int> initlist)\n    {\n        cout << \"P(initializer_list<int>), values= \";\n        for (auto i : initlist)\n            cout << i << ' ';\n       \tcout << endl;\n    }\n};\n\nP p(77,5);\t\t// P(int, int), a=77, b=5\nP q{77,5};\t\t// P(initializer_list<int>), values= 77 5 42\nP r{77,5,42};\t// P(initializer_list<int>), values= 77 5\nP s={77,5};\t\t// P(initializer_list<int>), values= 77 5\n// 如果没有initializer_list的ctor，q和s可以运行，但是r不行\n```\n\n### explicit\n\nexplicit for ctors，表示这个ctor必须被明确调用才行，不允许编译器做隐式转换。\n\n示例如下：\n\n```c++\nstruct Complex\n{\n    int real, image;\n    \n    explicit\n    Complex(int re, int im=0): real(re), image(im){}\n    \n    Complex operator+(const Complex& x){\n        return Complex((real + x.real), (image + x.image));\n    }\n}\n\nComplex c1(12, 5);\nComplex c2 = c1 + 5; // [Error] no match for 'operator+' (operand types are 'Complex' and 'int')\n// 如果ctor没有explicit关键字，那么编译器就会把5隐式转换为5+0i，然后进行运算；\n```\n\n### range-based for statement\n\n```c++\nfor ( decl : coll ) {\n    statement\n}\n```\n\n```c++\nfor (int i : { 2, 3, 5, 7, 9, 13, 17, 19}) {\n    cout << i << endl;\n}\n```\n\n```c++\nvector<double> vec;\n...\nfor ( auto elem : vec ) {\n    cout << elem << endl;\n}\n// 取引用，可以直接修改值\nfor (auto& elem : vec) {\n    elem *= 3;\n}\n```\n\n### =default, =delete\n\n如果自行定义了一个ctor，那么编译器就不会再给你一个default ctor；\n\n如果你强制加上 =default，就可以重新获得并使用 default ctor；\n\n```c++\nclass Zoo\n{\npublic:\n    Zoo(int i1, int i2): d1(i1), d2(i2) {}\n    Zoo(const Zoo&) =delete;\t\t\t\t// 拷贝构造\n    Zoo(Zoo&&) =default;\n    Zoo& operator=(const Zoo&) =default;\t// 拷贝赋值\n    Zoo& operator=(const Zoo&&) =delete;\n    virtual ~Zoo() {}\nprivate:\n    int d1, d2;\n}\n```\n\n  ### Alias Template (template typedef)\n\nAlias：化名，别名\n\n```c++\ntemplate <typename T>\nusing Vec = std::vector<T, MyAlloc<T>>;\nVec<int> coll;\n```\n\n等价于：\n\n```c++\nstd::vector<int, MyAlloc<int>> coll;\n```\n\ntypedef 没法指定类型参数\n\n```c++\ntypedef std::vector<int, MyAlloc<int>> Vec;\n```\n\n### Type Alias\n\n和 typedef 相似\n\n```c++\n// typedef void (*func)(int, int); 等价于下式\nusing func = void(*)(int, int);\n// func 表示函数指针\nvoid example(int, int) {}\nfunc fn = example;\n```\n\n### using关键字\n\n```c++\nusing namespace std;\t// 命名空间\nusing std::cout;\t\t// 声明 namespace members\n// type alias和alias template声明\nusing func = void(*)(int, int);\ntemplate<typename T>\nstruct Container {\n    using value_type = T;\n};\ntemplate <class CharT> using mystring=std::basic_string<CharT, std::char_traits<CharT>>;\n```\n\n### noexcept关键字\n\n```c++\nvoid foo() noexcept; <=> void foo() noexcept(true);\n\nvoid swap(Type& x, Type& y) npexcept(noexcept(x.swap(y)))\n{\n    x.swap(y);\n}\n```\n\n保证函数不会丢出异常；`noexcept(...)`中可以指定boolean表达式，表面在某种情况下不丢出异常；\n\n### override关键字\n\n作用于虚函数\n\n```c++\nstruct Base{\n    virtual void vfunc(float) {}\n};\nstruct Derived1: Base {\n    virtual void vfunc(int) {}\t// 本意是重写父类函数的，结果参数不对，编译器会认为是新的虚函数\n}\n```\n\n```c++\nstruct Derived2: Base {\n    virtual void vfunc(int) override {}\t\t// 报错，想重写还传这个参数...\n    virtual void vfunc(float) override {}\t// 重写成功，参数一致\n}\n```\n\n### final关键字\n\n用于类，则该类不能被继承；用于函数，则该函数不能被重写；\n\n```c++\nstruct Base1 final {};\nstruct Derived1 : Base1 {};\t\t// ERROR\n```\n\n```c++\nstruct Base2 {\n    virtual void f() final;\n}\n\nstruct Derived2 : Base2 {\n    void f();\t// ERROR\n}\n```\n\n### decltype\n\n使用decltype，可以让编译器找到一个expression的类型\n\n```c++\nmap<string, float> coll;\ndecltype(coll)::value_type elem;\n// 等价于c++ 11之前的写法\nmap<string, float>::value_type elem;\n```\n\n用法：\n\n1. 声明返回类型\n\n   ```c++\n   template <typename T1, typename T2>\n   decltype(x+y) add(T1 x, T2 y);\t// 编译出错：编译器先看到x,y，但是前面没出现过\n   =>\n       template <typename T1, typename T2>\n       auto add(T1 x, T2 y) -> decltype(x+y);\n   ```\n\n   \n\n2. 适用于metaprogramming\n\n   ```c++\n   template <typename T>\n   void test_decltype(T obj){}\t\t// T必须是容器\n   \n   typedef typename T::iterator iType;\n   => typedef typename decltype(obj)::iterator iType;\n   ```\n\n3. 传递 lambda 的类型\n\n   ```c++\n   auto cmp = [](const Person& p1, const Person& p2) { ... };\n   // 必须传递cmp给coll；否则coll会调用cmp的默认ctor，但cmp是lambda，没有默认构造函数，就会报错。所以必须这么传递\n   std::set<Person, decltype(cmp)> coll(cmp);\n   ```\n\n### Lambda\n\nlambda就是可以在语句或表达式中定义的函数，这个函数可以被作为参数或者局部变量；\n\nlambda是一个对象，功能上是一个函数；\n\n```c++\n[...](...) mutable throwSpec -> retType { ... }\n\n[]：里面放取用的外部变量，值or引用都可\n()：标识重载的()操作符的参数，mutable,throwSpec,retType都省略的话()也可以省略\nmutable：表示变量以value形式传入，且值可以修改，不加则传入的值只可读\nthrowSpec：指定函数抛出的异常，如 throw(int)\nretType：返回类型，没有则编译器自己推断\n{}：函数体\n```\n\n```c++\n// 示例\nauto I = []{\n    std::cout << \"hello lambda\" << std::endl;\n};\nI();\t// prints \"hello lambda\"\n```\n\n","slug":"c-11-14-1","published":1,"updated":"2022-03-25T12:22:17.115Z","_id":"ckpt846kw0000lktp12jydz58","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"变参模板\"><a href=\"#变参模板\" class=\"headerlink\" title=\"变参模板\"></a>变参模板</h2><p>变参模板（Variadic Templates），能够接受任意参数的模板<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; firstArg, <span class=\"keyword\">const</span> Types&amp;... args)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; firstArg &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>...(args) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 每次能处理的只有 firstArg</span></span><br><span class=\"line\">    print(args...); <span class=\"comment\">// args...只能往下传递</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// ...就是一个所谓的 pack(包)</span></span><br><span class=\"line\"><span class=\"comment\">// 用于 template parameters，就是 template parameters pack (模板参数包)</span></span><br><span class=\"line\"><span class=\"comment\">// 用于 function parameter types，就是 function parameter types pack (函数参数类型包)</span></span><br><span class=\"line\"><span class=\"comment\">// 用于 function parameters，就是 function parameters pack (函数参数包)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加上...表示可以接受任意个参数，要注意其位置；</span></span><br><span class=\"line\"><span class=\"comment\">// 一定要写一个处理最后情况的函数，这其实就像是递归，必须处理最简单的情况</span></span><br></pre></td></tr></table></figure></p>\n<p>实际使用1：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerHash</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> Customer&amp; c)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hash_val(c.fname, c.lname, c.no);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 最泛化的，设置 seed 后开始递归，不设置 seed 根本进不去 2.</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hash_val(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 递归函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">size_t</span>&amp; seed, <span class=\"keyword\">const</span> T&amp; val, <span class=\"keyword\">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    hash_combine(seed, val);</span><br><span class=\"line\">    hash_val(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 递归函数的结尾</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">size_t</span>&amp; seed, <span class=\"keyword\">const</span> T&amp; val)</span> </span>&#123;</span><br><span class=\"line\">    hash_combine(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 实际计算 hash 的函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">size_t</span>&amp; seed, <span class=\"keyword\">const</span> T&amp; val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= <span class=\"built_in\">std</span>::hash&lt;T&gt;(val) + <span class=\"number\">0x9e3779b9</span> + (seed&lt;&lt;<span class=\"number\">6</span>) + (seed&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实际使用2：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Values&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>;</span>  <span class=\"comment\">// 泛化</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>&lt;&gt; &#123;</span>&#125;;       <span class=\"comment\">// 特化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Head, <span class=\"keyword\">typename</span>... Tail&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>&lt;Head, Tail...&gt; :</span> <span class=\"keyword\">private</span> tuple&lt;Tail...&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    tuple() &#123;&#125;;</span><br><span class=\"line\">    tuple(Head v, Tail... vtail):m_head(v), inherited(vtail...) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typename</span> Head::type <span class=\"title\">head</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_head; &#125;</span><br><span class=\"line\">    <span class=\"function\">inherited&amp; <span class=\"title\">tail</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    Head m_head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模板表达式里的空间\"><a href=\"#模板表达式里的空间\" class=\"headerlink\" title=\"模板表达式里的空间\"></a>模板表达式里的空间</h2><h3 id=\"nullptr-和-std-nullptr-t\"><a href=\"#nullptr-和-std-nullptr-t\" class=\"headerlink\" title=\"nullptr 和 std::nullptr_t\"></a>nullptr 和 std::nullptr_t</h3><p>一个新的关键字，空指针<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">void</span> *)</span></span>;</span><br><span class=\"line\">f(<span class=\"number\">0</span>);           <span class=\"comment\">// calls f(int)</span></span><br><span class=\"line\">f(<span class=\"literal\">NULL</span>);        <span class=\"comment\">// calls f(int)</span></span><br><span class=\"line\">f(<span class=\"literal\">nullptr</span>);     <span class=\"comment\">// calls f(void *)</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"自动类型推断-auto\"><a href=\"#自动类型推断-auto\" class=\"headerlink\" title=\"自动类型推断 auto\"></a>自动类型推断 auto</h3><p>尽量只在类型过于复杂、书写太长，或者类型难以推断的地方<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> i = <span class=\"number\">42</span>; <span class=\"comment\">// i has type int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> d = f(); <span class=\"comment\">// d has type double</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> pos = v.begin();       <span class=\"comment\">// pos has type vector&lt;string&gt;::iterator，类型太长，懒得写</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> l = [](<span class=\"keyword\">int</span> x)-&gt;<span class=\"keyword\">bool</span>&#123;   <span class=\"comment\">// l has type of a lambda，类型过于复杂</span></span><br><span class=\"line\">    ...,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Uniform-Initialization\"><a href=\"#Uniform-Initialization\" class=\"headerlink\" title=\"Uniform Initialization\"></a>Uniform Initialization</h3><p>初始化可能在小括号、大括号和赋值操作符之间发生<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> value[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;\t<span class=\"comment\">// initializer_list&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>&#125;;\t<span class=\"comment\">// \t容器中有可以接受initializer_list&lt;T&gt;的ctor</span></span><br><span class=\"line\"><span class=\"built_in\">complex</span>&lt;<span class=\"keyword\">double</span>&gt; c&#123;<span class=\"number\">4.0</span>, <span class=\"number\">3.0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Rect r1 = &#123; <span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">20</span>,<span class=\"number\">25</span>,&amp;area, &amp;<span class=\"built_in\">print</span> &#125;;</span><br><span class=\"line\"><span class=\"function\">Rect <span class=\"title\">r1</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">20</span>,<span class=\"number\">25</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ia[<span class=\"number\">6</span>] = &#123; <span class=\"number\">27</span>,<span class=\"number\">210</span>,<span class=\"number\">12</span>,<span class=\"number\">47</span>,<span class=\"number\">109</span>,<span class=\"number\">83</span> &#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Initializer-Lists\"><a href=\"#Initializer-Lists\" class=\"headerlink\" title=\"Initializer Lists\"></a>Initializer Lists</h4><p>Initializer Lists的一些示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i;\t\t<span class=\"comment\">// i 的值不确定</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j&#123;&#125;;\t<span class=\"comment\">// j 被初始化为 0</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p;\t\t<span class=\"comment\">// p 的值不确定</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* q&#123;&#125;;\t<span class=\"comment\">// q 被初始化为 nullptr</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x1</span><span class=\"params\">(<span class=\"number\">5.3</span>)</span></span>;\t<span class=\"comment\">// OK, x1==5</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x2 = <span class=\"number\">5.3</span>;\t<span class=\"comment\">// OK, x2==5</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x3&#123;<span class=\"number\">5.3</span>&#125;;\t<span class=\"comment\">// ERROR: narrowing</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x4 = &#123;<span class=\"number\">5.3</span>&#125;;\t<span class=\"comment\">// ERROR: narrowing</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c1&#123;<span class=\"number\">7</span>&#125;;\t\t<span class=\"comment\">// OK: 这里没有narrowing</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c2&#123;<span class=\"number\">99999</span>&#125;;\t<span class=\"comment\">// ERROR“ narrowing(99999不符合char的范围)</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v2&#123;<span class=\"number\">1</span>, <span class=\"number\">2.3</span>, <span class=\"number\">4</span>, <span class=\"number\">5.6</span>&#125;;\t<span class=\"comment\">// ERROR: narrowing</span></span><br></pre></td></tr></table></figure>\n<p>模板类std::initializer_list&lt;&gt;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt; vals)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> p=vals.<span class=\"built_in\">begin</span>(); p!=vals.<span class=\"built_in\">end</span>(); p++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(&#123;<span class=\"number\">12</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>&#125;);\t<span class=\"comment\">// 传递a list of value给print()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例2</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">P</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    P(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"p(int, int), a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\", b=\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    P(<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt; initlist)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"P(initializer_list&lt;int&gt;), values= \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : initlist)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">       \t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">P <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">77</span>,<span class=\"number\">5</span>)</span></span>;\t\t<span class=\"comment\">// P(int, int), a=77, b=5</span></span><br><span class=\"line\">P q&#123;<span class=\"number\">77</span>,<span class=\"number\">5</span>&#125;;\t\t<span class=\"comment\">// P(initializer_list&lt;int&gt;), values= 77 5 42</span></span><br><span class=\"line\">P r&#123;<span class=\"number\">77</span>,<span class=\"number\">5</span>,<span class=\"number\">42</span>&#125;;\t<span class=\"comment\">// P(initializer_list&lt;int&gt;), values= 77 5</span></span><br><span class=\"line\">P s=&#123;<span class=\"number\">77</span>,<span class=\"number\">5</span>&#125;;\t\t<span class=\"comment\">// P(initializer_list&lt;int&gt;), values= 77 5</span></span><br><span class=\"line\"><span class=\"comment\">// 如果没有initializer_list的ctor，q和s可以运行，但是r不行</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"explicit\"><a href=\"#explicit\" class=\"headerlink\" title=\"explicit\"></a>explicit</h3><p>explicit for ctors，表示这个ctor必须被明确调用才行，不允许编译器做隐式转换。</p>\n<p>示例如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Complex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> real, <span class=\"built_in\">image</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">explicit</span></span><br><span class=\"line\">    Complex(<span class=\"keyword\">int</span> re, <span class=\"keyword\">int</span> im=<span class=\"number\">0</span>): real(re), <span class=\"built_in\">image</span>(im)&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Complex <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Complex&amp; x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Complex((real + x.real), (<span class=\"built_in\">image</span> + x.<span class=\"built_in\">image</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Complex <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">12</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">Complex c2 = c1 + <span class=\"number\">5</span>; <span class=\"comment\">// [Error] no match for 'operator+' (operand types are 'Complex' and 'int')</span></span><br><span class=\"line\"><span class=\"comment\">// 如果ctor没有explicit关键字，那么编译器就会把5隐式转换为5+0i，然后进行运算；</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"range-based-for-statement\"><a href=\"#range-based-for-statement\" class=\"headerlink\" title=\"range-based for statement\"></a>range-based for statement</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> ( decl : coll ) &#123;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : &#123; <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; vec;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> elem : vec ) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; elem &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 取引用，可以直接修改值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; elem : vec) &#123;</span><br><span class=\"line\">    elem *= <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"default-delete\"><a href=\"#default-delete\" class=\"headerlink\" title=\"=default, =delete\"></a>=default, =delete</h3><p>如果自行定义了一个ctor，那么编译器就不会再给你一个default ctor；</p>\n<p>如果你强制加上 =default，就可以重新获得并使用 default ctor；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zoo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Zoo(<span class=\"keyword\">int</span> i1, <span class=\"keyword\">int</span> i2): d1(i1), d2(i2) &#123;&#125;</span><br><span class=\"line\">    Zoo(<span class=\"keyword\">const</span> Zoo&amp;) =<span class=\"keyword\">delete</span>;\t\t\t\t<span class=\"comment\">// 拷贝构造</span></span><br><span class=\"line\">    Zoo(Zoo&amp;&amp;) =<span class=\"keyword\">default</span>;</span><br><span class=\"line\">    Zoo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Zoo&amp;) =<span class=\"keyword\">default</span>;\t<span class=\"comment\">// 拷贝赋值</span></span><br><span class=\"line\">    Zoo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Zoo&amp;&amp;) =<span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Zoo() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d1, d2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Alias-Template-template-typedef\"><a href=\"#Alias-Template-template-typedef\" class=\"headerlink\" title=\"Alias Template (template typedef)\"></a>Alias Template (template typedef)</h3><p>Alias：化名，别名</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Vec = <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class=\"line\">Vec&lt;<span class=\"keyword\">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>, MyAlloc&lt;<span class=\"keyword\">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>\n<p>typedef 没法指定类型参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>, MyAlloc&lt;<span class=\"keyword\">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Type-Alias\"><a href=\"#Type-Alias\" class=\"headerlink\" title=\"Type Alias\"></a>Type Alias</h3><p>和 typedef 相似</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// typedef void (*func)(int, int); 等价于下式</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> func = <span class=\"keyword\">void</span>(*)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\"><span class=\"comment\">// func 表示函数指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">example</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\">func fn = example;</span><br></pre></td></tr></table></figure>\n<h3 id=\"using关键字\"><a href=\"#using关键字\" class=\"headerlink\" title=\"using关键字\"></a>using关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;\t<span class=\"comment\">// 命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;\t\t<span class=\"comment\">// 声明 namespace members</span></span><br><span class=\"line\"><span class=\"comment\">// type alias和alias template声明</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> func = <span class=\"keyword\">void</span>(*)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Container</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> value_type = T;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CharT</span>&gt; <span class=\"title\">using</span> <span class=\"title\">mystring</span>=<span class=\"title\">std</span>:</span>:basic_string&lt;CharT, <span class=\"built_in\">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"noexcept关键字\"><a href=\"#noexcept关键字\" class=\"headerlink\" title=\"noexcept关键字\"></a>noexcept关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span></span>; &lt;=&gt; <span class=\"keyword\">void</span> foo() <span class=\"keyword\">noexcept</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Type&amp; x, Type&amp; y)</span> <span class=\"title\">npexcept</span><span class=\"params\">(<span class=\"keyword\">noexcept</span>(x.swap(y)))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    x.swap(y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保证函数不会丢出异常；<code>noexcept(...)</code>中可以指定boolean表达式，表面在某种情况下不丢出异常；</p>\n<h3 id=\"override关键字\"><a href=\"#override关键字\" class=\"headerlink\" title=\"override关键字\"></a>override关键字</h3><p>作用于虚函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived1</span>:</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> </span>&#123;&#125;\t<span class=\"comment\">// 本意是重写父类函数的，结果参数不对，编译器会认为是新的虚函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived2</span>:</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">override</span> </span>&#123;&#125;\t\t<span class=\"comment\">// 报错，想重写还传这个参数...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> <span class=\"keyword\">override</span> </span>&#123;&#125;\t<span class=\"comment\">// 重写成功，参数一致</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"final关键字\"><a href=\"#final关键字\" class=\"headerlink\" title=\"final关键字\"></a>final关键字</h3><p>用于类，则该类不能被继承；用于函数，则该函数不能被重写；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base1</span> <span class=\"title\">final</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived1</span> :</span> Base1 &#123;&#125;;\t\t<span class=\"comment\">// ERROR</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base2</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"keyword\">final</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived2</span> :</span> Base2 &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;\t<span class=\"comment\">// ERROR</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"decltype\"><a href=\"#decltype\" class=\"headerlink\" title=\"decltype\"></a>decltype</h3><p>使用decltype，可以让编译器找到一个expression的类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">float</span>&gt; coll;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(coll)::value_type elem;</span><br><span class=\"line\"><span class=\"comment\">// 等价于c++ 11之前的写法</span></span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">float</span>&gt;::value_type elem;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ol>\n<li><p>声明返回类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(x+y) add(T1 x, T2 y);\t<span class=\"comment\">// 编译出错：编译器先看到x,y，但是前面没出现过</span></span><br><span class=\"line\">=&gt;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> add(T1 x, T2 y) -&gt; <span class=\"keyword\">decltype</span>(x+y);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>适用于metaprogramming</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_decltype</span><span class=\"params\">(T obj)</span></span>&#123;&#125;\t\t<span class=\"comment\">// T必须是容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> T::iterator iType;</span><br><span class=\"line\">=&gt; <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> <span class=\"keyword\">decltype</span>(obj)::iterator iType;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传递 lambda 的类型</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> cmp = [](<span class=\"keyword\">const</span> Person&amp; p1, <span class=\"keyword\">const</span> Person&amp; p2) &#123; ... &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 必须传递cmp给coll；否则coll会调用cmp的默认ctor，但cmp是lambda，没有默认构造函数，就会报错。所以必须这么传递</span></span><br><span class=\"line\">std::set&lt;Person, decltype(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h3><p>lambda就是可以在语句或表达式中定义的函数，这个函数可以被作为参数或者局部变量；</p>\n<p>lambda是一个对象，功能上是一个函数；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...](...) <span class=\"keyword\">mutable</span> throwSpec -&gt; retType &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[]：里面放取用的外部变量，值<span class=\"keyword\">or</span>引用都可</span><br><span class=\"line\">()：标识重载的()操作符的参数，<span class=\"keyword\">mutable</span>,throwSpec,retType都省略的话()也可以省略</span><br><span class=\"line\"><span class=\"keyword\">mutable</span>：表示变量以value形式传入，且值可以修改，不加则传入的值只可读</span><br><span class=\"line\">throwSpec：指定函数抛出的异常，如 <span class=\"keyword\">throw</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">retType：返回类型，没有则编译器自己推断</span><br><span class=\"line\">&#123;&#125;：函数体</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> I = []&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello lambda\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">I();\t<span class=\"comment\">// prints \"hello lambda\"</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"变参模板\"><a href=\"#变参模板\" class=\"headerlink\" title=\"变参模板\"></a>变参模板</h2><p>变参模板（Variadic Templates），能够接受任意参数的模板<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; firstArg, <span class=\"keyword\">const</span> Types&amp;... args)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; firstArg &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; <span class=\"keyword\">sizeof</span>...(args) &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 每次能处理的只有 firstArg</span></span><br><span class=\"line\">    print(args...); <span class=\"comment\">// args...只能往下传递</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ----------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// ...就是一个所谓的 pack(包)</span></span><br><span class=\"line\"><span class=\"comment\">// 用于 template parameters，就是 template parameters pack (模板参数包)</span></span><br><span class=\"line\"><span class=\"comment\">// 用于 function parameter types，就是 function parameter types pack (函数参数类型包)</span></span><br><span class=\"line\"><span class=\"comment\">// 用于 function parameters，就是 function parameters pack (函数参数包)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加上...表示可以接受任意个参数，要注意其位置；</span></span><br><span class=\"line\"><span class=\"comment\">// 一定要写一个处理最后情况的函数，这其实就像是递归，必须处理最简单的情况</span></span><br></pre></td></tr></table></figure></p>\n<p>实际使用1：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomerHash</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">const</span> Customer&amp; c)</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hash_val(c.fname, c.lname, c.no);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 最泛化的，设置 seed 后开始递归，不设置 seed 根本进不去 2.</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    hash_val(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 递归函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">size_t</span>&amp; seed, <span class=\"keyword\">const</span> T&amp; val, <span class=\"keyword\">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    hash_combine(seed, val);</span><br><span class=\"line\">    hash_val(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 递归函数的结尾</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">size_t</span>&amp; seed, <span class=\"keyword\">const</span> T&amp; val)</span> </span>&#123;</span><br><span class=\"line\">    hash_combine(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 实际计算 hash 的函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"keyword\">size_t</span>&amp; seed, <span class=\"keyword\">const</span> T&amp; val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= <span class=\"built_in\">std</span>::hash&lt;T&gt;(val) + <span class=\"number\">0x9e3779b9</span> + (seed&lt;&lt;<span class=\"number\">6</span>) + (seed&gt;&gt;<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实际使用2：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Values&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>;</span>  <span class=\"comment\">// 泛化</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>&lt;&gt; &#123;</span>&#125;;       <span class=\"comment\">// 特化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Head, <span class=\"keyword\">typename</span>... Tail&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>&lt;Head, Tail...&gt; :</span> <span class=\"keyword\">private</span> tuple&lt;Tail...&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> tuple&lt;Tail...&gt; inherited;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    tuple() &#123;&#125;;</span><br><span class=\"line\">    tuple(Head v, Tail... vtail):m_head(v), inherited(vtail...) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">typename</span> Head::type <span class=\"title\">head</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_head; &#125;</span><br><span class=\"line\">    <span class=\"function\">inherited&amp; <span class=\"title\">tail</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    Head m_head;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模板表达式里的空间\"><a href=\"#模板表达式里的空间\" class=\"headerlink\" title=\"模板表达式里的空间\"></a>模板表达式里的空间</h2><h3 id=\"nullptr-和-std-nullptr-t\"><a href=\"#nullptr-和-std-nullptr-t\" class=\"headerlink\" title=\"nullptr 和 std::nullptr_t\"></a>nullptr 和 std::nullptr_t</h3><p>一个新的关键字，空指针<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">void</span> *)</span></span>;</span><br><span class=\"line\">f(<span class=\"number\">0</span>);           <span class=\"comment\">// calls f(int)</span></span><br><span class=\"line\">f(<span class=\"literal\">NULL</span>);        <span class=\"comment\">// calls f(int)</span></span><br><span class=\"line\">f(<span class=\"literal\">nullptr</span>);     <span class=\"comment\">// calls f(void *)</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"自动类型推断-auto\"><a href=\"#自动类型推断-auto\" class=\"headerlink\" title=\"自动类型推断 auto\"></a>自动类型推断 auto</h3><p>尽量只在类型过于复杂、书写太长，或者类型难以推断的地方<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> i = <span class=\"number\">42</span>; <span class=\"comment\">// i has type int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> d = f(); <span class=\"comment\">// d has type double</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> pos = v.begin();       <span class=\"comment\">// pos has type vector&lt;string&gt;::iterator，类型太长，懒得写</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> l = [](<span class=\"keyword\">int</span> x)-&gt;<span class=\"keyword\">bool</span>&#123;   <span class=\"comment\">// l has type of a lambda，类型过于复杂</span></span><br><span class=\"line\">    ...,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Uniform-Initialization\"><a href=\"#Uniform-Initialization\" class=\"headerlink\" title=\"Uniform Initialization\"></a>Uniform Initialization</h3><p>初始化可能在小括号、大括号和赋值操作符之间发生<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> value[] &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;\t<span class=\"comment\">// initializer_list&lt;T&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>&#125;;\t<span class=\"comment\">// \t容器中有可以接受initializer_list&lt;T&gt;的ctor</span></span><br><span class=\"line\"><span class=\"built_in\">complex</span>&lt;<span class=\"keyword\">double</span>&gt; c&#123;<span class=\"number\">4.0</span>, <span class=\"number\">3.0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Rect r1 = &#123; <span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">20</span>,<span class=\"number\">25</span>,&amp;area, &amp;<span class=\"built_in\">print</span> &#125;;</span><br><span class=\"line\"><span class=\"function\">Rect <span class=\"title\">r1</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">20</span>,<span class=\"number\">25</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ia[<span class=\"number\">6</span>] = &#123; <span class=\"number\">27</span>,<span class=\"number\">210</span>,<span class=\"number\">12</span>,<span class=\"number\">47</span>,<span class=\"number\">109</span>,<span class=\"number\">83</span> &#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Initializer-Lists\"><a href=\"#Initializer-Lists\" class=\"headerlink\" title=\"Initializer Lists\"></a>Initializer Lists</h4><p>Initializer Lists的一些示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i;\t\t<span class=\"comment\">// i 的值不确定</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j&#123;&#125;;\t<span class=\"comment\">// j 被初始化为 0</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p;\t\t<span class=\"comment\">// p 的值不确定</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* q&#123;&#125;;\t<span class=\"comment\">// q 被初始化为 nullptr</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">x1</span><span class=\"params\">(<span class=\"number\">5.3</span>)</span></span>;\t<span class=\"comment\">// OK, x1==5</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x2 = <span class=\"number\">5.3</span>;\t<span class=\"comment\">// OK, x2==5</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x3&#123;<span class=\"number\">5.3</span>&#125;;\t<span class=\"comment\">// ERROR: narrowing</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x4 = &#123;<span class=\"number\">5.3</span>&#125;;\t<span class=\"comment\">// ERROR: narrowing</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c1&#123;<span class=\"number\">7</span>&#125;;\t\t<span class=\"comment\">// OK: 这里没有narrowing</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c2&#123;<span class=\"number\">99999</span>&#125;;\t<span class=\"comment\">// ERROR“ narrowing(99999不符合char的范围)</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v2&#123;<span class=\"number\">1</span>, <span class=\"number\">2.3</span>, <span class=\"number\">4</span>, <span class=\"number\">5.6</span>&#125;;\t<span class=\"comment\">// ERROR: narrowing</span></span><br></pre></td></tr></table></figure>\n<p>模板类std::initializer_list&lt;&gt;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt; vals)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> p=vals.<span class=\"built_in\">begin</span>(); p!=vals.<span class=\"built_in\">end</span>(); p++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; *p &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(&#123;<span class=\"number\">12</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">13</span>,<span class=\"number\">17</span>&#125;);\t<span class=\"comment\">// 传递a list of value给print()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 示例2</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">P</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    P(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"p(int, int), a=\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\", b=\"</span> &lt;&lt; b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    P(<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt; initlist)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"P(initializer_list&lt;int&gt;), values= \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : initlist)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">' '</span>;</span><br><span class=\"line\">       \t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">P <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">77</span>,<span class=\"number\">5</span>)</span></span>;\t\t<span class=\"comment\">// P(int, int), a=77, b=5</span></span><br><span class=\"line\">P q&#123;<span class=\"number\">77</span>,<span class=\"number\">5</span>&#125;;\t\t<span class=\"comment\">// P(initializer_list&lt;int&gt;), values= 77 5 42</span></span><br><span class=\"line\">P r&#123;<span class=\"number\">77</span>,<span class=\"number\">5</span>,<span class=\"number\">42</span>&#125;;\t<span class=\"comment\">// P(initializer_list&lt;int&gt;), values= 77 5</span></span><br><span class=\"line\">P s=&#123;<span class=\"number\">77</span>,<span class=\"number\">5</span>&#125;;\t\t<span class=\"comment\">// P(initializer_list&lt;int&gt;), values= 77 5</span></span><br><span class=\"line\"><span class=\"comment\">// 如果没有initializer_list的ctor，q和s可以运行，但是r不行</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"explicit\"><a href=\"#explicit\" class=\"headerlink\" title=\"explicit\"></a>explicit</h3><p>explicit for ctors，表示这个ctor必须被明确调用才行，不允许编译器做隐式转换。</p>\n<p>示例如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Complex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> real, <span class=\"built_in\">image</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">explicit</span></span><br><span class=\"line\">    Complex(<span class=\"keyword\">int</span> re, <span class=\"keyword\">int</span> im=<span class=\"number\">0</span>): real(re), <span class=\"built_in\">image</span>(im)&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Complex <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Complex&amp; x)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Complex((real + x.real), (<span class=\"built_in\">image</span> + x.<span class=\"built_in\">image</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Complex <span class=\"title\">c1</span><span class=\"params\">(<span class=\"number\">12</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">Complex c2 = c1 + <span class=\"number\">5</span>; <span class=\"comment\">// [Error] no match for 'operator+' (operand types are 'Complex' and 'int')</span></span><br><span class=\"line\"><span class=\"comment\">// 如果ctor没有explicit关键字，那么编译器就会把5隐式转换为5+0i，然后进行运算；</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"range-based-for-statement\"><a href=\"#range-based-for-statement\" class=\"headerlink\" title=\"range-based for statement\"></a>range-based for statement</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> ( decl : coll ) &#123;</span><br><span class=\"line\">    statement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : &#123; <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; vec;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> elem : vec ) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; elem &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 取引用，可以直接修改值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; elem : vec) &#123;</span><br><span class=\"line\">    elem *= <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"default-delete\"><a href=\"#default-delete\" class=\"headerlink\" title=\"=default, =delete\"></a>=default, =delete</h3><p>如果自行定义了一个ctor，那么编译器就不会再给你一个default ctor；</p>\n<p>如果你强制加上 =default，就可以重新获得并使用 default ctor；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zoo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Zoo(<span class=\"keyword\">int</span> i1, <span class=\"keyword\">int</span> i2): d1(i1), d2(i2) &#123;&#125;</span><br><span class=\"line\">    Zoo(<span class=\"keyword\">const</span> Zoo&amp;) =<span class=\"keyword\">delete</span>;\t\t\t\t<span class=\"comment\">// 拷贝构造</span></span><br><span class=\"line\">    Zoo(Zoo&amp;&amp;) =<span class=\"keyword\">default</span>;</span><br><span class=\"line\">    Zoo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Zoo&amp;) =<span class=\"keyword\">default</span>;\t<span class=\"comment\">// 拷贝赋值</span></span><br><span class=\"line\">    Zoo&amp; <span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Zoo&amp;&amp;) =<span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~Zoo() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> d1, d2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Alias-Template-template-typedef\"><a href=\"#Alias-Template-template-typedef\" class=\"headerlink\" title=\"Alias Template (template typedef)\"></a>Alias Template (template typedef)</h3><p>Alias：化名，别名</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Vec = <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class=\"line\">Vec&lt;<span class=\"keyword\">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>\n<p>等价于：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>, MyAlloc&lt;<span class=\"keyword\">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure>\n<p>typedef 没法指定类型参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>, MyAlloc&lt;<span class=\"keyword\">int</span>&gt;&gt; Vec;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Type-Alias\"><a href=\"#Type-Alias\" class=\"headerlink\" title=\"Type Alias\"></a>Type Alias</h3><p>和 typedef 相似</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// typedef void (*func)(int, int); 等价于下式</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> func = <span class=\"keyword\">void</span>(*)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\"><span class=\"comment\">// func 表示函数指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">example</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\">func fn = example;</span><br></pre></td></tr></table></figure>\n<h3 id=\"using关键字\"><a href=\"#using关键字\" class=\"headerlink\" title=\"using关键字\"></a>using关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;\t<span class=\"comment\">// 命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;\t\t<span class=\"comment\">// 声明 namespace members</span></span><br><span class=\"line\"><span class=\"comment\">// type alias和alias template声明</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> func = <span class=\"keyword\">void</span>(*)(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Container</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> value_type = T;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CharT</span>&gt; <span class=\"title\">using</span> <span class=\"title\">mystring</span>=<span class=\"title\">std</span>:</span>:basic_string&lt;CharT, <span class=\"built_in\">std</span>::char_traits&lt;CharT&gt;&gt;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"noexcept关键字\"><a href=\"#noexcept关键字\" class=\"headerlink\" title=\"noexcept关键字\"></a>noexcept关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> <span class=\"keyword\">noexcept</span></span>; &lt;=&gt; <span class=\"keyword\">void</span> foo() <span class=\"keyword\">noexcept</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Type&amp; x, Type&amp; y)</span> <span class=\"title\">npexcept</span><span class=\"params\">(<span class=\"keyword\">noexcept</span>(x.swap(y)))</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    x.swap(y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保证函数不会丢出异常；<code>noexcept(...)</code>中可以指定boolean表达式，表面在某种情况下不丢出异常；</p>\n<h3 id=\"override关键字\"><a href=\"#override关键字\" class=\"headerlink\" title=\"override关键字\"></a>override关键字</h3><p>作用于虚函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived1</span>:</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> </span>&#123;&#125;\t<span class=\"comment\">// 本意是重写父类函数的，结果参数不对，编译器会认为是新的虚函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived2</span>:</span> Base &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span> <span class=\"keyword\">override</span> </span>&#123;&#125;\t\t<span class=\"comment\">// 报错，想重写还传这个参数...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">vfunc</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span> <span class=\"keyword\">override</span> </span>&#123;&#125;\t<span class=\"comment\">// 重写成功，参数一致</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"final关键字\"><a href=\"#final关键字\" class=\"headerlink\" title=\"final关键字\"></a>final关键字</h3><p>用于类，则该类不能被继承；用于函数，则该函数不能被重写；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base1</span> <span class=\"title\">final</span> &#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived1</span> :</span> Base1 &#123;&#125;;\t\t<span class=\"comment\">// ERROR</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Base2</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"keyword\">final</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Derived2</span> :</span> Base2 &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;\t<span class=\"comment\">// ERROR</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"decltype\"><a href=\"#decltype\" class=\"headerlink\" title=\"decltype\"></a>decltype</h3><p>使用decltype，可以让编译器找到一个expression的类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">float</span>&gt; coll;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(coll)::value_type elem;</span><br><span class=\"line\"><span class=\"comment\">// 等价于c++ 11之前的写法</span></span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">float</span>&gt;::value_type elem;</span><br></pre></td></tr></table></figure>\n<p>用法：</p>\n<ol>\n<li><p>声明返回类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(x+y) add(T1 x, T2 y);\t<span class=\"comment\">// 编译出错：编译器先看到x,y，但是前面没出现过</span></span><br><span class=\"line\">=&gt;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> add(T1 x, T2 y) -&gt; <span class=\"keyword\">decltype</span>(x+y);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>适用于metaprogramming</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_decltype</span><span class=\"params\">(T obj)</span></span>&#123;&#125;\t\t<span class=\"comment\">// T必须是容器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> T::iterator iType;</span><br><span class=\"line\">=&gt; <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> <span class=\"keyword\">decltype</span>(obj)::iterator iType;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传递 lambda 的类型</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> cmp = [](<span class=\"keyword\">const</span> Person&amp; p1, <span class=\"keyword\">const</span> Person&amp; p2) &#123; ... &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 必须传递cmp给coll；否则coll会调用cmp的默认ctor，但cmp是lambda，没有默认构造函数，就会报错。所以必须这么传递</span></span><br><span class=\"line\">std::set&lt;Person, decltype(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h3><p>lambda就是可以在语句或表达式中定义的函数，这个函数可以被作为参数或者局部变量；</p>\n<p>lambda是一个对象，功能上是一个函数；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...](...) <span class=\"keyword\">mutable</span> throwSpec -&gt; retType &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[]：里面放取用的外部变量，值<span class=\"keyword\">or</span>引用都可</span><br><span class=\"line\">()：标识重载的()操作符的参数，<span class=\"keyword\">mutable</span>,throwSpec,retType都省略的话()也可以省略</span><br><span class=\"line\"><span class=\"keyword\">mutable</span>：表示变量以value形式传入，且值可以修改，不加则传入的值只可读</span><br><span class=\"line\">throwSpec：指定函数抛出的异常，如 <span class=\"keyword\">throw</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">retType：返回类型，没有则编译器自己推断</span><br><span class=\"line\">&#123;&#125;：函数体</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> I = []&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello lambda\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">I();\t<span class=\"comment\">// prints \"hello lambda\"</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Makefile Record","date":"2021-03-29T08:36:21.000Z","top_img":"/img/cover/games101.webp","cover":"/img/cover/games101.webp","_content":"\n## Makefile\n","source":"_posts/Makefile-Record.md","raw":"---\ntitle: Makefile Record\ndate: 2021-03-29 16:36:21\ntop_img: /img/cover/games101.webp\ncover: /img/cover/games101.webp\ntags: [c++, makefile]\n---\n\n## Makefile\n","slug":"Makefile-Record","published":1,"updated":"2022-03-25T12:22:17.112Z","_id":"ckpt846l30001lktpdq4gcbnh","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Makefile\"><a href=\"#Makefile\" class=\"headerlink\" title=\"Makefile\"></a>Makefile</h2>"},{"title":"Spring-1","date":"2021-05-25T13:26:26.000Z","top_img":"/img/cover/spring.jpeg","cover":"/img/cover/spring.jpeg","_content":"\n## Bean 装配\n### 自动化装配\n+ 自动化装配 = 组件扫描 + 自动装配\n    + 组件扫描(component scanning): Spring会自动发现应用上下文中所创建的bean\n    + 自动装配(autowiring): Spring 自动满足bean之间的依赖\n\n+ `@Component`注解作用在类上，表明该类作为组件类，并告知 Spring 要为这个类创建 bean。\n    + `@Component(\"bean-name\")`，bean 的默认ID为类名，手动指明后为`bean-name`\n+ `@ComponentScan`注解作用在配置类，强制 Spring 开启组件扫描，默认扫描位置为配置类所在的目录，找到所有带`@Component`注解的类。\n    + `@ComponentScan(basePackages=\"soudsystem\")`, `@ComponentScan(basePackages={\"soudsystem\", \"video\"})`，扫描这些包\n    + `@ComponentScan(basePackages={CDPlayer.class, DVDPlayer.class})`，扫描这些类所在的包\n\n+ `@Autowired`注解，作用于构造器、属性的setter方法、对象，表明当Spring调用这个构造器或方法或对象时，会传入一个合适的bean\n    + 如果有且只有一个 bean 匹配依赖需求，那么这个 bean 会被装配进来；\n    + 如果没有匹配的 bean，那么应用上下文创建的时候，Spring 会抛出异常；`@Autowired(required=false)`可以避免异常；\n    + 如果有多个 bean 都能满足依赖关系，Spring 会抛出异常，表明没有指明选择哪个 bean；\n\n### 通过Java代码装配bean\n首先需要一个单独的配置类 `JavaConfig`，自动化装配会给配置类加上`@ComponentScan`，这里我们不选择这么做；\n\n+ `@Bean`注解，作用于创建类实例的方法，告诉Spring该方法会返回一个对象，该对象要注册成为Spring应用上下文中的bean，方法体包含了创建对象的具体逻辑\n    ```java\n    @Bean\n    public CompactDisc sgtPeppers() {\n        return new SgtPeppers();\n    }\n    ```\n\n### 通过XML装配bean\n这个xml文件比较繁琐，且方式落后，详情见书本吧\n\n### 配置 profile bean\n环境的不同需要不同构建方式的同一个 bean。\n\n在3.1版本中，Spring引入了bean profile的功能。要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署 到每个环境时，要确保对应的profile处于激活（active）的状态。\n\n+ `@Profile`注解指定某个bean属于哪一个profile，可以用在类上，也可以用在方法上，只有profile被激活时，对应的bean才会被创建，没有指定profile的bean始终都被被创建\n    + 示例：\n    ```java\n    @Configuration\n    public class DataSourceConfig {\n        @Bean(destroyMethod=\"shutdown\")\n        @Profile(\"dev\")\n        public DataSource embeddedDataSource() {\n        }\n\n        @Bean\n        @Profile(\"prod\")\n        public DataSource jndiDataSource() {\n        }\n    }\n    ```\n\n+ profile的激活：`spring.profiles.active`和`spring.profiles.default`\n    + 如果`spring.profiles.active`有设置，则激活`spring.profiles.active`对应的profile；如果没有设置，则看`spring.profiles.default`；\n    + 如果`spring.profiles.default`有设置，则激活`spring.profiles.default`对应的profile；如果没有设置，则设置了profile的bean都不激活；\n+ `@ActiveProfiles(\"dev\")`注解，指定要激活的profile\n\n### 条件化的 bean\n假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后 才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。\n\n+ `@Conditional`注解，可以用于带有`@Bean`注解的方法上；如果给的条件计算为true，就会创建这个bean，否则会被忽略\n    + magicBean方法使用了`@Conditional`注解，传入了`MagicExistsCondition.class`，`MagicExistsCondition.class`实现了`Condition.class`的matches接口，判断有没有`magic`这个环境属性。如果有，则创建这个bean；如果没有，则不创建。\n    ```java\n    @Bean\n    @Conditional(MagicExistsCondition.class)\n    public MagicBean magicBean() {\n        return MagicBean();\n    }\n\n    public interface Condition {\n        boolean matches(ConditionContext ctxt, AnnotatedTypeMetadata metadata);\n    }\n\n    public class MagicExistsCondition implements Condition {\n        public boolean matches(ConditionContext ctxt, AnnotatedTypeMetadata metadata) {\n            Environment env = context.getEnvironment();\n            return env.containsProperty(\"magic\");\n        }\n    }\n    ```\n\n### 处理自动装配的歧义性\n即有多个匹配的bean能够满足装配\n#### 标示首选的 bean\n+ `@Primary`注解，指定最喜欢的方案。`@Primary`能够与`@Component`组合用在组件扫描\n的bean上，也可以与`@Bean`组合用在Java配置的bean声明中\n    + 示例\n    ```java\n    // 自动化配置\n    @Component\n    @Primary\n    public class IceCream implements Dessert { ... }\n\n    // Java 配置\n    @Bean\n    @Primary\n    public Dessert iceCream() {\n        return new IceCream();\n    };\n    ```\n\n####  限定自动装配的 bean\n+ `@Qualifier`注解，使用限定符的主要方式。可以与`@Autowired`协同使用，参数为想注入的 bean 的 ID\n    + 示例\n    ```java\n    @Autowired\n    @Qualifier(\"iceCream\")\n    public void setDessert(Dessert dessert) {\n        this.dessert = dessert;\n    }\n    ```\n\n这时候的限定符指定的bean的ID还是紧耦合的，一旦bean改名之后代码就需要再次修改，因此设计了自定义的限定符。\n为 bean 设置限定符，也就不依赖于 bean ID 作为限定符，为 bean 声明上添加 `@Qualifier`注解即可\n```java\n@Component\n@Qualifier(\"cold\")\npublic class IceCream implements Dessert { ... }\n```\n以上，就实现了与 bean 的类名解耦\n\n### bean 的作用域\n+ 单例(Singleton)：在整个应用中，只创建一个bean实例\n    + 默认模式，但是不适用于易变类型\n+ 原型(Prototype)：每次注入或通过Spring应用上下文获取的时候，都会创建一个bean实例\n    + 使用`@Scope`注解选择其他作用域\n    ```java\n    @Component\n    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 原型作用域\n    public class Notepad { ... }\n    ```\n+ 会话(Session)：在Web应用中，为每个会话创建一个bean实例\n    + `SCOPE_SESSION`，会为每个会话创建一个`ShoppingCart`\n    ```java\n    @Component\n    @Scope(ConfigurableBeanFactory.SCOPE_SESSION，proxyMode=ScopedProxyMode.INTERFACES) // 原型作用域\n    public ShoppingCart cart() { ... }\n    ```\n    + 注意：对于每个会话来说，还是单例的\n    + 关于`ProxyMode`，详见书本59页\n+ 请求(Request)：在Web应用中，为每个请求创建一个bean实例\n\n## 面向切面的Spring\n在使用面向切面编程时，我们仍然在一个地方定义通用功能， 但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称 为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为 它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。\n\n+ 通知 advice：定义了切面是什么以及何时使用\n    + 前置通知 Before：在目标方法被调用之前调用通知功能\n    + 后置通知 After：在目标方法调用之后调用通知，不关心方法的输出是什么\n    + 返回通知 After-returning：在目标方法成功执行之后调用通知\n    + 异常通知 After-throwing：在目标方法抛出异常后调用通知\n    + 环绕通知 Around：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为\n+ 连接点 join point：在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。\n+ 切点 pointcut：切点定义了何处，有助于缩小切面所通知的连接点的范围。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。\n+ 切面 Aspect：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。\n+ 引入 Introduction：引入允许我们向现有的类添加新方法或属性。\n    + 例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。\n+ 织入 Weaving：织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。\n    + 在目标对象的生命周期里有多个点可以进行织入：\n        + 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。\n        + 类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增 强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。\n        + 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。\n\n+ 切面类实例：\n    ```java\n    package concert;\n\n    public interface Performance {\n        public void perform();\n    }\n    ```\n    ```java\n    package concert;\n\n    @Aspect     // 表明是个切面\n    public class Audience {\n        // 定义命名的切点\n        @Pointcut(\"execution(** concert.Performance.perform(..))\")\n        public void performance() {};\n\n        @Before(\"performance()\")\n        public void slienceCellPhones() {\n            System.out.println(\"Sliencing cell phones\");\n        }\n\n        @Before(\"performance()\")\n        public void takeSeats() {\n            System.out.println(\"Taking seats\");\n        }\n\n        @AfterReturning(\"performance()\")\n        public void applause() {\n            System.out.println(\"CLAP CLAP CLAP!!\");\n        }\n\n        @AfterThrowing(\"performance()\")\n        public void demandRefund() {\n            System.out.println(\"Demanding a refund\");\n        }\n    }\n    ```\n\n## 第5章 构建Spring Web应用程序\n\n\n\n## 参考\n《[Spring实战](https://github.com/niuxinghua/iOS-collection/blob/master/Spring%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89%20(1)%20(1).pdf)》","source":"_posts/Spring-1.md","raw":"---\ntitle: Spring-1\ndate: 2021-05-25 21:26:26\ntop_img: /img/cover/spring.jpeg\ncover: /img/cover/spring.jpeg\ntags: [Spring, 笔记]\n---\n\n## Bean 装配\n### 自动化装配\n+ 自动化装配 = 组件扫描 + 自动装配\n    + 组件扫描(component scanning): Spring会自动发现应用上下文中所创建的bean\n    + 自动装配(autowiring): Spring 自动满足bean之间的依赖\n\n+ `@Component`注解作用在类上，表明该类作为组件类，并告知 Spring 要为这个类创建 bean。\n    + `@Component(\"bean-name\")`，bean 的默认ID为类名，手动指明后为`bean-name`\n+ `@ComponentScan`注解作用在配置类，强制 Spring 开启组件扫描，默认扫描位置为配置类所在的目录，找到所有带`@Component`注解的类。\n    + `@ComponentScan(basePackages=\"soudsystem\")`, `@ComponentScan(basePackages={\"soudsystem\", \"video\"})`，扫描这些包\n    + `@ComponentScan(basePackages={CDPlayer.class, DVDPlayer.class})`，扫描这些类所在的包\n\n+ `@Autowired`注解，作用于构造器、属性的setter方法、对象，表明当Spring调用这个构造器或方法或对象时，会传入一个合适的bean\n    + 如果有且只有一个 bean 匹配依赖需求，那么这个 bean 会被装配进来；\n    + 如果没有匹配的 bean，那么应用上下文创建的时候，Spring 会抛出异常；`@Autowired(required=false)`可以避免异常；\n    + 如果有多个 bean 都能满足依赖关系，Spring 会抛出异常，表明没有指明选择哪个 bean；\n\n### 通过Java代码装配bean\n首先需要一个单独的配置类 `JavaConfig`，自动化装配会给配置类加上`@ComponentScan`，这里我们不选择这么做；\n\n+ `@Bean`注解，作用于创建类实例的方法，告诉Spring该方法会返回一个对象，该对象要注册成为Spring应用上下文中的bean，方法体包含了创建对象的具体逻辑\n    ```java\n    @Bean\n    public CompactDisc sgtPeppers() {\n        return new SgtPeppers();\n    }\n    ```\n\n### 通过XML装配bean\n这个xml文件比较繁琐，且方式落后，详情见书本吧\n\n### 配置 profile bean\n环境的不同需要不同构建方式的同一个 bean。\n\n在3.1版本中，Spring引入了bean profile的功能。要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署 到每个环境时，要确保对应的profile处于激活（active）的状态。\n\n+ `@Profile`注解指定某个bean属于哪一个profile，可以用在类上，也可以用在方法上，只有profile被激活时，对应的bean才会被创建，没有指定profile的bean始终都被被创建\n    + 示例：\n    ```java\n    @Configuration\n    public class DataSourceConfig {\n        @Bean(destroyMethod=\"shutdown\")\n        @Profile(\"dev\")\n        public DataSource embeddedDataSource() {\n        }\n\n        @Bean\n        @Profile(\"prod\")\n        public DataSource jndiDataSource() {\n        }\n    }\n    ```\n\n+ profile的激活：`spring.profiles.active`和`spring.profiles.default`\n    + 如果`spring.profiles.active`有设置，则激活`spring.profiles.active`对应的profile；如果没有设置，则看`spring.profiles.default`；\n    + 如果`spring.profiles.default`有设置，则激活`spring.profiles.default`对应的profile；如果没有设置，则设置了profile的bean都不激活；\n+ `@ActiveProfiles(\"dev\")`注解，指定要激活的profile\n\n### 条件化的 bean\n假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后 才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。\n\n+ `@Conditional`注解，可以用于带有`@Bean`注解的方法上；如果给的条件计算为true，就会创建这个bean，否则会被忽略\n    + magicBean方法使用了`@Conditional`注解，传入了`MagicExistsCondition.class`，`MagicExistsCondition.class`实现了`Condition.class`的matches接口，判断有没有`magic`这个环境属性。如果有，则创建这个bean；如果没有，则不创建。\n    ```java\n    @Bean\n    @Conditional(MagicExistsCondition.class)\n    public MagicBean magicBean() {\n        return MagicBean();\n    }\n\n    public interface Condition {\n        boolean matches(ConditionContext ctxt, AnnotatedTypeMetadata metadata);\n    }\n\n    public class MagicExistsCondition implements Condition {\n        public boolean matches(ConditionContext ctxt, AnnotatedTypeMetadata metadata) {\n            Environment env = context.getEnvironment();\n            return env.containsProperty(\"magic\");\n        }\n    }\n    ```\n\n### 处理自动装配的歧义性\n即有多个匹配的bean能够满足装配\n#### 标示首选的 bean\n+ `@Primary`注解，指定最喜欢的方案。`@Primary`能够与`@Component`组合用在组件扫描\n的bean上，也可以与`@Bean`组合用在Java配置的bean声明中\n    + 示例\n    ```java\n    // 自动化配置\n    @Component\n    @Primary\n    public class IceCream implements Dessert { ... }\n\n    // Java 配置\n    @Bean\n    @Primary\n    public Dessert iceCream() {\n        return new IceCream();\n    };\n    ```\n\n####  限定自动装配的 bean\n+ `@Qualifier`注解，使用限定符的主要方式。可以与`@Autowired`协同使用，参数为想注入的 bean 的 ID\n    + 示例\n    ```java\n    @Autowired\n    @Qualifier(\"iceCream\")\n    public void setDessert(Dessert dessert) {\n        this.dessert = dessert;\n    }\n    ```\n\n这时候的限定符指定的bean的ID还是紧耦合的，一旦bean改名之后代码就需要再次修改，因此设计了自定义的限定符。\n为 bean 设置限定符，也就不依赖于 bean ID 作为限定符，为 bean 声明上添加 `@Qualifier`注解即可\n```java\n@Component\n@Qualifier(\"cold\")\npublic class IceCream implements Dessert { ... }\n```\n以上，就实现了与 bean 的类名解耦\n\n### bean 的作用域\n+ 单例(Singleton)：在整个应用中，只创建一个bean实例\n    + 默认模式，但是不适用于易变类型\n+ 原型(Prototype)：每次注入或通过Spring应用上下文获取的时候，都会创建一个bean实例\n    + 使用`@Scope`注解选择其他作用域\n    ```java\n    @Component\n    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 原型作用域\n    public class Notepad { ... }\n    ```\n+ 会话(Session)：在Web应用中，为每个会话创建一个bean实例\n    + `SCOPE_SESSION`，会为每个会话创建一个`ShoppingCart`\n    ```java\n    @Component\n    @Scope(ConfigurableBeanFactory.SCOPE_SESSION，proxyMode=ScopedProxyMode.INTERFACES) // 原型作用域\n    public ShoppingCart cart() { ... }\n    ```\n    + 注意：对于每个会话来说，还是单例的\n    + 关于`ProxyMode`，详见书本59页\n+ 请求(Request)：在Web应用中，为每个请求创建一个bean实例\n\n## 面向切面的Spring\n在使用面向切面编程时，我们仍然在一个地方定义通用功能， 但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称 为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为 它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。\n\n+ 通知 advice：定义了切面是什么以及何时使用\n    + 前置通知 Before：在目标方法被调用之前调用通知功能\n    + 后置通知 After：在目标方法调用之后调用通知，不关心方法的输出是什么\n    + 返回通知 After-returning：在目标方法成功执行之后调用通知\n    + 异常通知 After-throwing：在目标方法抛出异常后调用通知\n    + 环绕通知 Around：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为\n+ 连接点 join point：在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。\n+ 切点 pointcut：切点定义了何处，有助于缩小切面所通知的连接点的范围。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。\n+ 切面 Aspect：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。\n+ 引入 Introduction：引入允许我们向现有的类添加新方法或属性。\n    + 例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。\n+ 织入 Weaving：织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。\n    + 在目标对象的生命周期里有多个点可以进行织入：\n        + 编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。\n        + 类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增 强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。\n        + 运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。\n\n+ 切面类实例：\n    ```java\n    package concert;\n\n    public interface Performance {\n        public void perform();\n    }\n    ```\n    ```java\n    package concert;\n\n    @Aspect     // 表明是个切面\n    public class Audience {\n        // 定义命名的切点\n        @Pointcut(\"execution(** concert.Performance.perform(..))\")\n        public void performance() {};\n\n        @Before(\"performance()\")\n        public void slienceCellPhones() {\n            System.out.println(\"Sliencing cell phones\");\n        }\n\n        @Before(\"performance()\")\n        public void takeSeats() {\n            System.out.println(\"Taking seats\");\n        }\n\n        @AfterReturning(\"performance()\")\n        public void applause() {\n            System.out.println(\"CLAP CLAP CLAP!!\");\n        }\n\n        @AfterThrowing(\"performance()\")\n        public void demandRefund() {\n            System.out.println(\"Demanding a refund\");\n        }\n    }\n    ```\n\n## 第5章 构建Spring Web应用程序\n\n\n\n## 参考\n《[Spring实战](https://github.com/niuxinghua/iOS-collection/blob/master/Spring%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89%20(1)%20(1).pdf)》","slug":"Spring-1","published":1,"updated":"2022-03-25T12:22:17.113Z","_id":"ckpt847ja0006lktp8b1lg95x","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Bean-装配\"><a href=\"#Bean-装配\" class=\"headerlink\" title=\"Bean 装配\"></a>Bean 装配</h2><h3 id=\"自动化装配\"><a href=\"#自动化装配\" class=\"headerlink\" title=\"自动化装配\"></a>自动化装配</h3><ul>\n<li><p>自动化装配 = 组件扫描 + 自动装配</p>\n<ul>\n<li>组件扫描(component scanning): Spring会自动发现应用上下文中所创建的bean</li>\n<li>自动装配(autowiring): Spring 自动满足bean之间的依赖</li>\n</ul>\n</li>\n<li><p><code>@Component</code>注解作用在类上，表明该类作为组件类，并告知 Spring 要为这个类创建 bean。</p>\n<ul>\n<li><code>@Component(&quot;bean-name&quot;)</code>，bean 的默认ID为类名，手动指明后为<code>bean-name</code></li>\n</ul>\n</li>\n<li><p><code>@ComponentScan</code>注解作用在配置类，强制 Spring 开启组件扫描，默认扫描位置为配置类所在的目录，找到所有带<code>@Component</code>注解的类。</p>\n<ul>\n<li><code>@ComponentScan(basePackages=&quot;soudsystem&quot;)</code>, <code>@ComponentScan(basePackages={&quot;soudsystem&quot;, &quot;video&quot;})</code>，扫描这些包</li>\n<li><code>@ComponentScan(basePackages={CDPlayer.class, DVDPlayer.class})</code>，扫描这些类所在的包</li>\n</ul>\n</li>\n<li><p><code>@Autowired</code>注解，作用于构造器、属性的setter方法、对象，表明当Spring调用这个构造器或方法或对象时，会传入一个合适的bean</p>\n<ul>\n<li>如果有且只有一个 bean 匹配依赖需求，那么这个 bean 会被装配进来；</li>\n<li>如果没有匹配的 bean，那么应用上下文创建的时候，Spring 会抛出异常；<code>@Autowired(required=false)</code>可以避免异常；</li>\n<li>如果有多个 bean 都能满足依赖关系，Spring 会抛出异常，表明没有指明选择哪个 bean；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"通过Java代码装配bean\"><a href=\"#通过Java代码装配bean\" class=\"headerlink\" title=\"通过Java代码装配bean\"></a>通过Java代码装配bean</h3><p>首先需要一个单独的配置类 <code>JavaConfig</code>，自动化装配会给配置类加上<code>@ComponentScan</code>，这里我们不选择这么做；</p>\n<ul>\n<li><code>@Bean</code>注解，作用于创建类实例的方法，告诉Spring该方法会返回一个对象，该对象要注册成为Spring应用上下文中的bean，方法体包含了创建对象的具体逻辑  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">sgtPeppers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"通过XML装配bean\"><a href=\"#通过XML装配bean\" class=\"headerlink\" title=\"通过XML装配bean\"></a>通过XML装配bean</h3><p>这个xml文件比较繁琐，且方式落后，详情见书本吧</p>\n<h3 id=\"配置-profile-bean\"><a href=\"#配置-profile-bean\" class=\"headerlink\" title=\"配置 profile bean\"></a>配置 profile bean</h3><p>环境的不同需要不同构建方式的同一个 bean。</p>\n<p>在3.1版本中，Spring引入了bean profile的功能。要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署 到每个环境时，要确保对应的profile处于激活（active）的状态。</p>\n<ul>\n<li><p><code>@Profile</code>注解指定某个bean属于哪一个profile，可以用在类上，也可以用在方法上，只有profile被激活时，对应的bean才会被创建，没有指定profile的bean始终都被被创建</p>\n<ul>\n<li>示例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(destroyMethod=<span class=\"string\">\"shutdown\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Profile</span>(<span class=\"string\">\"dev\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">embeddedDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile</span>(<span class=\"string\">\"prod\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">jndiDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>profile的激活：<code>spring.profiles.active</code>和<code>spring.profiles.default</code></p>\n<ul>\n<li>如果<code>spring.profiles.active</code>有设置，则激活<code>spring.profiles.active</code>对应的profile；如果没有设置，则看<code>spring.profiles.default</code>；</li>\n<li>如果<code>spring.profiles.default</code>有设置，则激活<code>spring.profiles.default</code>对应的profile；如果没有设置，则设置了profile的bean都不激活；</li>\n</ul>\n</li>\n<li><code>@ActiveProfiles(&quot;dev&quot;)</code>注解，指定要激活的profile</li>\n</ul>\n<h3 id=\"条件化的-bean\"><a href=\"#条件化的-bean\" class=\"headerlink\" title=\"条件化的 bean\"></a>条件化的 bean</h3><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后 才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。</p>\n<ul>\n<li><code>@Conditional</code>注解，可以用于带有<code>@Bean</code>注解的方法上；如果给的条件计算为true，就会创建这个bean，否则会被忽略<ul>\n<li>magicBean方法使用了<code>@Conditional</code>注解，传入了<code>MagicExistsCondition.class</code>，<code>MagicExistsCondition.class</code>实现了<code>Condition.class</code>的matches接口，判断有没有<code>magic</code>这个环境属性。如果有，则创建这个bean；如果没有，则不创建。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>(MagicExistsCondition<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> <span class=\"title\">MagicBean</span> <span class=\"title\">magicBean</span>() </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MagicBean();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext ctxt, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicExistsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext ctxt, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">        Environment env = context.getEnvironment();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env.containsProperty(<span class=\"string\">\"magic\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"处理自动装配的歧义性\"><a href=\"#处理自动装配的歧义性\" class=\"headerlink\" title=\"处理自动装配的歧义性\"></a>处理自动装配的歧义性</h3><p>即有多个匹配的bean能够满足装配</p>\n<h4 id=\"标示首选的-bean\"><a href=\"#标示首选的-bean\" class=\"headerlink\" title=\"标示首选的 bean\"></a>标示首选的 bean</h4><ul>\n<li><code>@Primary</code>注解，指定最喜欢的方案。<code>@Primary</code>能够与<code>@Component</code>组合用在组件扫描<br>的bean上，也可以与<code>@Bean</code>组合用在Java配置的bean声明中<ul>\n<li>示例<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动化配置</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IceCream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dessert</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Java 配置</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Dessert <span class=\"title\">iceCream</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IceCream();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"限定自动装配的-bean\"><a href=\"#限定自动装配的-bean\" class=\"headerlink\" title=\"限定自动装配的 bean\"></a>限定自动装配的 bean</h4><ul>\n<li><code>@Qualifier</code>注解，使用限定符的主要方式。可以与<code>@Autowired</code>协同使用，参数为想注入的 bean 的 ID<ul>\n<li>示例<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"iceCream\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDessert</span><span class=\"params\">(Dessert dessert)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dessert = dessert;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>这时候的限定符指定的bean的ID还是紧耦合的，一旦bean改名之后代码就需要再次修改，因此设计了自定义的限定符。<br>为 bean 设置限定符，也就不依赖于 bean ID 作为限定符，为 bean 声明上添加 <code>@Qualifier</code>注解即可<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"cold\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IceCream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dessert</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><br>以上，就实现了与 bean 的类名解耦</p>\n<h3 id=\"bean-的作用域\"><a href=\"#bean-的作用域\" class=\"headerlink\" title=\"bean 的作用域\"></a>bean 的作用域</h3><ul>\n<li>单例(Singleton)：在整个应用中，只创建一个bean实例<ul>\n<li>默认模式，但是不适用于易变类型</li>\n</ul>\n</li>\n<li>原型(Prototype)：每次注入或通过Spring应用上下文获取的时候，都会创建一个bean实例<ul>\n<li>使用<code>@Scope</code>注解选择其他作用域<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE) <span class=\"comment\">// 原型作用域</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notepad</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>会话(Session)：在Web应用中，为每个会话创建一个bean实例<ul>\n<li><code>SCOPE_SESSION</code>，会为每个会话创建一个<code>ShoppingCart</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span>(ConfigurableBeanFactory.SCOPE_SESSION，proxyMode=ScopedProxyMode.INTERFACES) <span class=\"comment\">// 原型作用域</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ShoppingCart <span class=\"title\">cart</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li>注意：对于每个会话来说，还是单例的</li>\n<li>关于<code>ProxyMode</code>，详见书本59页</li>\n</ul>\n</li>\n<li>请求(Request)：在Web应用中，为每个请求创建一个bean实例</li>\n</ul>\n<h2 id=\"面向切面的Spring\"><a href=\"#面向切面的Spring\" class=\"headerlink\" title=\"面向切面的Spring\"></a>面向切面的Spring</h2><p>在使用面向切面编程时，我们仍然在一个地方定义通用功能， 但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称 为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为 它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</p>\n<ul>\n<li>通知 advice：定义了切面是什么以及何时使用<ul>\n<li>前置通知 Before：在目标方法被调用之前调用通知功能</li>\n<li>后置通知 After：在目标方法调用之后调用通知，不关心方法的输出是什么</li>\n<li>返回通知 After-returning：在目标方法成功执行之后调用通知</li>\n<li>异常通知 After-throwing：在目标方法抛出异常后调用通知</li>\n<li>环绕通知 Around：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>\n</ul>\n</li>\n<li>连接点 join point：在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</li>\n<li>切点 pointcut：切点定义了何处，有助于缩小切面所通知的连接点的范围。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</li>\n<li>切面 Aspect：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。</li>\n<li>引入 Introduction：引入允许我们向现有的类添加新方法或属性。<ul>\n<li>例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。</li>\n</ul>\n</li>\n<li><p>织入 Weaving：织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。</p>\n<ul>\n<li>在目标对象的生命周期里有多个点可以进行织入：<ul>\n<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增 强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>切面类实例：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> concert;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Performance</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> concert;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span>     <span class=\"comment\">// 表明是个切面</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义命名的切点</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(** concert.Performance.perform(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">performance</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">slienceCellPhones</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Sliencing cell phones\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">takeSeats</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Taking seats\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">applause</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demandRefund</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Demanding a refund\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"第5章-构建Spring-Web应用程序\"><a href=\"#第5章-构建Spring-Web应用程序\" class=\"headerlink\" title=\"第5章 构建Spring Web应用程序\"></a>第5章 构建Spring Web应用程序</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《<a href=\"https://github.com/niuxinghua/iOS-collection/blob/master/Spring%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89%20(1\" target=\"_blank\" rel=\"noopener\">Spring实战</a>%20(1).pdf)》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Bean-装配\"><a href=\"#Bean-装配\" class=\"headerlink\" title=\"Bean 装配\"></a>Bean 装配</h2><h3 id=\"自动化装配\"><a href=\"#自动化装配\" class=\"headerlink\" title=\"自动化装配\"></a>自动化装配</h3><ul>\n<li><p>自动化装配 = 组件扫描 + 自动装配</p>\n<ul>\n<li>组件扫描(component scanning): Spring会自动发现应用上下文中所创建的bean</li>\n<li>自动装配(autowiring): Spring 自动满足bean之间的依赖</li>\n</ul>\n</li>\n<li><p><code>@Component</code>注解作用在类上，表明该类作为组件类，并告知 Spring 要为这个类创建 bean。</p>\n<ul>\n<li><code>@Component(&quot;bean-name&quot;)</code>，bean 的默认ID为类名，手动指明后为<code>bean-name</code></li>\n</ul>\n</li>\n<li><p><code>@ComponentScan</code>注解作用在配置类，强制 Spring 开启组件扫描，默认扫描位置为配置类所在的目录，找到所有带<code>@Component</code>注解的类。</p>\n<ul>\n<li><code>@ComponentScan(basePackages=&quot;soudsystem&quot;)</code>, <code>@ComponentScan(basePackages={&quot;soudsystem&quot;, &quot;video&quot;})</code>，扫描这些包</li>\n<li><code>@ComponentScan(basePackages={CDPlayer.class, DVDPlayer.class})</code>，扫描这些类所在的包</li>\n</ul>\n</li>\n<li><p><code>@Autowired</code>注解，作用于构造器、属性的setter方法、对象，表明当Spring调用这个构造器或方法或对象时，会传入一个合适的bean</p>\n<ul>\n<li>如果有且只有一个 bean 匹配依赖需求，那么这个 bean 会被装配进来；</li>\n<li>如果没有匹配的 bean，那么应用上下文创建的时候，Spring 会抛出异常；<code>@Autowired(required=false)</code>可以避免异常；</li>\n<li>如果有多个 bean 都能满足依赖关系，Spring 会抛出异常，表明没有指明选择哪个 bean；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"通过Java代码装配bean\"><a href=\"#通过Java代码装配bean\" class=\"headerlink\" title=\"通过Java代码装配bean\"></a>通过Java代码装配bean</h3><p>首先需要一个单独的配置类 <code>JavaConfig</code>，自动化装配会给配置类加上<code>@ComponentScan</code>，这里我们不选择这么做；</p>\n<ul>\n<li><code>@Bean</code>注解，作用于创建类实例的方法，告诉Spring该方法会返回一个对象，该对象要注册成为Spring应用上下文中的bean，方法体包含了创建对象的具体逻辑  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompactDisc <span class=\"title\">sgtPeppers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SgtPeppers();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"通过XML装配bean\"><a href=\"#通过XML装配bean\" class=\"headerlink\" title=\"通过XML装配bean\"></a>通过XML装配bean</h3><p>这个xml文件比较繁琐，且方式落后，详情见书本吧</p>\n<h3 id=\"配置-profile-bean\"><a href=\"#配置-profile-bean\" class=\"headerlink\" title=\"配置 profile bean\"></a>配置 profile bean</h3><p>环境的不同需要不同构建方式的同一个 bean。</p>\n<p>在3.1版本中，Spring引入了bean profile的功能。要使用profile，你首先要将所有不同的bean定义整理到一个或多个profile之中，在将应用部署 到每个环境时，要确保对应的profile处于激活（active）的状态。</p>\n<ul>\n<li><p><code>@Profile</code>注解指定某个bean属于哪一个profile，可以用在类上，也可以用在方法上，只有profile被激活时，对应的bean才会被创建，没有指定profile的bean始终都被被创建</p>\n<ul>\n<li>示例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(destroyMethod=<span class=\"string\">\"shutdown\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Profile</span>(<span class=\"string\">\"dev\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">embeddedDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile</span>(<span class=\"string\">\"prod\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">jndiDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>profile的激活：<code>spring.profiles.active</code>和<code>spring.profiles.default</code></p>\n<ul>\n<li>如果<code>spring.profiles.active</code>有设置，则激活<code>spring.profiles.active</code>对应的profile；如果没有设置，则看<code>spring.profiles.default</code>；</li>\n<li>如果<code>spring.profiles.default</code>有设置，则激活<code>spring.profiles.default</code>对应的profile；如果没有设置，则设置了profile的bean都不激活；</li>\n</ul>\n</li>\n<li><code>@ActiveProfiles(&quot;dev&quot;)</code>注解，指定要激活的profile</li>\n</ul>\n<h3 id=\"条件化的-bean\"><a href=\"#条件化的-bean\" class=\"headerlink\" title=\"条件化的 bean\"></a>条件化的 bean</h3><p>假设你希望一个或多个bean只有在应用的类路径下包含特定的库时才创建。或者我们希望某个bean只有当另外某个特定的bean也声明了之后 才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个bean。</p>\n<ul>\n<li><code>@Conditional</code>注解，可以用于带有<code>@Bean</code>注解的方法上；如果给的条件计算为true，就会创建这个bean，否则会被忽略<ul>\n<li>magicBean方法使用了<code>@Conditional</code>注解，传入了<code>MagicExistsCondition.class</code>，<code>MagicExistsCondition.class</code>实现了<code>Condition.class</code>的matches接口，判断有没有<code>magic</code>这个环境属性。如果有，则创建这个bean；如果没有，则不创建。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>(MagicExistsCondition<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> <span class=\"title\">MagicBean</span> <span class=\"title\">magicBean</span>() </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MagicBean();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext ctxt, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MagicExistsCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext ctxt, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">        Environment env = context.getEnvironment();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> env.containsProperty(<span class=\"string\">\"magic\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"处理自动装配的歧义性\"><a href=\"#处理自动装配的歧义性\" class=\"headerlink\" title=\"处理自动装配的歧义性\"></a>处理自动装配的歧义性</h3><p>即有多个匹配的bean能够满足装配</p>\n<h4 id=\"标示首选的-bean\"><a href=\"#标示首选的-bean\" class=\"headerlink\" title=\"标示首选的 bean\"></a>标示首选的 bean</h4><ul>\n<li><code>@Primary</code>注解，指定最喜欢的方案。<code>@Primary</code>能够与<code>@Component</code>组合用在组件扫描<br>的bean上，也可以与<code>@Bean</code>组合用在Java配置的bean声明中<ul>\n<li>示例<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动化配置</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IceCream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dessert</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Java 配置</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Dessert <span class=\"title\">iceCream</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IceCream();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"限定自动装配的-bean\"><a href=\"#限定自动装配的-bean\" class=\"headerlink\" title=\"限定自动装配的 bean\"></a>限定自动装配的 bean</h4><ul>\n<li><code>@Qualifier</code>注解，使用限定符的主要方式。可以与<code>@Autowired</code>协同使用，参数为想注入的 bean 的 ID<ul>\n<li>示例<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"iceCream\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDessert</span><span class=\"params\">(Dessert dessert)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dessert = dessert;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p>这时候的限定符指定的bean的ID还是紧耦合的，一旦bean改名之后代码就需要再次修改，因此设计了自定义的限定符。<br>为 bean 设置限定符，也就不依赖于 bean ID 作为限定符，为 bean 声明上添加 <code>@Qualifier</code>注解即可<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"cold\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IceCream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Dessert</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><br>以上，就实现了与 bean 的类名解耦</p>\n<h3 id=\"bean-的作用域\"><a href=\"#bean-的作用域\" class=\"headerlink\" title=\"bean 的作用域\"></a>bean 的作用域</h3><ul>\n<li>单例(Singleton)：在整个应用中，只创建一个bean实例<ul>\n<li>默认模式，但是不适用于易变类型</li>\n</ul>\n</li>\n<li>原型(Prototype)：每次注入或通过Spring应用上下文获取的时候，都会创建一个bean实例<ul>\n<li>使用<code>@Scope</code>注解选择其他作用域<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE) <span class=\"comment\">// 原型作用域</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Notepad</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>会话(Session)：在Web应用中，为每个会话创建一个bean实例<ul>\n<li><code>SCOPE_SESSION</code>，会为每个会话创建一个<code>ShoppingCart</code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span>(ConfigurableBeanFactory.SCOPE_SESSION，proxyMode=ScopedProxyMode.INTERFACES) <span class=\"comment\">// 原型作用域</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ShoppingCart <span class=\"title\">cart</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></li>\n<li>注意：对于每个会话来说，还是单例的</li>\n<li>关于<code>ProxyMode</code>，详见书本59页</li>\n</ul>\n</li>\n<li>请求(Request)：在Web应用中，为每个请求创建一个bean实例</li>\n</ul>\n<h2 id=\"面向切面的Spring\"><a href=\"#面向切面的Spring\" class=\"headerlink\" title=\"面向切面的Spring\"></a>面向切面的Spring</h2><p>在使用面向切面编程时，我们仍然在一个地方定义通用功能， 但是可以通过声明的方式定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称 为切面（aspect）。这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为 它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</p>\n<ul>\n<li>通知 advice：定义了切面是什么以及何时使用<ul>\n<li>前置通知 Before：在目标方法被调用之前调用通知功能</li>\n<li>后置通知 After：在目标方法调用之后调用通知，不关心方法的输出是什么</li>\n<li>返回通知 After-returning：在目标方法成功执行之后调用通知</li>\n<li>异常通知 After-throwing：在目标方法抛出异常后调用通知</li>\n<li>环绕通知 Around：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>\n</ul>\n</li>\n<li>连接点 join point：在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</li>\n<li>切点 pointcut：切点定义了何处，有助于缩小切面所通知的连接点的范围。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</li>\n<li>切面 Aspect：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。</li>\n<li>引入 Introduction：引入允许我们向现有的类添加新方法或属性。<ul>\n<li>例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。</li>\n</ul>\n</li>\n<li><p>织入 Weaving：织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。</p>\n<ul>\n<li>在目标对象的生命周期里有多个点可以进行织入：<ul>\n<li>编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。</li>\n<li>类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增 强该目标类的字节码。AspectJ 5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。</li>\n<li>运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>切面类实例：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> concert;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Performance</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">perform</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> concert;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span>     <span class=\"comment\">// 表明是个切面</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Audience</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义命名的切点</span></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(** concert.Performance.perform(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">performance</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">slienceCellPhones</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Sliencing cell phones\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">takeSeats</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Taking seats\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">applause</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"CLAP CLAP CLAP!!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterThrowing</span>(<span class=\"string\">\"performance()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">demandRefund</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Demanding a refund\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"第5章-构建Spring-Web应用程序\"><a href=\"#第5章-构建Spring-Web应用程序\" class=\"headerlink\" title=\"第5章 构建Spring Web应用程序\"></a>第5章 构建Spring Web应用程序</h2><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《<a href=\"https://github.com/niuxinghua/iOS-collection/blob/master/Spring%E5%AE%9E%E6%88%98%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89%20(1\" target=\"_blank\" rel=\"noopener\">Spring实战</a>%20(1).pdf)》</p>\n"},{"title":"c++11/14-2","date":"2021-06-12T05:14:08.000Z","top_img":"/img/cover/c11.jpg","cover":"/img/cover/c11.jpg","_content":"\n## c++标准库\n\n### 右值引用\n\n为了解决不必要的复制，并且允许perfect forwarding；\n\n当赋值操作（=号）的右边是一个右值rvalue，那么左边的对象可以从右边的对象“偷”resources，即允许move语义；\n\n> Lvalue: 可以出现在operator= 左侧者\n>\n> Rvalue: 只能出现在operator=右侧者\n\n临时对象就是一种右值\n\n```c++\nint foo() { return 5; }\n...\nint x = foo();\t\t// ok\nint* p = &foo();\t// error: 不可以对右值取引用，函数返回值属于右值\nfoo() = 7;\t\t\t// error\n```\n\n```c++\ntemplate <typename T>\nclass Myclass{\npublic:\n    Myclass();\n    Myclass(const T& t);\n    // 类需要有这样的构造函数且无异常才能支持move\n    Myclass(const T&& t) noexcept;\n}\n```\n\n右值使用示例\n\n```c++\nvoid process(int& i) { cout << \"process(int&):\" << i << endl; }\nvoid process(int&& i) { cout << \"process(int&&):\" << i << endl; }\nvoid forward(int&& i) {\n    cout << \"forward(int&&):\" << i << \",\";\n    process(i);\n}\n\nint a=0;\nprocess(a);\t\t\t// process(int&): 0\nprocess(1);\t\t\t// process(int&&): 1\nprocess(move(a));\t// process(int&&): 0\n// 不完美的传递(forwarding)\nforward(2);\t\t\t// forward(int&&):2, process(int&):2\n\t// 2经过传递之后变成了一个named object，即成了左值，因此调用process(int&)\nforward(move(a));\t// forward(int&&):0, process(int&):0\nforward(a);\t\t\t// ERROR: 不能绑定int左值到int&&\n\nconst int& b = 1;\nprocess(b);\t\t\t// ERROR:没有合适的函数调用‘process(const int&)’\nprocess(move(b));\t// 没有合适的函数调用'process(std::remove_reference<const int&>::type)'\n\nint& x(5);\t\t\t// ERROR\nprocess(move(x));\t// ERROR: x未声明\n```\n\n","source":"_posts/c-11-14-2.md","raw":"---\ntitle: c++11/14-2\ndate: 2021-06-12 13:14:08\ntop_img: /img/cover/c11.jpg\ncover: /img/cover/c11.jpg\ntags: [c++]\n---\n\n## c++标准库\n\n### 右值引用\n\n为了解决不必要的复制，并且允许perfect forwarding；\n\n当赋值操作（=号）的右边是一个右值rvalue，那么左边的对象可以从右边的对象“偷”resources，即允许move语义；\n\n> Lvalue: 可以出现在operator= 左侧者\n>\n> Rvalue: 只能出现在operator=右侧者\n\n临时对象就是一种右值\n\n```c++\nint foo() { return 5; }\n...\nint x = foo();\t\t// ok\nint* p = &foo();\t// error: 不可以对右值取引用，函数返回值属于右值\nfoo() = 7;\t\t\t// error\n```\n\n```c++\ntemplate <typename T>\nclass Myclass{\npublic:\n    Myclass();\n    Myclass(const T& t);\n    // 类需要有这样的构造函数且无异常才能支持move\n    Myclass(const T&& t) noexcept;\n}\n```\n\n右值使用示例\n\n```c++\nvoid process(int& i) { cout << \"process(int&):\" << i << endl; }\nvoid process(int&& i) { cout << \"process(int&&):\" << i << endl; }\nvoid forward(int&& i) {\n    cout << \"forward(int&&):\" << i << \",\";\n    process(i);\n}\n\nint a=0;\nprocess(a);\t\t\t// process(int&): 0\nprocess(1);\t\t\t// process(int&&): 1\nprocess(move(a));\t// process(int&&): 0\n// 不完美的传递(forwarding)\nforward(2);\t\t\t// forward(int&&):2, process(int&):2\n\t// 2经过传递之后变成了一个named object，即成了左值，因此调用process(int&)\nforward(move(a));\t// forward(int&&):0, process(int&):0\nforward(a);\t\t\t// ERROR: 不能绑定int左值到int&&\n\nconst int& b = 1;\nprocess(b);\t\t\t// ERROR:没有合适的函数调用‘process(const int&)’\nprocess(move(b));\t// 没有合适的函数调用'process(std::remove_reference<const int&>::type)'\n\nint& x(5);\t\t\t// ERROR\nprocess(move(x));\t// ERROR: x未声明\n```\n\n","slug":"c-11-14-2","published":1,"updated":"2022-03-25T12:22:17.116Z","_id":"ckpttxbzk0000gstpbdhr2wxl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"c-标准库\"><a href=\"#c-标准库\" class=\"headerlink\" title=\"c++标准库\"></a>c++标准库</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><p>为了解决不必要的复制，并且允许perfect forwarding；</p>\n<p>当赋值操作（=号）的右边是一个右值rvalue，那么左边的对象可以从右边的对象“偷”resources，即允许move语义；</p>\n<blockquote>\n<p>Lvalue: 可以出现在operator= 左侧者</p>\n<p>Rvalue: 只能出现在operator=右侧者</p>\n</blockquote>\n<p>临时对象就是一种右值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">5</span>; &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = foo();\t\t<span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;foo();\t<span class=\"comment\">// error: 不可以对右值取引用，函数返回值属于右值</span></span><br><span class=\"line\">foo() = <span class=\"number\">7</span>;\t\t\t<span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Myclass</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Myclass();</span><br><span class=\"line\">    Myclass(<span class=\"keyword\">const</span> T&amp; t);</span><br><span class=\"line\">    <span class=\"comment\">// 类需要有这样的构造函数且无异常才能支持move</span></span><br><span class=\"line\">    Myclass(<span class=\"keyword\">const</span> T&amp;&amp; t) <span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>右值使用示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; i)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"process(int&amp;):\"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; i)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"process(int&amp;&amp;):\"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"forward(int&amp;&amp;):\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">process</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">process</span>(a);\t\t\t<span class=\"comment\">// process(int&amp;): 0</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"number\">1</span>);\t\t\t<span class=\"comment\">// process(int&amp;&amp;): 1</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">move</span>(a));\t<span class=\"comment\">// process(int&amp;&amp;): 0</span></span><br><span class=\"line\"><span class=\"comment\">// 不完美的传递(forwarding)</span></span><br><span class=\"line\">forward(<span class=\"number\">2</span>);\t\t\t<span class=\"comment\">// forward(int&amp;&amp;):2, process(int&amp;):2</span></span><br><span class=\"line\">\t<span class=\"comment\">// 2经过传递之后变成了一个named object，即成了左值，因此调用process(int&amp;)</span></span><br><span class=\"line\">forward(<span class=\"built_in\">move</span>(a));\t<span class=\"comment\">// forward(int&amp;&amp;):0, process(int&amp;):0</span></span><br><span class=\"line\">forward(a);\t\t\t<span class=\"comment\">// ERROR: 不能绑定int左值到int&amp;&amp;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">process</span>(b);\t\t\t<span class=\"comment\">// ERROR:没有合适的函数调用‘process(const int&amp;)’</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">move</span>(b));\t<span class=\"comment\">// 没有合适的函数调用'process(std::remove_reference&lt;const int&amp;&gt;::type)'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;\t\t\t<span class=\"comment\">// ERROR</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">move</span>(x));\t<span class=\"comment\">// ERROR: x未声明</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"c-标准库\"><a href=\"#c-标准库\" class=\"headerlink\" title=\"c++标准库\"></a>c++标准库</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><p>为了解决不必要的复制，并且允许perfect forwarding；</p>\n<p>当赋值操作（=号）的右边是一个右值rvalue，那么左边的对象可以从右边的对象“偷”resources，即允许move语义；</p>\n<blockquote>\n<p>Lvalue: 可以出现在operator= 左侧者</p>\n<p>Rvalue: 只能出现在operator=右侧者</p>\n</blockquote>\n<p>临时对象就是一种右值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">5</span>; &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = foo();\t\t<span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;foo();\t<span class=\"comment\">// error: 不可以对右值取引用，函数返回值属于右值</span></span><br><span class=\"line\">foo() = <span class=\"number\">7</span>;\t\t\t<span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Myclass</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Myclass();</span><br><span class=\"line\">    Myclass(<span class=\"keyword\">const</span> T&amp; t);</span><br><span class=\"line\">    <span class=\"comment\">// 类需要有这样的构造函数且无异常才能支持move</span></span><br><span class=\"line\">    Myclass(<span class=\"keyword\">const</span> T&amp;&amp; t) <span class=\"keyword\">noexcept</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>右值使用示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; i)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"process(int&amp;):\"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; i)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"process(int&amp;&amp;):\"</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"forward(int&amp;&amp;):\"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">process</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> a=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">process</span>(a);\t\t\t<span class=\"comment\">// process(int&amp;): 0</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"number\">1</span>);\t\t\t<span class=\"comment\">// process(int&amp;&amp;): 1</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">move</span>(a));\t<span class=\"comment\">// process(int&amp;&amp;): 0</span></span><br><span class=\"line\"><span class=\"comment\">// 不完美的传递(forwarding)</span></span><br><span class=\"line\">forward(<span class=\"number\">2</span>);\t\t\t<span class=\"comment\">// forward(int&amp;&amp;):2, process(int&amp;):2</span></span><br><span class=\"line\">\t<span class=\"comment\">// 2经过传递之后变成了一个named object，即成了左值，因此调用process(int&amp;)</span></span><br><span class=\"line\">forward(<span class=\"built_in\">move</span>(a));\t<span class=\"comment\">// forward(int&amp;&amp;):0, process(int&amp;):0</span></span><br><span class=\"line\">forward(a);\t\t\t<span class=\"comment\">// ERROR: 不能绑定int左值到int&amp;&amp;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">process</span>(b);\t\t\t<span class=\"comment\">// ERROR:没有合适的函数调用‘process(const int&amp;)’</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">move</span>(b));\t<span class=\"comment\">// 没有合适的函数调用'process(std::remove_reference&lt;const int&amp;&gt;::type)'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>&amp; <span class=\"title\">x</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;\t\t\t<span class=\"comment\">// ERROR</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">move</span>(x));\t<span class=\"comment\">// ERROR: x未声明</span></span><br></pre></td></tr></table></figure>\n"},{"title":"设计模式","date":"2021-06-12T13:56:33.000Z","top_img":"/img/cover/designpattern.jpg","cover":"/img/cover/designpattern.jpg","_content":"# 设计模式\n参考书目：《大话设计模式》、《软件工程原理》\n\n## 面向对象\n+ 四大好处：可维护、可扩展、可复用、灵活性好\n\n## 第一章 简单工厂模式\n\n![simple](/img/designpatterns/simple.jpg)\n\n+ 所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。\n    + 通过创建反射类，结合配置文件将具体要创建的类的选择过程从工厂类的代码中解放出来，反射类中也没有switch，而是在配置文件中一一对应好，这样客户端只要传入要操作的类型就可以了。\n    + 这样工厂代码彻底实现了开——闭原则，即使要增加新的类也不需要修改工厂类。\n\n## 第二章 策略模式\n\n![strategy](/img/designpatterns/strategy.jpg)\n\n+ 策略模式：它定义了算法家族，分别封装起来，让他们之间可以互相调换，此模式让算法的变化，不会影响到使用算法的客户。\n\n+ 策略模式是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的方法，减少了各类算法类与使用算法类之间的耦合。\n\n+ 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取除这些算法中的公共功能\n+ 策略模式简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。\n\n## 第三章 单一职责原则\n+ 单一职责原则SRP：就一个类而言，应该仅有一个引起它变化的原因。\n\n+ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。\n\n+ 如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n## 第四章 开放——封闭原则(OCP)\n+ 开放——封闭原则，The Open-Closed Principle，简称OCP，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改\n    + 对于扩展是开放的，对于更改是封闭的\n\n+ 软件设计要容易维护又不容易出问题的好办法，就是多扩展，少修改。\n\n+ 面对需求，对程序的修改是通过增加新代码进行的，而不是更改现有的代码\n\n## 第五章 依赖倒转原则\n+ 依赖倒转原则：\n    + 抽象不应该依赖细节，细节应该依赖于抽象；即针对接口编程，不要对实现编程；\n    + 高层模块不应该依赖底层模块，两个都应该依赖抽象\n\n+ 里氏代换原则：在软件里，把父类都替换成他们的子类，程序的行为没有变化；\n    + 如果一个软件实体使用的是父类，那么程序无法区分子类和父类\n    + 注意：这里子类继承复用父类，显然父类的所有功能子类必须有，子类特有的子类再去添加；\n\n## 第六章 装饰模式\n\n![](/img/designpatterns/decorator.jpg)\n\n+ 装饰模式：动态的给一些类添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活；\n\n## 第七章 代理模式\n\n![proxy](/img/designpatterns/proxy.jpg)\n\n+ 代理模式：为其他对象提供一种代理以控制对这个对象的访问；\n\n+ 应用场合：\n    1. 远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实；\n    2. 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真是对象；\n    3. 安全代理，用来控制真实对象访问时的权限；\n    4. 智能指引，是指当调用真实的对象时，代理处理另外一些事；\n        + 如计算真实对象的引用次数，通过代理在访问一个对象时附加一些内务处理；\n\n## 第八章 工厂方法模式\n\n![factorymethod](/img/designpatterns/factorymethod.jpg)\n\n+ 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类；\n\n+ 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。\n    + 但是对工厂类的修改违背了开——闭原则\n\n+ 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是改客户端。\n    + 工厂方法模式既克服了简单工厂违背开放——封闭原则的缺点，又保持了封装对象过程的优点；\n\n## 第九章 原型模式\n\n![](/img/designpatterns/prototype.jpg)\n\n+ 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象\n\n+ 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。\n\n+ 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又是对性能大大的提高；\n    + 不是重新初始化对象，而是动态的获取对象运行时的状态；\n\n## 第十章 模板方法模式\n\n![template](/img/designpatterns/template.jpg)\n\n+ 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n+ 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。\n\n+ 通过把不变行为搬移到父类，去除子类中的重复代码来体现它的优势。\n+ 模板方法模式提供了一个很好的代码复用平台。\n\n## 第十一章 迪米特法则\n+ 迪米特法则(LoD)，也叫最少知识原则。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发这个调用。\n\n+ 首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。\n\n+ 其根本思想，是强调了类之间的松耦合。\n    + 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。\n\n## 第十二章 外观模式\n\n![facade](/img/designpatterns/facade.jpg)\n\n+ 外观模式：为了系统中的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n+ 何时使用\n    1. 在设计初期，应该要有意识地将不同的两个层分离，为复杂的子系统提供一个简单的接口，使得耦合大大降低。\n    2. 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂。\n        + 大多数的模式使用时会产生大量很小的类，对于外部调用很是麻烦；于是增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。\n    3. 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，这时可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。\n\n+ 理解：被外观隐藏的多个子系统可以是任意的，相互可以没有任何关系，侧重点在于，外观模式隐藏了子系统之间的相互调用，而是提供一组接口给外部调用。满足了松耦合的要求，也体现了迪米特法则。\n\n## 第十三章 建造者模式\n![builder](/img/designpatterns/builder.jpg)\n\n+ 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n    + 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n+ 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。\n+ 理解：这里强调的是过程，比如程序中一组特定顺序的过程。\n\n## 第十四章 观察者模式\n\n![observer](/img/designpatterns/observer.jpg)\n\n+ 观察者模式：又称发布——订阅(Publish/Subscribe)模式，它定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。\n\n+ 根据开——闭原则和依赖倒转原则，在这个模式中，通知者和监听者都是一个抽象父类，表示一个对外的抽象接口，而其子类都是一个个实体，因此对外封闭了实现细节，两边都只需要针对接口编程。\n\n+ 观察者模式很适合用于同时修改很多对象的状态的情景，尤其是不知道具体有多少对象的时候。\n\n+ 观察者模式实际上就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。\n\n+ 当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。\n\n## 第十五章 抽象工厂模式\n\n![abstractfactory](/img/designpatterns/abstractfactory.jpg)\n\n+ 抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n+ 这时候每个具体工厂生产的是一个完整的产品簇。抽象工厂方法的好处在于，易于交换产品系列，由于具体工厂类的初始化只有一行代码，因此将其修改之后，后面生产的产品也都完全改变。这就使得改变一个应用的具体工厂变的非常容易。\n+ 它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。\n+ 反射：\n+ 所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。\n\n## 第十六章 状态模式\n\n![state](/img/designpatterns/state.jpg)\n\n+ 状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n+ 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简单化。\n\n+ 好处：\n    1. 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。\n        + 将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。(继承于同一个State父类，并通过共同的handle函数进行状态切换)\n    2. 消除了庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State子类之间，来减少相互间的依赖。\n\n+ 何时使用：当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变他的行为时，就可以考虑使用状态模式了。\n\n## 第十七章 适配器模式\n\n![adapter](/img/designpatterns/adapter.jpg)\n\n+ 适配器模式(Adapter)：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n+ 使用：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。\n    + 使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。\n    + 两个类所做的事情相同或相似，但是具有不同的接口时要是用它。\n    + 双方都不太容易修改的时候在使用适配器模式。\n\n+ 主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。\n\n## 第十八章 备忘录模式\n\n![memento](/img/designpatterns/memento.jpg)\n\n+ 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n\n+ 使用：Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。\n    + 如：如果在某个系统使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。\n\n+ 使用备忘录模式可以把复杂的对象内部信息对其他的对象屏蔽起来。\n+ 当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。\n\n## 第十九章 组合模式\n\n![composite](/img/designpatterns/composite.jpg)\n\n+ 组合模式(Composite)：将对象组合成树形结构以表示’部分-整体‘的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n+ 整体与部分可以被一致对待\n\n+ 透明方式：就是在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。\n+ 安全方式：在Component类中不去生命Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法。由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。\n\n+ 使用：\n    1. 需求中是体现部分与整体层次的结构时\n    2. 希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。\n\n## 第二十章 迭代器模式\n\n![iterator](/img/designpatterns/iterator.jpg)\n\n+ 迭代器模式(Iterator)：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。\n\n+ 为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。\n\n+ 使用\n    + 需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候\n    + 对聚集有多种方式遍历时\n\n## 第二十一章 单例模式\n\n![singleton](/img/designpatterns/singleton.jpg)\n\n+ 单例模式(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n+ 让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且他可以提供一个访问该实例的方法。\n\n+ 所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。\n\n+ 好处：单例模式因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。\n\n## 合成/聚合复用原则\n+ 合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承。\n    + 聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；\n    + 合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的周期一样。\n\n+ 好处：\n    + 优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。\n\n## 第二十二章 桥接模式\n\n![qiaojie](/img/designpatterns/qiaojie.jpg)\n\n+ 桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n    + 实现指的是抽象类和它的派生类用来实现自己的对象。\n    + 实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少他们之间的耦合。\n\n## 第二十三章 命令模式\n\n![invoker](/img/designpatterns/invoker.jpg)\n\n+ 命令模式(Command)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。\n\n+ 命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。\n\n+ 作用：\n    1. 它能较容易地设计一个命令队列；\n    2. 在需要的情况下，可以较容易地将命令记入日志；\n    3. 允许请求的一方决定是否要否决请求；\n    4. 可以容易地实现对请求的撤销和重做；\n    5. 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。\n\n+ 敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构首先这个模式并不难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。\n\n## 第二十四章 职责链模式\n\n![successor](/img/designpatterns/successor.jpg)\n\n+ 职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n+ 当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。\n\n+ 接受者和发送者都没有对方的明确信息，且链中的对象自己也不知道链的结构。结果是职责链可简化为对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有候选接受者的引用————大大降低了耦合度。\n\n+ 可以随时增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性\n\n## 第二十五章 中介者模式\n\n![meditator](/img/designpatterns/meditator.jpg)\n\n+ 中介者模式(Mediator)：用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显式地相互调用，从而使其耦合松散，而且可以独立地改变他们之间的交互。\n\n+ 尽管将一个系统分割成许多对象通常可以增加其复用性，但是对象间相互连接的激增又会降低其可用性了。\n    + 大量的链接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就是困难了。\n\n+ 优点：\n    + 减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator；\n    + 由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。\n+ 缺点：\n    + 由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。\n\n+ 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。\n\n## 第二十六章 享元模式\n\n![flyweight](/img/designpatterns/flyweight.jpg)\n\n+ 享元模式(Flyweight)：运用共享技术有效地支持大量细粒度的对象。\n\n+ 享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的实例来表示数据。如果能发现这些实例除了几个参数基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数类移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度的地减少单个实例的数目。\n\n+ 使用：\n    + 如果一个应用程序是用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；\n    + 还有就是对象的大多数状态可以是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。\n\n## 第二十七章 解释器模式\n\n![explain](/img/designpatterns/explain.jpg)\n\n+ 解释器模式(interpreter)：给定一个语言，定义它的一种文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n+ 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n\n+ 使用：通常当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象的语法树时，可使用解释器模式。\n\n+ 好处：容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体相似，这些类都易于直接编写。\n\n## 第二十八章 访问者模式\n\n![visitor](/img/designpatterns/visitor.jpg)\n\n+ 访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n+ 适合数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。\n\n+ 访问者模式的目的是要把处理从数据结构分离出来。如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式是比较适合的，因为访问者模式使得算法操作的增加变得容易。\n\n+ 优点：增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。\n+ 缺点：使得增加新的数据结构变得困难。","source":"_posts/设计模式.md","raw":"---\ntitle: 设计模式\ndate: 2021-06-12 21:56:33\ntop_img: /img/cover/designpattern.jpg\ncover: /img/cover/designpattern.jpg\ntags: [设计模式]\n---\n# 设计模式\n参考书目：《大话设计模式》、《软件工程原理》\n\n## 面向对象\n+ 四大好处：可维护、可扩展、可复用、灵活性好\n\n## 第一章 简单工厂模式\n\n![simple](/img/designpatterns/simple.jpg)\n\n+ 所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。\n    + 通过创建反射类，结合配置文件将具体要创建的类的选择过程从工厂类的代码中解放出来，反射类中也没有switch，而是在配置文件中一一对应好，这样客户端只要传入要操作的类型就可以了。\n    + 这样工厂代码彻底实现了开——闭原则，即使要增加新的类也不需要修改工厂类。\n\n## 第二章 策略模式\n\n![strategy](/img/designpatterns/strategy.jpg)\n\n+ 策略模式：它定义了算法家族，分别封装起来，让他们之间可以互相调换，此模式让算法的变化，不会影响到使用算法的客户。\n\n+ 策略模式是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的方法，减少了各类算法类与使用算法类之间的耦合。\n\n+ 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取除这些算法中的公共功能\n+ 策略模式简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。\n\n## 第三章 单一职责原则\n+ 单一职责原则SRP：就一个类而言，应该仅有一个引起它变化的原因。\n\n+ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。\n\n+ 如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。\n\n## 第四章 开放——封闭原则(OCP)\n+ 开放——封闭原则，The Open-Closed Principle，简称OCP，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改\n    + 对于扩展是开放的，对于更改是封闭的\n\n+ 软件设计要容易维护又不容易出问题的好办法，就是多扩展，少修改。\n\n+ 面对需求，对程序的修改是通过增加新代码进行的，而不是更改现有的代码\n\n## 第五章 依赖倒转原则\n+ 依赖倒转原则：\n    + 抽象不应该依赖细节，细节应该依赖于抽象；即针对接口编程，不要对实现编程；\n    + 高层模块不应该依赖底层模块，两个都应该依赖抽象\n\n+ 里氏代换原则：在软件里，把父类都替换成他们的子类，程序的行为没有变化；\n    + 如果一个软件实体使用的是父类，那么程序无法区分子类和父类\n    + 注意：这里子类继承复用父类，显然父类的所有功能子类必须有，子类特有的子类再去添加；\n\n## 第六章 装饰模式\n\n![](/img/designpatterns/decorator.jpg)\n\n+ 装饰模式：动态的给一些类添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活；\n\n## 第七章 代理模式\n\n![proxy](/img/designpatterns/proxy.jpg)\n\n+ 代理模式：为其他对象提供一种代理以控制对这个对象的访问；\n\n+ 应用场合：\n    1. 远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实；\n    2. 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真是对象；\n    3. 安全代理，用来控制真实对象访问时的权限；\n    4. 智能指引，是指当调用真实的对象时，代理处理另外一些事；\n        + 如计算真实对象的引用次数，通过代理在访问一个对象时附加一些内务处理；\n\n## 第八章 工厂方法模式\n\n![factorymethod](/img/designpatterns/factorymethod.jpg)\n\n+ 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类；\n\n+ 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。\n    + 但是对工厂类的修改违背了开——闭原则\n\n+ 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是改客户端。\n    + 工厂方法模式既克服了简单工厂违背开放——封闭原则的缺点，又保持了封装对象过程的优点；\n\n## 第九章 原型模式\n\n![](/img/designpatterns/prototype.jpg)\n\n+ 原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象\n\n+ 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。\n\n+ 一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又是对性能大大的提高；\n    + 不是重新初始化对象，而是动态的获取对象运行时的状态；\n\n## 第十章 模板方法模式\n\n![template](/img/designpatterns/template.jpg)\n\n+ 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n+ 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。\n\n+ 通过把不变行为搬移到父类，去除子类中的重复代码来体现它的优势。\n+ 模板方法模式提供了一个很好的代码复用平台。\n\n## 第十一章 迪米特法则\n+ 迪米特法则(LoD)，也叫最少知识原则。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发这个调用。\n\n+ 首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。\n\n+ 其根本思想，是强调了类之间的松耦合。\n    + 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。\n\n## 第十二章 外观模式\n\n![facade](/img/designpatterns/facade.jpg)\n\n+ 外观模式：为了系统中的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n+ 何时使用\n    1. 在设计初期，应该要有意识地将不同的两个层分离，为复杂的子系统提供一个简单的接口，使得耦合大大降低。\n    2. 在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂。\n        + 大多数的模式使用时会产生大量很小的类，对于外部调用很是麻烦；于是增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。\n    3. 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，这时可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。\n\n+ 理解：被外观隐藏的多个子系统可以是任意的，相互可以没有任何关系，侧重点在于，外观模式隐藏了子系统之间的相互调用，而是提供一组接口给外部调用。满足了松耦合的要求，也体现了迪米特法则。\n\n## 第十三章 建造者模式\n![builder](/img/designpatterns/builder.jpg)\n\n+ 建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n    + 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n+ 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。\n+ 理解：这里强调的是过程，比如程序中一组特定顺序的过程。\n\n## 第十四章 观察者模式\n\n![observer](/img/designpatterns/observer.jpg)\n\n+ 观察者模式：又称发布——订阅(Publish/Subscribe)模式，它定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。\n\n+ 根据开——闭原则和依赖倒转原则，在这个模式中，通知者和监听者都是一个抽象父类，表示一个对外的抽象接口，而其子类都是一个个实体，因此对外封闭了实现细节，两边都只需要针对接口编程。\n\n+ 观察者模式很适合用于同时修改很多对象的状态的情景，尤其是不知道具体有多少对象的时候。\n\n+ 观察者模式实际上就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。\n\n+ 当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。\n\n## 第十五章 抽象工厂模式\n\n![abstractfactory](/img/designpatterns/abstractfactory.jpg)\n\n+ 抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n+ 这时候每个具体工厂生产的是一个完整的产品簇。抽象工厂方法的好处在于，易于交换产品系列，由于具体工厂类的初始化只有一行代码，因此将其修改之后，后面生产的产品也都完全改变。这就使得改变一个应用的具体工厂变的非常容易。\n+ 它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。\n+ 反射：\n+ 所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。\n\n## 第十六章 状态模式\n\n![state](/img/designpatterns/state.jpg)\n\n+ 状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n+ 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简单化。\n\n+ 好处：\n    1. 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。\n        + 将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。(继承于同一个State父类，并通过共同的handle函数进行状态切换)\n    2. 消除了庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State子类之间，来减少相互间的依赖。\n\n+ 何时使用：当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变他的行为时，就可以考虑使用状态模式了。\n\n## 第十七章 适配器模式\n\n![adapter](/img/designpatterns/adapter.jpg)\n\n+ 适配器模式(Adapter)：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n+ 使用：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。\n    + 使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。\n    + 两个类所做的事情相同或相似，但是具有不同的接口时要是用它。\n    + 双方都不太容易修改的时候在使用适配器模式。\n\n+ 主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。\n\n## 第十八章 备忘录模式\n\n![memento](/img/designpatterns/memento.jpg)\n\n+ 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n\n+ 使用：Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。\n    + 如：如果在某个系统使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。\n\n+ 使用备忘录模式可以把复杂的对象内部信息对其他的对象屏蔽起来。\n+ 当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。\n\n## 第十九章 组合模式\n\n![composite](/img/designpatterns/composite.jpg)\n\n+ 组合模式(Composite)：将对象组合成树形结构以表示’部分-整体‘的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n+ 整体与部分可以被一致对待\n\n+ 透明方式：就是在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。\n+ 安全方式：在Component类中不去生命Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法。由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。\n\n+ 使用：\n    1. 需求中是体现部分与整体层次的结构时\n    2. 希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。\n\n## 第二十章 迭代器模式\n\n![iterator](/img/designpatterns/iterator.jpg)\n\n+ 迭代器模式(Iterator)：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。\n\n+ 为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。\n\n+ 使用\n    + 需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候\n    + 对聚集有多种方式遍历时\n\n## 第二十一章 单例模式\n\n![singleton](/img/designpatterns/singleton.jpg)\n\n+ 单例模式(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n+ 让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且他可以提供一个访问该实例的方法。\n\n+ 所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。\n\n+ 好处：单例模式因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。\n\n## 合成/聚合复用原则\n+ 合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承。\n    + 聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；\n    + 合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的周期一样。\n\n+ 好处：\n    + 优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。\n\n## 第二十二章 桥接模式\n\n![qiaojie](/img/designpatterns/qiaojie.jpg)\n\n+ 桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。\n    + 实现指的是抽象类和它的派生类用来实现自己的对象。\n    + 实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少他们之间的耦合。\n\n## 第二十三章 命令模式\n\n![invoker](/img/designpatterns/invoker.jpg)\n\n+ 命令模式(Command)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。\n\n+ 命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。\n\n+ 作用：\n    1. 它能较容易地设计一个命令队列；\n    2. 在需要的情况下，可以较容易地将命令记入日志；\n    3. 允许请求的一方决定是否要否决请求；\n    4. 可以容易地实现对请求的撤销和重做；\n    5. 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。\n\n+ 敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构首先这个模式并不难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。\n\n## 第二十四章 职责链模式\n\n![successor](/img/designpatterns/successor.jpg)\n\n+ 职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n+ 当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。\n\n+ 接受者和发送者都没有对方的明确信息，且链中的对象自己也不知道链的结构。结果是职责链可简化为对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有候选接受者的引用————大大降低了耦合度。\n\n+ 可以随时增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性\n\n## 第二十五章 中介者模式\n\n![meditator](/img/designpatterns/meditator.jpg)\n\n+ 中介者模式(Mediator)：用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显式地相互调用，从而使其耦合松散，而且可以独立地改变他们之间的交互。\n\n+ 尽管将一个系统分割成许多对象通常可以增加其复用性，但是对象间相互连接的激增又会降低其可用性了。\n    + 大量的链接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就是困难了。\n\n+ 优点：\n    + 减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator；\n    + 由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。\n+ 缺点：\n    + 由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。\n\n+ 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。\n\n## 第二十六章 享元模式\n\n![flyweight](/img/designpatterns/flyweight.jpg)\n\n+ 享元模式(Flyweight)：运用共享技术有效地支持大量细粒度的对象。\n\n+ 享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的实例来表示数据。如果能发现这些实例除了几个参数基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数类移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度的地减少单个实例的数目。\n\n+ 使用：\n    + 如果一个应用程序是用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；\n    + 还有就是对象的大多数状态可以是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。\n\n## 第二十七章 解释器模式\n\n![explain](/img/designpatterns/explain.jpg)\n\n+ 解释器模式(interpreter)：给定一个语言，定义它的一种文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n+ 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n\n+ 使用：通常当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象的语法树时，可使用解释器模式。\n\n+ 好处：容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体相似，这些类都易于直接编写。\n\n## 第二十八章 访问者模式\n\n![visitor](/img/designpatterns/visitor.jpg)\n\n+ 访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n+ 适合数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。\n\n+ 访问者模式的目的是要把处理从数据结构分离出来。如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式是比较适合的，因为访问者模式使得算法操作的增加变得容易。\n\n+ 优点：增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。\n+ 缺点：使得增加新的数据结构变得困难。","slug":"设计模式","published":1,"updated":"2022-03-25T12:22:17.119Z","_id":"ckpttxbzv0001gstp2r0tfy0k","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>参考书目：《大话设计模式》、《软件工程原理》</p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><ul>\n<li>四大好处：可维护、可扩展、可复用、灵活性好</li>\n</ul>\n<h2 id=\"第一章-简单工厂模式\"><a href=\"#第一章-简单工厂模式\" class=\"headerlink\" title=\"第一章 简单工厂模式\"></a>第一章 简单工厂模式</h2><p><img src=\"/img/designpatterns/simple.jpg\" alt=\"simple\"></p>\n<ul>\n<li>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。<ul>\n<li>通过创建反射类，结合配置文件将具体要创建的类的选择过程从工厂类的代码中解放出来，反射类中也没有switch，而是在配置文件中一一对应好，这样客户端只要传入要操作的类型就可以了。</li>\n<li>这样工厂代码彻底实现了开——闭原则，即使要增加新的类也不需要修改工厂类。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章-策略模式\"><a href=\"#第二章-策略模式\" class=\"headerlink\" title=\"第二章 策略模式\"></a>第二章 策略模式</h2><p><img src=\"/img/designpatterns/strategy.jpg\" alt=\"strategy\"></p>\n<ul>\n<li><p>策略模式：它定义了算法家族，分别封装起来，让他们之间可以互相调换，此模式让算法的变化，不会影响到使用算法的客户。</p>\n</li>\n<li><p>策略模式是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的方法，减少了各类算法类与使用算法类之间的耦合。</p>\n</li>\n<li><p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取除这些算法中的公共功能</p>\n</li>\n<li>策略模式简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。</li>\n</ul>\n<h2 id=\"第三章-单一职责原则\"><a href=\"#第三章-单一职责原则\" class=\"headerlink\" title=\"第三章 单一职责原则\"></a>第三章 单一职责原则</h2><ul>\n<li><p>单一职责原则SRP：就一个类而言，应该仅有一个引起它变化的原因。</p>\n</li>\n<li><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。</p>\n</li>\n<li><p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n</ul>\n<h2 id=\"第四章-开放——封闭原则-OCP\"><a href=\"#第四章-开放——封闭原则-OCP\" class=\"headerlink\" title=\"第四章 开放——封闭原则(OCP)\"></a>第四章 开放——封闭原则(OCP)</h2><ul>\n<li><p>开放——封闭原则，The Open-Closed Principle，简称OCP，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改</p>\n<ul>\n<li>对于扩展是开放的，对于更改是封闭的</li>\n</ul>\n</li>\n<li><p>软件设计要容易维护又不容易出问题的好办法，就是多扩展，少修改。</p>\n</li>\n<li><p>面对需求，对程序的修改是通过增加新代码进行的，而不是更改现有的代码</p>\n</li>\n</ul>\n<h2 id=\"第五章-依赖倒转原则\"><a href=\"#第五章-依赖倒转原则\" class=\"headerlink\" title=\"第五章 依赖倒转原则\"></a>第五章 依赖倒转原则</h2><ul>\n<li><p>依赖倒转原则：</p>\n<ul>\n<li>抽象不应该依赖细节，细节应该依赖于抽象；即针对接口编程，不要对实现编程；</li>\n<li>高层模块不应该依赖底层模块，两个都应该依赖抽象</li>\n</ul>\n</li>\n<li><p>里氏代换原则：在软件里，把父类都替换成他们的子类，程序的行为没有变化；</p>\n<ul>\n<li>如果一个软件实体使用的是父类，那么程序无法区分子类和父类</li>\n<li>注意：这里子类继承复用父类，显然父类的所有功能子类必须有，子类特有的子类再去添加；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六章-装饰模式\"><a href=\"#第六章-装饰模式\" class=\"headerlink\" title=\"第六章 装饰模式\"></a>第六章 装饰模式</h2><p><img src=\"/img/designpatterns/decorator.jpg\" alt=\"\"></p>\n<ul>\n<li>装饰模式：动态的给一些类添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活；</li>\n</ul>\n<h2 id=\"第七章-代理模式\"><a href=\"#第七章-代理模式\" class=\"headerlink\" title=\"第七章 代理模式\"></a>第七章 代理模式</h2><p><img src=\"/img/designpatterns/proxy.jpg\" alt=\"proxy\"></p>\n<ul>\n<li><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问；</p>\n</li>\n<li><p>应用场合：</p>\n<ol>\n<li>远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实；</li>\n<li>虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真是对象；</li>\n<li>安全代理，用来控制真实对象访问时的权限；</li>\n<li>智能指引，是指当调用真实的对象时，代理处理另外一些事；<ul>\n<li>如计算真实对象的引用次数，通过代理在访问一个对象时附加一些内务处理；</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"第八章-工厂方法模式\"><a href=\"#第八章-工厂方法模式\" class=\"headerlink\" title=\"第八章 工厂方法模式\"></a>第八章 工厂方法模式</h2><p><img src=\"/img/designpatterns/factorymethod.jpg\" alt=\"factorymethod\"></p>\n<ul>\n<li><p>工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类；</p>\n</li>\n<li><p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p>\n<ul>\n<li>但是对工厂类的修改违背了开——闭原则</li>\n</ul>\n</li>\n<li><p>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是改客户端。</p>\n<ul>\n<li>工厂方法模式既克服了简单工厂违背开放——封闭原则的缺点，又保持了封装对象过程的优点；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第九章-原型模式\"><a href=\"#第九章-原型模式\" class=\"headerlink\" title=\"第九章 原型模式\"></a>第九章 原型模式</h2><p><img src=\"/img/designpatterns/prototype.jpg\" alt=\"\"></p>\n<ul>\n<li><p>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>\n</li>\n<li><p>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。</p>\n</li>\n<li><p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又是对性能大大的提高；</p>\n<ul>\n<li>不是重新初始化对象，而是动态的获取对象运行时的状态；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十章-模板方法模式\"><a href=\"#第十章-模板方法模式\" class=\"headerlink\" title=\"第十章 模板方法模式\"></a>第十章 模板方法模式</h2><p><img src=\"/img/designpatterns/template.jpg\" alt=\"template\"></p>\n<ul>\n<li><p>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n</li>\n<li><p>当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。</p>\n</li>\n<li><p>通过把不变行为搬移到父类，去除子类中的重复代码来体现它的优势。</p>\n</li>\n<li>模板方法模式提供了一个很好的代码复用平台。</li>\n</ul>\n<h2 id=\"第十一章-迪米特法则\"><a href=\"#第十一章-迪米特法则\" class=\"headerlink\" title=\"第十一章 迪米特法则\"></a>第十一章 迪米特法则</h2><ul>\n<li><p>迪米特法则(LoD)，也叫最少知识原则。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发这个调用。</p>\n</li>\n<li><p>首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p>\n</li>\n<li><p>其根本思想，是强调了类之间的松耦合。</p>\n<ul>\n<li>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十二章-外观模式\"><a href=\"#第十二章-外观模式\" class=\"headerlink\" title=\"第十二章 外观模式\"></a>第十二章 外观模式</h2><p><img src=\"/img/designpatterns/facade.jpg\" alt=\"facade\"></p>\n<ul>\n<li><p>外观模式：为了系统中的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>\n</li>\n<li><p>何时使用</p>\n<ol>\n<li>在设计初期，应该要有意识地将不同的两个层分离，为复杂的子系统提供一个简单的接口，使得耦合大大降低。</li>\n<li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂。<ul>\n<li>大多数的模式使用时会产生大量很小的类，对于外部调用很是麻烦；于是增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。</li>\n</ul>\n</li>\n<li>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，这时可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</li>\n</ol>\n</li>\n<li><p>理解：被外观隐藏的多个子系统可以是任意的，相互可以没有任何关系，侧重点在于，外观模式隐藏了子系统之间的相互调用，而是提供一组接口给外部调用。满足了松耦合的要求，也体现了迪米特法则。</p>\n</li>\n</ul>\n<h2 id=\"第十三章-建造者模式\"><a href=\"#第十三章-建造者模式\" class=\"headerlink\" title=\"第十三章 建造者模式\"></a>第十三章 建造者模式</h2><p><img src=\"/img/designpatterns/builder.jpg\" alt=\"builder\"></p>\n<ul>\n<li>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<ul>\n<li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>\n</ul>\n</li>\n<li>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。</li>\n<li>理解：这里强调的是过程，比如程序中一组特定顺序的过程。</li>\n</ul>\n<h2 id=\"第十四章-观察者模式\"><a href=\"#第十四章-观察者模式\" class=\"headerlink\" title=\"第十四章 观察者模式\"></a>第十四章 观察者模式</h2><p><img src=\"/img/designpatterns/observer.jpg\" alt=\"observer\"></p>\n<ul>\n<li><p>观察者模式：又称发布——订阅(Publish/Subscribe)模式，它定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>\n</li>\n<li><p>根据开——闭原则和依赖倒转原则，在这个模式中，通知者和监听者都是一个抽象父类，表示一个对外的抽象接口，而其子类都是一个个实体，因此对外封闭了实现细节，两边都只需要针对接口编程。</p>\n</li>\n<li><p>观察者模式很适合用于同时修改很多对象的状态的情景，尤其是不知道具体有多少对象的时候。</p>\n</li>\n<li><p>观察者模式实际上就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。</p>\n</li>\n<li><p>当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>\n</li>\n</ul>\n<h2 id=\"第十五章-抽象工厂模式\"><a href=\"#第十五章-抽象工厂模式\" class=\"headerlink\" title=\"第十五章 抽象工厂模式\"></a>第十五章 抽象工厂模式</h2><p><img src=\"/img/designpatterns/abstractfactory.jpg\" alt=\"abstractfactory\"></p>\n<ul>\n<li>抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>\n<li>这时候每个具体工厂生产的是一个完整的产品簇。抽象工厂方法的好处在于，易于交换产品系列，由于具体工厂类的初始化只有一行代码，因此将其修改之后，后面生产的产品也都完全改变。这就使得改变一个应用的具体工厂变的非常容易。</li>\n<li>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。</li>\n<li>反射：</li>\n<li>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。</li>\n</ul>\n<h2 id=\"第十六章-状态模式\"><a href=\"#第十六章-状态模式\" class=\"headerlink\" title=\"第十六章 状态模式\"></a>第十六章 状态模式</h2><p><img src=\"/img/designpatterns/state.jpg\" alt=\"state\"></p>\n<ul>\n<li><p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>\n</li>\n<li><p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简单化。</p>\n</li>\n<li><p>好处：</p>\n<ol>\n<li>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。<ul>\n<li>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。(继承于同一个State父类，并通过共同的handle函数进行状态切换)</li>\n</ul>\n</li>\n<li>消除了庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State子类之间，来减少相互间的依赖。</li>\n</ol>\n</li>\n<li><p>何时使用：当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变他的行为时，就可以考虑使用状态模式了。</p>\n</li>\n</ul>\n<h2 id=\"第十七章-适配器模式\"><a href=\"#第十七章-适配器模式\" class=\"headerlink\" title=\"第十七章 适配器模式\"></a>第十七章 适配器模式</h2><p><img src=\"/img/designpatterns/adapter.jpg\" alt=\"adapter\"></p>\n<ul>\n<li><p>适配器模式(Adapter)：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\n</li>\n<li><p>使用：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。</p>\n<ul>\n<li>使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。</li>\n<li>两个类所做的事情相同或相似，但是具有不同的接口时要是用它。</li>\n<li>双方都不太容易修改的时候在使用适配器模式。</li>\n</ul>\n</li>\n<li><p>主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。</p>\n</li>\n</ul>\n<h2 id=\"第十八章-备忘录模式\"><a href=\"#第十八章-备忘录模式\" class=\"headerlink\" title=\"第十八章 备忘录模式\"></a>第十八章 备忘录模式</h2><p><img src=\"/img/designpatterns/memento.jpg\" alt=\"memento\"></p>\n<ul>\n<li><p>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>\n</li>\n<li><p>使用：Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</p>\n<ul>\n<li>如：如果在某个系统使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。</li>\n</ul>\n</li>\n<li><p>使用备忘录模式可以把复杂的对象内部信息对其他的对象屏蔽起来。</p>\n</li>\n<li>当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li>\n</ul>\n<h2 id=\"第十九章-组合模式\"><a href=\"#第十九章-组合模式\" class=\"headerlink\" title=\"第十九章 组合模式\"></a>第十九章 组合模式</h2><p><img src=\"/img/designpatterns/composite.jpg\" alt=\"composite\"></p>\n<ul>\n<li><p>组合模式(Composite)：将对象组合成树形结构以表示’部分-整体‘的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n</li>\n<li><p>整体与部分可以被一致对待</p>\n</li>\n<li><p>透明方式：就是在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。</p>\n</li>\n<li><p>安全方式：在Component类中不去生命Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法。由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</p>\n</li>\n<li><p>使用：</p>\n<ol>\n<li>需求中是体现部分与整体层次的结构时</li>\n<li>希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"第二十章-迭代器模式\"><a href=\"#第二十章-迭代器模式\" class=\"headerlink\" title=\"第二十章 迭代器模式\"></a>第二十章 迭代器模式</h2><p><img src=\"/img/designpatterns/iterator.jpg\" alt=\"iterator\"></p>\n<ul>\n<li><p>迭代器模式(Iterator)：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。</p>\n</li>\n<li><p>为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。</p>\n</li>\n<li><p>使用</p>\n<ul>\n<li>需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候</li>\n<li>对聚集有多种方式遍历时</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十一章-单例模式\"><a href=\"#第二十一章-单例模式\" class=\"headerlink\" title=\"第二十一章 单例模式\"></a>第二十一章 单例模式</h2><p><img src=\"/img/designpatterns/singleton.jpg\" alt=\"singleton\"></p>\n<ul>\n<li><p>单例模式(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n</li>\n<li><p>让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且他可以提供一个访问该实例的方法。</p>\n</li>\n<li><p>所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。</p>\n</li>\n<li><p>好处：单例模式因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</p>\n</li>\n</ul>\n<h2 id=\"合成-聚合复用原则\"><a href=\"#合成-聚合复用原则\" class=\"headerlink\" title=\"合成/聚合复用原则\"></a>合成/聚合复用原则</h2><ul>\n<li><p>合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承。</p>\n<ul>\n<li>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；</li>\n<li>合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的周期一样。</li>\n</ul>\n</li>\n<li><p>好处：</p>\n<ul>\n<li>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十二章-桥接模式\"><a href=\"#第二十二章-桥接模式\" class=\"headerlink\" title=\"第二十二章 桥接模式\"></a>第二十二章 桥接模式</h2><p><img src=\"/img/designpatterns/qiaojie.jpg\" alt=\"qiaojie\"></p>\n<ul>\n<li>桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<ul>\n<li>实现指的是抽象类和它的派生类用来实现自己的对象。</li>\n<li>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少他们之间的耦合。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十三章-命令模式\"><a href=\"#第二十三章-命令模式\" class=\"headerlink\" title=\"第二十三章 命令模式\"></a>第二十三章 命令模式</h2><p><img src=\"/img/designpatterns/invoker.jpg\" alt=\"invoker\"></p>\n<ul>\n<li><p>命令模式(Command)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>\n</li>\n<li><p>命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</p>\n</li>\n<li><p>作用：</p>\n<ol>\n<li>它能较容易地设计一个命令队列；</li>\n<li>在需要的情况下，可以较容易地将命令记入日志；</li>\n<li>允许请求的一方决定是否要否决请求；</li>\n<li>可以容易地实现对请求的撤销和重做；</li>\n<li>由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。</li>\n</ol>\n</li>\n<li><p>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构首先这个模式并不难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。</p>\n</li>\n</ul>\n<h2 id=\"第二十四章-职责链模式\"><a href=\"#第二十四章-职责链模式\" class=\"headerlink\" title=\"第二十四章 职责链模式\"></a>第二十四章 职责链模式</h2><p><img src=\"/img/designpatterns/successor.jpg\" alt=\"successor\"></p>\n<ul>\n<li><p>职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>\n</li>\n<li><p>当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p>\n</li>\n<li><p>接受者和发送者都没有对方的明确信息，且链中的对象自己也不知道链的结构。结果是职责链可简化为对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有候选接受者的引用————大大降低了耦合度。</p>\n</li>\n<li><p>可以随时增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性</p>\n</li>\n</ul>\n<h2 id=\"第二十五章-中介者模式\"><a href=\"#第二十五章-中介者模式\" class=\"headerlink\" title=\"第二十五章 中介者模式\"></a>第二十五章 中介者模式</h2><p><img src=\"/img/designpatterns/meditator.jpg\" alt=\"meditator\"></p>\n<ul>\n<li><p>中介者模式(Mediator)：用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显式地相互调用，从而使其耦合松散，而且可以独立地改变他们之间的交互。</p>\n</li>\n<li><p>尽管将一个系统分割成许多对象通常可以增加其复用性，但是对象间相互连接的激增又会降低其可用性了。</p>\n<ul>\n<li>大量的链接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就是困难了。</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator；</li>\n<li>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</li>\n</ul>\n</li>\n<li><p>中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。</p>\n</li>\n</ul>\n<h2 id=\"第二十六章-享元模式\"><a href=\"#第二十六章-享元模式\" class=\"headerlink\" title=\"第二十六章 享元模式\"></a>第二十六章 享元模式</h2><p><img src=\"/img/designpatterns/flyweight.jpg\" alt=\"flyweight\"></p>\n<ul>\n<li><p>享元模式(Flyweight)：运用共享技术有效地支持大量细粒度的对象。</p>\n</li>\n<li><p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的实例来表示数据。如果能发现这些实例除了几个参数基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数类移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度的地减少单个实例的数目。</p>\n</li>\n<li><p>使用：</p>\n<ul>\n<li>如果一个应用程序是用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；</li>\n<li>还有就是对象的大多数状态可以是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十七章-解释器模式\"><a href=\"#第二十七章-解释器模式\" class=\"headerlink\" title=\"第二十七章 解释器模式\"></a>第二十七章 解释器模式</h2><p><img src=\"/img/designpatterns/explain.jpg\" alt=\"explain\"></p>\n<ul>\n<li><p>解释器模式(interpreter)：给定一个语言，定义它的一种文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>\n</li>\n<li><p>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>\n</li>\n<li><p>使用：通常当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象的语法树时，可使用解释器模式。</p>\n</li>\n<li><p>好处：容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体相似，这些类都易于直接编写。</p>\n</li>\n</ul>\n<h2 id=\"第二十八章-访问者模式\"><a href=\"#第二十八章-访问者模式\" class=\"headerlink\" title=\"第二十八章 访问者模式\"></a>第二十八章 访问者模式</h2><p><img src=\"/img/designpatterns/visitor.jpg\" alt=\"visitor\"></p>\n<ul>\n<li><p>访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>\n</li>\n<li><p>适合数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。</p>\n</li>\n<li><p>访问者模式的目的是要把处理从数据结构分离出来。如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式是比较适合的，因为访问者模式使得算法操作的增加变得容易。</p>\n</li>\n<li><p>优点：增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。</p>\n</li>\n<li>缺点：使得增加新的数据结构变得困难。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><p>参考书目：《大话设计模式》、《软件工程原理》</p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><ul>\n<li>四大好处：可维护、可扩展、可复用、灵活性好</li>\n</ul>\n<h2 id=\"第一章-简单工厂模式\"><a href=\"#第一章-简单工厂模式\" class=\"headerlink\" title=\"第一章 简单工厂模式\"></a>第一章 简单工厂模式</h2><p><img src=\"/img/designpatterns/simple.jpg\" alt=\"simple\"></p>\n<ul>\n<li>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。<ul>\n<li>通过创建反射类，结合配置文件将具体要创建的类的选择过程从工厂类的代码中解放出来，反射类中也没有switch，而是在配置文件中一一对应好，这样客户端只要传入要操作的类型就可以了。</li>\n<li>这样工厂代码彻底实现了开——闭原则，即使要增加新的类也不需要修改工厂类。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二章-策略模式\"><a href=\"#第二章-策略模式\" class=\"headerlink\" title=\"第二章 策略模式\"></a>第二章 策略模式</h2><p><img src=\"/img/designpatterns/strategy.jpg\" alt=\"strategy\"></p>\n<ul>\n<li><p>策略模式：它定义了算法家族，分别封装起来，让他们之间可以互相调换，此模式让算法的变化，不会影响到使用算法的客户。</p>\n</li>\n<li><p>策略模式是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的方法，减少了各类算法类与使用算法类之间的耦合。</p>\n</li>\n<li><p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取除这些算法中的公共功能</p>\n</li>\n<li>策略模式简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。</li>\n</ul>\n<h2 id=\"第三章-单一职责原则\"><a href=\"#第三章-单一职责原则\" class=\"headerlink\" title=\"第三章 单一职责原则\"></a>第三章 单一职责原则</h2><ul>\n<li><p>单一职责原则SRP：就一个类而言，应该仅有一个引起它变化的原因。</p>\n</li>\n<li><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。</p>\n</li>\n<li><p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>\n</li>\n</ul>\n<h2 id=\"第四章-开放——封闭原则-OCP\"><a href=\"#第四章-开放——封闭原则-OCP\" class=\"headerlink\" title=\"第四章 开放——封闭原则(OCP)\"></a>第四章 开放——封闭原则(OCP)</h2><ul>\n<li><p>开放——封闭原则，The Open-Closed Principle，简称OCP，是说软件实体（类、模块、函数等等）应该可以扩展，但是不可修改</p>\n<ul>\n<li>对于扩展是开放的，对于更改是封闭的</li>\n</ul>\n</li>\n<li><p>软件设计要容易维护又不容易出问题的好办法，就是多扩展，少修改。</p>\n</li>\n<li><p>面对需求，对程序的修改是通过增加新代码进行的，而不是更改现有的代码</p>\n</li>\n</ul>\n<h2 id=\"第五章-依赖倒转原则\"><a href=\"#第五章-依赖倒转原则\" class=\"headerlink\" title=\"第五章 依赖倒转原则\"></a>第五章 依赖倒转原则</h2><ul>\n<li><p>依赖倒转原则：</p>\n<ul>\n<li>抽象不应该依赖细节，细节应该依赖于抽象；即针对接口编程，不要对实现编程；</li>\n<li>高层模块不应该依赖底层模块，两个都应该依赖抽象</li>\n</ul>\n</li>\n<li><p>里氏代换原则：在软件里，把父类都替换成他们的子类，程序的行为没有变化；</p>\n<ul>\n<li>如果一个软件实体使用的是父类，那么程序无法区分子类和父类</li>\n<li>注意：这里子类继承复用父类，显然父类的所有功能子类必须有，子类特有的子类再去添加；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第六章-装饰模式\"><a href=\"#第六章-装饰模式\" class=\"headerlink\" title=\"第六章 装饰模式\"></a>第六章 装饰模式</h2><p><img src=\"/img/designpatterns/decorator.jpg\" alt=\"\"></p>\n<ul>\n<li>装饰模式：动态的给一些类添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活；</li>\n</ul>\n<h2 id=\"第七章-代理模式\"><a href=\"#第七章-代理模式\" class=\"headerlink\" title=\"第七章 代理模式\"></a>第七章 代理模式</h2><p><img src=\"/img/designpatterns/proxy.jpg\" alt=\"proxy\"></p>\n<ul>\n<li><p>代理模式：为其他对象提供一种代理以控制对这个对象的访问；</p>\n</li>\n<li><p>应用场合：</p>\n<ol>\n<li>远程代理，为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实；</li>\n<li>虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真是对象；</li>\n<li>安全代理，用来控制真实对象访问时的权限；</li>\n<li>智能指引，是指当调用真实的对象时，代理处理另外一些事；<ul>\n<li>如计算真实对象的引用次数，通过代理在访问一个对象时附加一些内务处理；</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"第八章-工厂方法模式\"><a href=\"#第八章-工厂方法模式\" class=\"headerlink\" title=\"第八章 工厂方法模式\"></a>第八章 工厂方法模式</h2><p><img src=\"/img/designpatterns/factorymethod.jpg\" alt=\"factorymethod\"></p>\n<ul>\n<li><p>工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类；</p>\n</li>\n<li><p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p>\n<ul>\n<li>但是对工厂类的修改违背了开——闭原则</li>\n</ul>\n</li>\n<li><p>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是改客户端。</p>\n<ul>\n<li>工厂方法模式既克服了简单工厂违背开放——封闭原则的缺点，又保持了封装对象过程的优点；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第九章-原型模式\"><a href=\"#第九章-原型模式\" class=\"headerlink\" title=\"第九章 原型模式\"></a>第九章 原型模式</h2><p><img src=\"/img/designpatterns/prototype.jpg\" alt=\"\"></p>\n<ul>\n<li><p>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>\n</li>\n<li><p>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。</p>\n</li>\n<li><p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。既隐藏了对象创建的细节，又是对性能大大的提高；</p>\n<ul>\n<li>不是重新初始化对象，而是动态的获取对象运行时的状态；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十章-模板方法模式\"><a href=\"#第十章-模板方法模式\" class=\"headerlink\" title=\"第十章 模板方法模式\"></a>第十章 模板方法模式</h2><p><img src=\"/img/designpatterns/template.jpg\" alt=\"template\"></p>\n<ul>\n<li><p>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n</li>\n<li><p>当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。</p>\n</li>\n<li><p>通过把不变行为搬移到父类，去除子类中的重复代码来体现它的优势。</p>\n</li>\n<li>模板方法模式提供了一个很好的代码复用平台。</li>\n</ul>\n<h2 id=\"第十一章-迪米特法则\"><a href=\"#第十一章-迪米特法则\" class=\"headerlink\" title=\"第十一章 迪米特法则\"></a>第十一章 迪米特法则</h2><ul>\n<li><p>迪米特法则(LoD)，也叫最少知识原则。如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发这个调用。</p>\n</li>\n<li><p>首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p>\n</li>\n<li><p>其根本思想，是强调了类之间的松耦合。</p>\n<ul>\n<li>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第十二章-外观模式\"><a href=\"#第十二章-外观模式\" class=\"headerlink\" title=\"第十二章 外观模式\"></a>第十二章 外观模式</h2><p><img src=\"/img/designpatterns/facade.jpg\" alt=\"facade\"></p>\n<ul>\n<li><p>外观模式：为了系统中的一组接口提供了一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>\n</li>\n<li><p>何时使用</p>\n<ol>\n<li>在设计初期，应该要有意识地将不同的两个层分离，为复杂的子系统提供一个简单的接口，使得耦合大大降低。</li>\n<li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂。<ul>\n<li>大多数的模式使用时会产生大量很小的类，对于外部调用很是麻烦；于是增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。</li>\n</ul>\n</li>\n<li>在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，这时可以为新系统开发一个外观Facade类，来提供设计粗糙或高度复杂的遗留代码的比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。</li>\n</ol>\n</li>\n<li><p>理解：被外观隐藏的多个子系统可以是任意的，相互可以没有任何关系，侧重点在于，外观模式隐藏了子系统之间的相互调用，而是提供一组接口给外部调用。满足了松耦合的要求，也体现了迪米特法则。</p>\n</li>\n</ul>\n<h2 id=\"第十三章-建造者模式\"><a href=\"#第十三章-建造者模式\" class=\"headerlink\" title=\"第十三章 建造者模式\"></a>第十三章 建造者模式</h2><p><img src=\"/img/designpatterns/builder.jpg\" alt=\"builder\"></p>\n<ul>\n<li>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<ul>\n<li>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li>\n</ul>\n</li>\n<li>建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。</li>\n<li>理解：这里强调的是过程，比如程序中一组特定顺序的过程。</li>\n</ul>\n<h2 id=\"第十四章-观察者模式\"><a href=\"#第十四章-观察者模式\" class=\"headerlink\" title=\"第十四章 观察者模式\"></a>第十四章 观察者模式</h2><p><img src=\"/img/designpatterns/observer.jpg\" alt=\"observer\"></p>\n<ul>\n<li><p>观察者模式：又称发布——订阅(Publish/Subscribe)模式，它定义了一种一对多的依赖关系，让多个观察对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>\n</li>\n<li><p>根据开——闭原则和依赖倒转原则，在这个模式中，通知者和监听者都是一个抽象父类，表示一个对外的抽象接口，而其子类都是一个个实体，因此对外封闭了实现细节，两边都只需要针对接口编程。</p>\n</li>\n<li><p>观察者模式很适合用于同时修改很多对象的状态的情景，尤其是不知道具体有多少对象的时候。</p>\n</li>\n<li><p>观察者模式实际上就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体。</p>\n</li>\n<li><p>当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>\n</li>\n</ul>\n<h2 id=\"第十五章-抽象工厂模式\"><a href=\"#第十五章-抽象工厂模式\" class=\"headerlink\" title=\"第十五章 抽象工厂模式\"></a>第十五章 抽象工厂模式</h2><p><img src=\"/img/designpatterns/abstractfactory.jpg\" alt=\"abstractfactory\"></p>\n<ul>\n<li>抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li>\n<li>这时候每个具体工厂生产的是一个完整的产品簇。抽象工厂方法的好处在于，易于交换产品系列，由于具体工厂类的初始化只有一行代码，因此将其修改之后，后面生产的产品也都完全改变。这就使得改变一个应用的具体工厂变的非常容易。</li>\n<li>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户端代码中。</li>\n<li>反射：</li>\n<li>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。</li>\n</ul>\n<h2 id=\"第十六章-状态模式\"><a href=\"#第十六章-状态模式\" class=\"headerlink\" title=\"第十六章 状态模式\"></a>第十六章 状态模式</h2><p><img src=\"/img/designpatterns/state.jpg\" alt=\"state\"></p>\n<ul>\n<li><p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>\n</li>\n<li><p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简单化。</p>\n</li>\n<li><p>好处：</p>\n<ol>\n<li>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。<ul>\n<li>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。(继承于同一个State父类，并通过共同的handle函数进行状态切换)</li>\n</ul>\n</li>\n<li>消除了庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State子类之间，来减少相互间的依赖。</li>\n</ol>\n</li>\n<li><p>何时使用：当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变他的行为时，就可以考虑使用状态模式了。</p>\n</li>\n</ul>\n<h2 id=\"第十七章-适配器模式\"><a href=\"#第十七章-适配器模式\" class=\"headerlink\" title=\"第十七章 适配器模式\"></a>第十七章 适配器模式</h2><p><img src=\"/img/designpatterns/adapter.jpg\" alt=\"adapter\"></p>\n<ul>\n<li><p>适配器模式(Adapter)：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\n</li>\n<li><p>使用：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。</p>\n<ul>\n<li>使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。</li>\n<li>两个类所做的事情相同或相似，但是具有不同的接口时要是用它。</li>\n<li>双方都不太容易修改的时候在使用适配器模式。</li>\n</ul>\n</li>\n<li><p>主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。</p>\n</li>\n</ul>\n<h2 id=\"第十八章-备忘录模式\"><a href=\"#第十八章-备忘录模式\" class=\"headerlink\" title=\"第十八章 备忘录模式\"></a>第十八章 备忘录模式</h2><p><img src=\"/img/designpatterns/memento.jpg\" alt=\"memento\"></p>\n<ul>\n<li><p>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>\n</li>\n<li><p>使用：Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</p>\n<ul>\n<li>如：如果在某个系统使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。</li>\n</ul>\n</li>\n<li><p>使用备忘录模式可以把复杂的对象内部信息对其他的对象屏蔽起来。</p>\n</li>\n<li>当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li>\n</ul>\n<h2 id=\"第十九章-组合模式\"><a href=\"#第十九章-组合模式\" class=\"headerlink\" title=\"第十九章 组合模式\"></a>第十九章 组合模式</h2><p><img src=\"/img/designpatterns/composite.jpg\" alt=\"composite\"></p>\n<ul>\n<li><p>组合模式(Composite)：将对象组合成树形结构以表示’部分-整体‘的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\n</li>\n<li><p>整体与部分可以被一致对待</p>\n</li>\n<li><p>透明方式：就是在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。</p>\n</li>\n<li><p>安全方式：在Component类中不去生命Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法。由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</p>\n</li>\n<li><p>使用：</p>\n<ol>\n<li>需求中是体现部分与整体层次的结构时</li>\n<li>希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"第二十章-迭代器模式\"><a href=\"#第二十章-迭代器模式\" class=\"headerlink\" title=\"第二十章 迭代器模式\"></a>第二十章 迭代器模式</h2><p><img src=\"/img/designpatterns/iterator.jpg\" alt=\"iterator\"></p>\n<ul>\n<li><p>迭代器模式(Iterator)：提供一种方法顺序访问一个聚合对象中各个元素，而不暴露该对象的内部表示。</p>\n</li>\n<li><p>为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。</p>\n</li>\n<li><p>使用</p>\n<ul>\n<li>需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候</li>\n<li>对聚集有多种方式遍历时</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十一章-单例模式\"><a href=\"#第二十一章-单例模式\" class=\"headerlink\" title=\"第二十一章 单例模式\"></a>第二十一章 单例模式</h2><p><img src=\"/img/designpatterns/singleton.jpg\" alt=\"singleton\"></p>\n<ul>\n<li><p>单例模式(Singleton)：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n</li>\n<li><p>让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且他可以提供一个访问该实例的方法。</p>\n</li>\n<li><p>所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。</p>\n</li>\n<li><p>好处：单例模式因为Singleton类封装它的唯一实例，这样它可以严格控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</p>\n</li>\n</ul>\n<h2 id=\"合成-聚合复用原则\"><a href=\"#合成-聚合复用原则\" class=\"headerlink\" title=\"合成/聚合复用原则\"></a>合成/聚合复用原则</h2><ul>\n<li><p>合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要使用类继承。</p>\n<ul>\n<li>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；</li>\n<li>合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的周期一样。</li>\n</ul>\n</li>\n<li><p>好处：</p>\n<ul>\n<li>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十二章-桥接模式\"><a href=\"#第二十二章-桥接模式\" class=\"headerlink\" title=\"第二十二章 桥接模式\"></a>第二十二章 桥接模式</h2><p><img src=\"/img/designpatterns/qiaojie.jpg\" alt=\"qiaojie\"></p>\n<ul>\n<li>桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<ul>\n<li>实现指的是抽象类和它的派生类用来实现自己的对象。</li>\n<li>实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少他们之间的耦合。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十三章-命令模式\"><a href=\"#第二十三章-命令模式\" class=\"headerlink\" title=\"第二十三章 命令模式\"></a>第二十三章 命令模式</h2><p><img src=\"/img/designpatterns/invoker.jpg\" alt=\"invoker\"></p>\n<ul>\n<li><p>命令模式(Command)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>\n</li>\n<li><p>命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</p>\n</li>\n<li><p>作用：</p>\n<ol>\n<li>它能较容易地设计一个命令队列；</li>\n<li>在需要的情况下，可以较容易地将命令记入日志；</li>\n<li>允许请求的一方决定是否要否决请求；</li>\n<li>可以容易地实现对请求的撤销和重做；</li>\n<li>由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。</li>\n</ol>\n</li>\n<li><p>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构首先这个模式并不难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。</p>\n</li>\n</ul>\n<h2 id=\"第二十四章-职责链模式\"><a href=\"#第二十四章-职责链模式\" class=\"headerlink\" title=\"第二十四章 职责链模式\"></a>第二十四章 职责链模式</h2><p><img src=\"/img/designpatterns/successor.jpg\" alt=\"successor\"></p>\n<ul>\n<li><p>职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>\n</li>\n<li><p>当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p>\n</li>\n<li><p>接受者和发送者都没有对方的明确信息，且链中的对象自己也不知道链的结构。结果是职责链可简化为对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有候选接受者的引用————大大降低了耦合度。</p>\n</li>\n<li><p>可以随时增加或修改处理一个请求的结构，增强了给对象指派职责的灵活性</p>\n</li>\n</ul>\n<h2 id=\"第二十五章-中介者模式\"><a href=\"#第二十五章-中介者模式\" class=\"headerlink\" title=\"第二十五章 中介者模式\"></a>第二十五章 中介者模式</h2><p><img src=\"/img/designpatterns/meditator.jpg\" alt=\"meditator\"></p>\n<ul>\n<li><p>中介者模式(Mediator)：用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显式地相互调用，从而使其耦合松散，而且可以独立地改变他们之间的交互。</p>\n</li>\n<li><p>尽管将一个系统分割成许多对象通常可以增加其复用性，但是对象间相互连接的激增又会降低其可用性了。</p>\n<ul>\n<li>大量的链接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就是困难了。</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator；</li>\n<li>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</li>\n</ul>\n</li>\n<li><p>中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。</p>\n</li>\n</ul>\n<h2 id=\"第二十六章-享元模式\"><a href=\"#第二十六章-享元模式\" class=\"headerlink\" title=\"第二十六章 享元模式\"></a>第二十六章 享元模式</h2><p><img src=\"/img/designpatterns/flyweight.jpg\" alt=\"flyweight\"></p>\n<ul>\n<li><p>享元模式(Flyweight)：运用共享技术有效地支持大量细粒度的对象。</p>\n</li>\n<li><p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的实例来表示数据。如果能发现这些实例除了几个参数基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数类移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度的地减少单个实例的数目。</p>\n</li>\n<li><p>使用：</p>\n<ul>\n<li>如果一个应用程序是用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；</li>\n<li>还有就是对象的大多数状态可以是外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二十七章-解释器模式\"><a href=\"#第二十七章-解释器模式\" class=\"headerlink\" title=\"第二十七章 解释器模式\"></a>第二十七章 解释器模式</h2><p><img src=\"/img/designpatterns/explain.jpg\" alt=\"explain\"></p>\n<ul>\n<li><p>解释器模式(interpreter)：给定一个语言，定义它的一种文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>\n</li>\n<li><p>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>\n</li>\n<li><p>使用：通常当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象的语法树时，可使用解释器模式。</p>\n</li>\n<li><p>好处：容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可以使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体相似，这些类都易于直接编写。</p>\n</li>\n</ul>\n<h2 id=\"第二十八章-访问者模式\"><a href=\"#第二十八章-访问者模式\" class=\"headerlink\" title=\"第二十八章 访问者模式\"></a>第二十八章 访问者模式</h2><p><img src=\"/img/designpatterns/visitor.jpg\" alt=\"visitor\"></p>\n<ul>\n<li><p>访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>\n</li>\n<li><p>适合数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。</p>\n</li>\n<li><p>访问者模式的目的是要把处理从数据结构分离出来。如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式是比较适合的，因为访问者模式使得算法操作的增加变得容易。</p>\n</li>\n<li><p>优点：增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。</p>\n</li>\n<li>缺点：使得增加新的数据结构变得困难。</li>\n</ul>\n"},{"title":"自动内存管理","date":"2022-03-27T05:35:18.000Z","top_img":"/img/cover/java_memory.webp","cover":"/img/cover/java_memory.webp","_content":"\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## Java内存区域\nJava虚拟机管理的内存包含以下几个运行时数据区域：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_memory.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时数据区\n    </div>\n</center>\n\n各运行时数据区域内容如下：\n+ **程序计数器（Program Counter Register）**：即线程执行字节码的行号指示器；\n    + 在JVM中每个线程都有一个，属于**线程私有**的资源\n    + 如果执行的是Java方法，那么计数器值是虚拟机字节码的指令地址；\n    + 如果执行的是本地(Native)方法，那么计数器值是空(Undefined)\n+ **Java虚拟机栈**：描述Java方法执行的线程内存模型；**线程私有**\n    + 当出现方法调用时，虚拟机会同步创建**栈帧(Stack Frame)**入栈；调用完毕时，栈帧出栈\n+ **本地方法栈（Native Method Stacks）**：与虚拟机栈所发挥的作用非常相似，本地方法栈是为虚拟机使用到的本地（Native）方法服务\n    + 本地方法可简单理解为Java程序调用的外部代码，如c++、python脚本等\n+ **Java堆（Java Heap）**：所有线程共享的一块内存区域，在虚拟机启动时创建，用来**存放对象实例**\n    + Java堆也是垃圾收集器管理的内存区域，对象的“朝生暮死”就在这里发，因此又叫“GC”堆\n+ **方法区（Method Area）**：与Java堆一样，是各个**线程共享**的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n+ **运行时常量池（Runtime Constant Pool）**：方法区的一部分，与已加载的类一一对应\n    + 常量池表(Constatnt Pool Table)是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中\n    + 运行时常量池中包含了多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。\n+ **直接内存（Direct Memory）**：不是虚拟机运行时数据区的一部分\n    + 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。\n\n### 运行时栈帧结构\nJava虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法 调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_stack_frame.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时栈帧结构\n    </div>\n</center>\n\n如上图，每一个栈帧都包括了**局部变量表**、**操作数栈**、**动态连接**、**方法返回地址**和一些额外的附加信息\n+ **局部变量表（Local Variables Table）**：用于存放方法参数和方法内部定义的局部变量\n    + 记录在方法的`Code`属性的`max_locals`数据项中\n    + 局部变量表的容量与变量槽（Variable Slot）为单位，变量槽的实际大小不固定，只是一种规范\n+ **操作数栈（Operand Stack）**：后入先出栈，最大深度记录在`Code`属性的`max_stacks`数据项中\n    + 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作；例如算术操作，会借助该栈完成计算\n+ **动态连接（Dynamic Linking）**：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接\n    + Class文件的常量池中存在大量符号引用，在运行期间转化为直接引用的部分就是动态连接\n+ **方法返回地址**：方法执行完成/异常退出的返回地址\n    + 遇到方法返回的字节码指令，属于正常退出，这时主调方法的PC值就可以作为返回地址，从而保存在栈帧中\n    + 因本方法执行过程中产生无法处理的异常（方法里的异常处理表没有对应的异常处理）而退出，属于异常退出，这要通过异常处理表来确定，一般栈帧就不会保存这部分信息\n+ 附加信息：一些规范里没有描述的信息到栈帧之中，例如与调试、 性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述\n\n## 垃圾收集\n### 可达性分析算法\n基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。\n\n**GC Roots**的组成：\n+ 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。\n+ 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。\n+ 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。\n+ 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。\n+ Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。\n+ 所有被同步锁（synchronized关键字）持有的对象。\n+ 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。\n\n在可达性分析算法中被判定为不可达的对象，可以通过自身定义的finalize()方法“拯救”自己，该方法仅会调用一次，并且虚拟机并不一定会等待其调用结束。如果调用之后，算法将其判定为可达，那么其“拯救”成功；否则将被回收。\n\n### 垃圾收集算法\n#### 理论：分代收集\n分代假说：\n+ **弱分代假说**（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的\n+ **强分代假说**（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡\n+ **跨代引用假说**（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。\n\n收集器设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储\n\n以较高的频率回收新生代，以较低的频率回收老年代；同时由于跨代引用仅少量存在，因此可以通过**记忆集(remembered set)** 等数据结构实现跨代收集\n\n一些定义：\n+ 部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： \n    + **新生代收集(Minor GC/Young GC)**：指目标只是新生代的垃圾收集。\n    + 老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。\n        + 目前只有CMS收集器会有单独收集老年代的行为。\n        + 另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。 \n    + 混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集\n        + 目前只有G1收集器会有这种行为\n+ **整堆收集(Full GC)**：整个Java堆和方法区的垃圾收集\n\n#### 1. 标记-清除算法\n算法分为“**标记**”和“**清除**”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象（也可以反过来，标记存活的对象，统一回收所有未被标记的对象）\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_sweep.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-清除”算法示意图\n    </div>\n</center>\n\n缺点：\n+ **执行效率不稳定**：标记和清除两个过程的执行效率都与对象数量有关，随对象数量增长而降低\n+ **内存空间碎片化问题**：标记、清除之后会产生大量不连续的内存碎片，导致再次分配时效果不佳\n\n#### 2. 标记-复制算法\n“半区复制”（Semispace Copying）：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n\n优点：\n+ 分配内存很方便，移动堆顶指针即可\n缺点：\n+ 如果存活对象较多，则内存复制的开销较大\n+ 可用内存减小到了原来的一半，过于浪费\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_copy.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-复制”算法示意图\n    </div>\n</center>\n\n\n优化后的半区复制分代策略——Appel式回收：内存空间100% = Eden 80% * 1 + Survivor 10% * 2\n\n每次扫描Eden和一块Survivor，将存活对象转移到另一块Survivor上\n\n根据研究数据——新生代中的对象有98%熬不过第一轮收集，这能工作的很好\n\n#### 3. 标记-整理算法\n算法的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存\n\n标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。\n\n优点：\n+ 对象分配简单，移动堆顶即可\n缺点：\n+ 存活对象较多时，内存复制较多；且对象移动过程必须要全程暂停用户应用程序\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_compact.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-整理”算法示意图\n    </div>\n</center>\n\n### 经典垃圾收集器\n#### 1. Serial收集器\nSerial收集器是**单线程**的**新生代**收集器，且在进行垃圾回收时，必须暂停所有线程，直到它收集结束\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/serial.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Serial/Serial Old收集器运行示意图\n    </div>\n</center>\n\n优点：简单而高效，是所有收集器里额外内存消耗最小的\n\nSerial收集器依然是HotSpot虚拟机运行在**客户端模式**下的默认新生代收集器。\n\n对于用户桌面的应用场景以及近年来流行的部分微服务应用之类的场景中，虚拟机可管理的内存很少，只要垃圾收集不是过于频繁，几十毫秒的停顿时间是完全可以接受的\n\n#### 2. ParNew收集器\nParNew收集器实质上是**Serial收集器的多线程并行版本**。\n\n除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。\n\nParNew收集器是不少运行在服务端模式下的HotSpot虚拟机机，尤其是JDK 7之前的遗留系统中首选的新生代收集器\n+ 除了Serial收集器外，目前只有它能与CMS收集器配合工作\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/parnew.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ParNew/Serial Old收集器运行示意图\n    </div>\n</center>\n\n#### 3. Parallel Scavenge收集器\nParallel Scavenge收集器也是一款**新生代收集器**，它同样是**基于标记-复制算法**实现的收集器，也是能够并行收集的**多线程**收集器\n\nParallel Scavenge收集器的目标则是**达到一个可控制的吞吐量**（Throughput），经常被称作“吞吐量优先收集器”。\n+ 吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间（运行用户代码时间+运行垃圾收集时间）的比值。\n\n#### 4. Serial Old收集器\nSerial Old是Serial收集器的**老年代**版本，它同样是一个**单线程**收集器，使用**标记-整理算法**。\n\n用 途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。\n\n#### 5. Parallel Old收集器\nParallel Old是Parallel Scavenge收集器的**老年代**版本，支持**多线程**并发收集，**基于标记-整理算法**实现\n\n#### 6. CMS收集器\nCMS（Concurrent Mark Sweep）收集器是一种以**获取最短回收停顿时间**为目标的收集器，**基于标记-清除算法**实现\n\n目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。\n\n收集过程：\n1. **初始标记**：标记一下GC Roots能直接关联到的对象；\n    + 时间很短，需要“Stop The World”\n2. **并发标记**：就是从GC Roots的直接关联对象开始遍历整个对象图的过程\n    + 这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行\n3. **重新标记**：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录\n    + 比初始标记时间稍长，但远比并发标记短；需要“Stop The World”\n4. **并发清除**：清理删除掉标记阶段判断的已经死亡的对象\n    + 由于不需要移动存活对象，所以可以与用户线程同时并发\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cms.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Concurrent Mark Sweep收集器运行示意图\n    </div>\n</center>\n\n优点：并发收集、低停顿\n缺点：\n+ 对处理器资源非常敏感：并发阶段会占用部分用户资源，导致应用程序变慢\n+ 无法处理“浮动垃圾”：本次垃圾收集过程中程序产生的新对象只能到下一次垃圾收集处理，因此不能等内存空间几乎完全占满才使用\n+ 内存空间碎片化问题：“标记—清除”算法的弊端\n\n#### 7. Garbage First收集器\n即G1收集器，是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。\n\nG1是一款主要面向服务端应用的垃圾收集器。\n\n**可以由用户指定期望的停顿时间**是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。\n\n收集过程大致可划分为以下四个步骤：\n+ **初始标记**：仅仅只是标记一下GC Roots能直接关联到的对象\n    + 并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象\n    + 这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿\n+ **并发标记**：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象\n    + 这阶段耗时较长，但可与用户程序并发执行\n    + 当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象\n+ **最终标记**：处理并发阶段结束后仍遗留下来的最后那少量的SATB记录\n    + 对用户线程做另一个短暂的暂停\n+ **筛选回收**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间\n    + 这里的操作涉及存活对象的移动，是**必须暂停用户线程**，由多条收集器线程并行完成\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/g1.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        G1收集器运行示意图\n    </div>\n</center>\n\nG1可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。\n\n**基于Region的堆内存布局**：\n+ G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间\n+ 收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果\n\n**可预测的停顿时间模型**：\n+ 将**Region作为单次回收的最小单元**，即每次收集到的内存空间都是Region大小的整数倍，避免在整个Java堆中进行全区域的垃圾收集\n+ G1收集器会跟踪**各个Region里面的垃圾堆积的“价值”** 大小（价值即回收所获得的空间大小以及回收所需时间的经验值）\n+ 然后在后台维护一个**优先级列表**，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region（这也就是“Garbage First”名字的由来）\n+ 这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率\n\n需要解决的细节问题：\n1. 跨Region引用对象如何解决？ --> 每个Region都维护自己的**记忆集**\n    + G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号\n    + 这种结构更复杂，占用内存量也更大\n2. 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？ --> **原始快照（SATB）算法**\n    + 新对象创建：G1为每一个Region设计了两个名为**TAMS**（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认它们是活的\n3. 怎样建立起可靠的停顿预测模型？ --> 以衰减均值为理论基础\n    + G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息\n    + 衰减平均值更准确地代表“最近的”平均状态\n    + 通过这些信息预测现在开始回收的话，可以计算由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益\n\n\n## Java基础故障处理工具\n### 1. jps\njps：JVM Process Status Tool，虚拟机进程状况工具\n\n功能和ps命令类似：可以**列出正在运行的虚拟机进程**，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）\n\njps命令格式： \n```sh\njps [ options ] [ hostid ]\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jps工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jps_options.png\">\n</center>\n\n### 2. jstat\njstat：JVM Statistics Monitoring Tool，虚拟机统计信息监视工具\n\n用于**监视虚拟机各种运行状态信息**的命令行工具，可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据\n\njstat命令格式为： \n```sh\njstat [ option vmid [interval[s|ms] [count]] ]\n```\n对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID 是一致的；如果是远程虚拟机进程，那VMID的格式应当是：\n```sh\n[protocol:][//]lvmid[@hostname[:port]/servername]\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstat工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstat_options.png\">\n</center>\n\n### 3. jinfo\njinfo：Configuration Info for Java，Java配置信息工具，作用是**实时查看和调整虚拟机各项参数**\n\njinfo命令格式：\n```sh\njinfo [ option ] pid\n```\n\n### 4. jmap\njmap：Memory Map for Java，Java内存映像工具，用于**生成堆转储快照**（一般称为heapdump或dump文件），还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等\n\njmap命令格式：\n```sh\njmap [ option ] vmid\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jmap工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jmap_options.png\">\n</center>\n\n### 5. jhat\njhat：JVM Heap Analysis Tool，虚拟机堆转储快照分析工具，与jmap搭配使用，来**分析jmap生成的堆转储快照**。\n\njhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看\n\n### 6. jstack\njstack：Stack Trace for Java，Java堆栈跟踪工具，用于**生成虚拟机当前时刻的线程快照**（一般称为threaddump或者 javacore文件）\n\n生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因\n\n\njstack命令格式：\n```sh\njstack [ option ] vmid\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstack工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstack_options.png\">\n</center>\n\n### 其他\n详见书本《深入理解Java虚拟机》4.2.7节","source":"_posts/自动内存管理.md","raw":"---\ntitle: 自动内存管理\ndate: 2022-03-27 13:35:18\ntop_img: /img/cover/java_memory.webp\ncover: /img/cover/java_memory.webp\ntags: [Java, 笔记]\n---\n\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## Java内存区域\nJava虚拟机管理的内存包含以下几个运行时数据区域：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_memory.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时数据区\n    </div>\n</center>\n\n各运行时数据区域内容如下：\n+ **程序计数器（Program Counter Register）**：即线程执行字节码的行号指示器；\n    + 在JVM中每个线程都有一个，属于**线程私有**的资源\n    + 如果执行的是Java方法，那么计数器值是虚拟机字节码的指令地址；\n    + 如果执行的是本地(Native)方法，那么计数器值是空(Undefined)\n+ **Java虚拟机栈**：描述Java方法执行的线程内存模型；**线程私有**\n    + 当出现方法调用时，虚拟机会同步创建**栈帧(Stack Frame)**入栈；调用完毕时，栈帧出栈\n+ **本地方法栈（Native Method Stacks）**：与虚拟机栈所发挥的作用非常相似，本地方法栈是为虚拟机使用到的本地（Native）方法服务\n    + 本地方法可简单理解为Java程序调用的外部代码，如c++、python脚本等\n+ **Java堆（Java Heap）**：所有线程共享的一块内存区域，在虚拟机启动时创建，用来**存放对象实例**\n    + Java堆也是垃圾收集器管理的内存区域，对象的“朝生暮死”就在这里发，因此又叫“GC”堆\n+ **方法区（Method Area）**：与Java堆一样，是各个**线程共享**的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n+ **运行时常量池（Runtime Constant Pool）**：方法区的一部分，与已加载的类一一对应\n    + 常量池表(Constatnt Pool Table)是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中\n    + 运行时常量池中包含了多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。\n+ **直接内存（Direct Memory）**：不是虚拟机运行时数据区的一部分\n    + 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。\n\n### 运行时栈帧结构\nJava虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法 调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_stack_frame.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时栈帧结构\n    </div>\n</center>\n\n如上图，每一个栈帧都包括了**局部变量表**、**操作数栈**、**动态连接**、**方法返回地址**和一些额外的附加信息\n+ **局部变量表（Local Variables Table）**：用于存放方法参数和方法内部定义的局部变量\n    + 记录在方法的`Code`属性的`max_locals`数据项中\n    + 局部变量表的容量与变量槽（Variable Slot）为单位，变量槽的实际大小不固定，只是一种规范\n+ **操作数栈（Operand Stack）**：后入先出栈，最大深度记录在`Code`属性的`max_stacks`数据项中\n    + 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作；例如算术操作，会借助该栈完成计算\n+ **动态连接（Dynamic Linking）**：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接\n    + Class文件的常量池中存在大量符号引用，在运行期间转化为直接引用的部分就是动态连接\n+ **方法返回地址**：方法执行完成/异常退出的返回地址\n    + 遇到方法返回的字节码指令，属于正常退出，这时主调方法的PC值就可以作为返回地址，从而保存在栈帧中\n    + 因本方法执行过程中产生无法处理的异常（方法里的异常处理表没有对应的异常处理）而退出，属于异常退出，这要通过异常处理表来确定，一般栈帧就不会保存这部分信息\n+ 附加信息：一些规范里没有描述的信息到栈帧之中，例如与调试、 性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述\n\n## 垃圾收集\n### 可达性分析算法\n基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。\n\n**GC Roots**的组成：\n+ 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。\n+ 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。\n+ 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。\n+ 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。\n+ Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。\n+ 所有被同步锁（synchronized关键字）持有的对象。\n+ 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。\n\n在可达性分析算法中被判定为不可达的对象，可以通过自身定义的finalize()方法“拯救”自己，该方法仅会调用一次，并且虚拟机并不一定会等待其调用结束。如果调用之后，算法将其判定为可达，那么其“拯救”成功；否则将被回收。\n\n### 垃圾收集算法\n#### 理论：分代收集\n分代假说：\n+ **弱分代假说**（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的\n+ **强分代假说**（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡\n+ **跨代引用假说**（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。\n\n收集器设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储\n\n以较高的频率回收新生代，以较低的频率回收老年代；同时由于跨代引用仅少量存在，因此可以通过**记忆集(remembered set)** 等数据结构实现跨代收集\n\n一些定义：\n+ 部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： \n    + **新生代收集(Minor GC/Young GC)**：指目标只是新生代的垃圾收集。\n    + 老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。\n        + 目前只有CMS收集器会有单独收集老年代的行为。\n        + 另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。 \n    + 混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集\n        + 目前只有G1收集器会有这种行为\n+ **整堆收集(Full GC)**：整个Java堆和方法区的垃圾收集\n\n#### 1. 标记-清除算法\n算法分为“**标记**”和“**清除**”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象（也可以反过来，标记存活的对象，统一回收所有未被标记的对象）\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_sweep.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-清除”算法示意图\n    </div>\n</center>\n\n缺点：\n+ **执行效率不稳定**：标记和清除两个过程的执行效率都与对象数量有关，随对象数量增长而降低\n+ **内存空间碎片化问题**：标记、清除之后会产生大量不连续的内存碎片，导致再次分配时效果不佳\n\n#### 2. 标记-复制算法\n“半区复制”（Semispace Copying）：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n\n优点：\n+ 分配内存很方便，移动堆顶指针即可\n缺点：\n+ 如果存活对象较多，则内存复制的开销较大\n+ 可用内存减小到了原来的一半，过于浪费\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_copy.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-复制”算法示意图\n    </div>\n</center>\n\n\n优化后的半区复制分代策略——Appel式回收：内存空间100% = Eden 80% * 1 + Survivor 10% * 2\n\n每次扫描Eden和一块Survivor，将存活对象转移到另一块Survivor上\n\n根据研究数据——新生代中的对象有98%熬不过第一轮收集，这能工作的很好\n\n#### 3. 标记-整理算法\n算法的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存\n\n标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。\n\n优点：\n+ 对象分配简单，移动堆顶即可\n缺点：\n+ 存活对象较多时，内存复制较多；且对象移动过程必须要全程暂停用户应用程序\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_compact.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-整理”算法示意图\n    </div>\n</center>\n\n### 经典垃圾收集器\n#### 1. Serial收集器\nSerial收集器是**单线程**的**新生代**收集器，且在进行垃圾回收时，必须暂停所有线程，直到它收集结束\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/serial.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Serial/Serial Old收集器运行示意图\n    </div>\n</center>\n\n优点：简单而高效，是所有收集器里额外内存消耗最小的\n\nSerial收集器依然是HotSpot虚拟机运行在**客户端模式**下的默认新生代收集器。\n\n对于用户桌面的应用场景以及近年来流行的部分微服务应用之类的场景中，虚拟机可管理的内存很少，只要垃圾收集不是过于频繁，几十毫秒的停顿时间是完全可以接受的\n\n#### 2. ParNew收集器\nParNew收集器实质上是**Serial收集器的多线程并行版本**。\n\n除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。\n\nParNew收集器是不少运行在服务端模式下的HotSpot虚拟机机，尤其是JDK 7之前的遗留系统中首选的新生代收集器\n+ 除了Serial收集器外，目前只有它能与CMS收集器配合工作\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/parnew.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ParNew/Serial Old收集器运行示意图\n    </div>\n</center>\n\n#### 3. Parallel Scavenge收集器\nParallel Scavenge收集器也是一款**新生代收集器**，它同样是**基于标记-复制算法**实现的收集器，也是能够并行收集的**多线程**收集器\n\nParallel Scavenge收集器的目标则是**达到一个可控制的吞吐量**（Throughput），经常被称作“吞吐量优先收集器”。\n+ 吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间（运行用户代码时间+运行垃圾收集时间）的比值。\n\n#### 4. Serial Old收集器\nSerial Old是Serial收集器的**老年代**版本，它同样是一个**单线程**收集器，使用**标记-整理算法**。\n\n用 途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。\n\n#### 5. Parallel Old收集器\nParallel Old是Parallel Scavenge收集器的**老年代**版本，支持**多线程**并发收集，**基于标记-整理算法**实现\n\n#### 6. CMS收集器\nCMS（Concurrent Mark Sweep）收集器是一种以**获取最短回收停顿时间**为目标的收集器，**基于标记-清除算法**实现\n\n目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。\n\n收集过程：\n1. **初始标记**：标记一下GC Roots能直接关联到的对象；\n    + 时间很短，需要“Stop The World”\n2. **并发标记**：就是从GC Roots的直接关联对象开始遍历整个对象图的过程\n    + 这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行\n3. **重新标记**：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录\n    + 比初始标记时间稍长，但远比并发标记短；需要“Stop The World”\n4. **并发清除**：清理删除掉标记阶段判断的已经死亡的对象\n    + 由于不需要移动存活对象，所以可以与用户线程同时并发\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cms.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Concurrent Mark Sweep收集器运行示意图\n    </div>\n</center>\n\n优点：并发收集、低停顿\n缺点：\n+ 对处理器资源非常敏感：并发阶段会占用部分用户资源，导致应用程序变慢\n+ 无法处理“浮动垃圾”：本次垃圾收集过程中程序产生的新对象只能到下一次垃圾收集处理，因此不能等内存空间几乎完全占满才使用\n+ 内存空间碎片化问题：“标记—清除”算法的弊端\n\n#### 7. Garbage First收集器\n即G1收集器，是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。\n\nG1是一款主要面向服务端应用的垃圾收集器。\n\n**可以由用户指定期望的停顿时间**是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。\n\n收集过程大致可划分为以下四个步骤：\n+ **初始标记**：仅仅只是标记一下GC Roots能直接关联到的对象\n    + 并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象\n    + 这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿\n+ **并发标记**：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象\n    + 这阶段耗时较长，但可与用户程序并发执行\n    + 当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象\n+ **最终标记**：处理并发阶段结束后仍遗留下来的最后那少量的SATB记录\n    + 对用户线程做另一个短暂的暂停\n+ **筛选回收**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间\n    + 这里的操作涉及存活对象的移动，是**必须暂停用户线程**，由多条收集器线程并行完成\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/g1.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        G1收集器运行示意图\n    </div>\n</center>\n\nG1可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。\n\n**基于Region的堆内存布局**：\n+ G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间\n+ 收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果\n\n**可预测的停顿时间模型**：\n+ 将**Region作为单次回收的最小单元**，即每次收集到的内存空间都是Region大小的整数倍，避免在整个Java堆中进行全区域的垃圾收集\n+ G1收集器会跟踪**各个Region里面的垃圾堆积的“价值”** 大小（价值即回收所获得的空间大小以及回收所需时间的经验值）\n+ 然后在后台维护一个**优先级列表**，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region（这也就是“Garbage First”名字的由来）\n+ 这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率\n\n需要解决的细节问题：\n1. 跨Region引用对象如何解决？ --> 每个Region都维护自己的**记忆集**\n    + G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号\n    + 这种结构更复杂，占用内存量也更大\n2. 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？ --> **原始快照（SATB）算法**\n    + 新对象创建：G1为每一个Region设计了两个名为**TAMS**（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认它们是活的\n3. 怎样建立起可靠的停顿预测模型？ --> 以衰减均值为理论基础\n    + G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息\n    + 衰减平均值更准确地代表“最近的”平均状态\n    + 通过这些信息预测现在开始回收的话，可以计算由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益\n\n\n## Java基础故障处理工具\n### 1. jps\njps：JVM Process Status Tool，虚拟机进程状况工具\n\n功能和ps命令类似：可以**列出正在运行的虚拟机进程**，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）\n\njps命令格式： \n```sh\njps [ options ] [ hostid ]\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jps工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jps_options.png\">\n</center>\n\n### 2. jstat\njstat：JVM Statistics Monitoring Tool，虚拟机统计信息监视工具\n\n用于**监视虚拟机各种运行状态信息**的命令行工具，可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据\n\njstat命令格式为： \n```sh\njstat [ option vmid [interval[s|ms] [count]] ]\n```\n对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID 是一致的；如果是远程虚拟机进程，那VMID的格式应当是：\n```sh\n[protocol:][//]lvmid[@hostname[:port]/servername]\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstat工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstat_options.png\">\n</center>\n\n### 3. jinfo\njinfo：Configuration Info for Java，Java配置信息工具，作用是**实时查看和调整虚拟机各项参数**\n\njinfo命令格式：\n```sh\njinfo [ option ] pid\n```\n\n### 4. jmap\njmap：Memory Map for Java，Java内存映像工具，用于**生成堆转储快照**（一般称为heapdump或dump文件），还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等\n\njmap命令格式：\n```sh\njmap [ option ] vmid\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jmap工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jmap_options.png\">\n</center>\n\n### 5. jhat\njhat：JVM Heap Analysis Tool，虚拟机堆转储快照分析工具，与jmap搭配使用，来**分析jmap生成的堆转储快照**。\n\njhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看\n\n### 6. jstack\njstack：Stack Trace for Java，Java堆栈跟踪工具，用于**生成虚拟机当前时刻的线程快照**（一般称为threaddump或者 javacore文件）\n\n生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因\n\n\njstack命令格式：\n```sh\njstack [ option ] vmid\n```\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstack工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstack_options.png\">\n</center>\n\n### 其他\n详见书本《深入理解Java虚拟机》4.2.7节","slug":"自动内存管理","published":1,"updated":"2022-09-21T07:30:46.940Z","_id":"cl18v3i6h00004otp6fitb1qj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"Java内存区域\"><a href=\"#Java内存区域\" class=\"headerlink\" title=\"Java内存区域\"></a>Java内存区域</h2><p>Java虚拟机管理的内存包含以下几个运行时数据区域：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_memory.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时数据区\n    </div>\n</center>\n\n<p>各运行时数据区域内容如下：</p>\n<ul>\n<li><strong>程序计数器（Program Counter Register）</strong>：即线程执行字节码的行号指示器；<ul>\n<li>在JVM中每个线程都有一个，属于<strong>线程私有</strong>的资源</li>\n<li>如果执行的是Java方法，那么计数器值是虚拟机字节码的指令地址；</li>\n<li>如果执行的是本地(Native)方法，那么计数器值是空(Undefined)</li>\n</ul>\n</li>\n<li><strong>Java虚拟机栈</strong>：描述Java方法执行的线程内存模型；<strong>线程私有</strong><ul>\n<li>当出现方法调用时，虚拟机会同步创建<strong>栈帧(Stack Frame)</strong>入栈；调用完毕时，栈帧出栈</li>\n</ul>\n</li>\n<li><strong>本地方法栈（Native Method Stacks）</strong>：与虚拟机栈所发挥的作用非常相似，本地方法栈是为虚拟机使用到的本地（Native）方法服务<ul>\n<li>本地方法可简单理解为Java程序调用的外部代码，如c++、python脚本等</li>\n</ul>\n</li>\n<li><strong>Java堆（Java Heap）</strong>：所有线程共享的一块内存区域，在虚拟机启动时创建，用来<strong>存放对象实例</strong><ul>\n<li>Java堆也是垃圾收集器管理的内存区域，对象的“朝生暮死”就在这里发，因此又叫“GC”堆</li>\n</ul>\n</li>\n<li><strong>方法区（Method Area）</strong>：与Java堆一样，是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li>\n<li><strong>运行时常量池（Runtime Constant Pool）</strong>：方法区的一部分，与已加载的类一一对应<ul>\n<li>常量池表(Constatnt Pool Table)是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li>\n<li>运行时常量池中包含了多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li>\n</ul>\n</li>\n<li><strong>直接内存（Direct Memory）</strong>：不是虚拟机运行时数据区的一部分<ul>\n<li>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法 调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_stack_frame.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时栈帧结构\n    </div>\n</center>\n\n<p>如上图，每一个栈帧都包括了<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法返回地址</strong>和一些额外的附加信息</p>\n<ul>\n<li><strong>局部变量表（Local Variables Table）</strong>：用于存放方法参数和方法内部定义的局部变量<ul>\n<li>记录在方法的<code>Code</code>属性的<code>max_locals</code>数据项中</li>\n<li>局部变量表的容量与变量槽（Variable Slot）为单位，变量槽的实际大小不固定，只是一种规范</li>\n</ul>\n</li>\n<li><strong>操作数栈（Operand Stack）</strong>：后入先出栈，最大深度记录在<code>Code</code>属性的<code>max_stacks</code>数据项中<ul>\n<li>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作；例如算术操作，会借助该栈完成计算</li>\n</ul>\n</li>\n<li><strong>动态连接（Dynamic Linking）</strong>：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接<ul>\n<li>Class文件的常量池中存在大量符号引用，在运行期间转化为直接引用的部分就是动态连接</li>\n</ul>\n</li>\n<li><strong>方法返回地址</strong>：方法执行完成/异常退出的返回地址<ul>\n<li>遇到方法返回的字节码指令，属于正常退出，这时主调方法的PC值就可以作为返回地址，从而保存在栈帧中</li>\n<li>因本方法执行过程中产生无法处理的异常（方法里的异常处理表没有对应的异常处理）而退出，属于异常退出，这要通过异常处理表来确定，一般栈帧就不会保存这部分信息</li>\n</ul>\n</li>\n<li>附加信息：一些规范里没有描述的信息到栈帧之中，例如与调试、 性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述</li>\n</ul>\n<h2 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h2><h3 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h3><p>基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>\n<p><strong>GC Roots</strong>的组成：</p>\n<ul>\n<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。</li>\n<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>\n<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>\n<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>\n<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>\n<li>所有被同步锁（synchronized关键字）持有的对象。</li>\n<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>\n</ul>\n<p>在可达性分析算法中被判定为不可达的对象，可以通过自身定义的finalize()方法“拯救”自己，该方法仅会调用一次，并且虚拟机并不一定会等待其调用结束。如果调用之后，算法将其判定为可达，那么其“拯救”成功；否则将被回收。</p>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><h4 id=\"理论：分代收集\"><a href=\"#理论：分代收集\" class=\"headerlink\" title=\"理论：分代收集\"></a>理论：分代收集</h4><p>分代假说：</p>\n<ul>\n<li><strong>弱分代假说</strong>（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的</li>\n<li><strong>强分代假说</strong>（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</li>\n<li><strong>跨代引用假说</strong>（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>\n</ul>\n<p>收集器设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储</p>\n<p>以较高的频率回收新生代，以较低的频率回收老年代；同时由于跨代引用仅少量存在，因此可以通过<strong>记忆集(remembered set)</strong> 等数据结构实现跨代收集</p>\n<p>一些定义：</p>\n<ul>\n<li>部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： <ul>\n<li><strong>新生代收集(Minor GC/Young GC)</strong>：指目标只是新生代的垃圾收集。</li>\n<li>老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。<ul>\n<li>目前只有CMS收集器会有单独收集老年代的行为。</li>\n<li>另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。 </li>\n</ul>\n</li>\n<li>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集<ul>\n<li>目前只有G1收集器会有这种行为</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>整堆收集(Full GC)</strong>：整个Java堆和方法区的垃圾收集</li>\n</ul>\n<h4 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1. 标记-清除算法\"></a>1. 标记-清除算法</h4><p>算法分为“<strong>标记</strong>”和“<strong>清除</strong>”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象（也可以反过来，标记存活的对象，统一回收所有未被标记的对象）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_sweep.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-清除”算法示意图\n    </div>\n</center>\n\n<p>缺点：</p>\n<ul>\n<li><strong>执行效率不稳定</strong>：标记和清除两个过程的执行效率都与对象数量有关，随对象数量增长而降低</li>\n<li><strong>内存空间碎片化问题</strong>：标记、清除之后会产生大量不连续的内存碎片，导致再次分配时效果不佳</li>\n</ul>\n<h4 id=\"2-标记-复制算法\"><a href=\"#2-标记-复制算法\" class=\"headerlink\" title=\"2. 标记-复制算法\"></a>2. 标记-复制算法</h4><p>“半区复制”（Semispace Copying）：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>\n<p>优点：</p>\n<ul>\n<li>分配内存很方便，移动堆顶指针即可<br>缺点：</li>\n<li>如果存活对象较多，则内存复制的开销较大</li>\n<li>可用内存减小到了原来的一半，过于浪费</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_copy.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-复制”算法示意图\n    </div>\n</center>\n\n\n<p>优化后的半区复制分代策略——Appel式回收：内存空间100% = Eden 80% <em> 1 + Survivor 10% </em> 2</p>\n<p>每次扫描Eden和一块Survivor，将存活对象转移到另一块Survivor上</p>\n<p>根据研究数据——新生代中的对象有98%熬不过第一轮收集，这能工作的很好</p>\n<h4 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3. 标记-整理算法\"></a>3. 标记-整理算法</h4><p>算法的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</p>\n<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p>\n<p>优点：</p>\n<ul>\n<li>对象分配简单，移动堆顶即可<br>缺点：</li>\n<li>存活对象较多时，内存复制较多；且对象移动过程必须要全程暂停用户应用程序</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_compact.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-整理”算法示意图\n    </div>\n</center>\n\n<h3 id=\"经典垃圾收集器\"><a href=\"#经典垃圾收集器\" class=\"headerlink\" title=\"经典垃圾收集器\"></a>经典垃圾收集器</h3><h4 id=\"1-Serial收集器\"><a href=\"#1-Serial收集器\" class=\"headerlink\" title=\"1. Serial收集器\"></a>1. Serial收集器</h4><p>Serial收集器是<strong>单线程</strong>的<strong>新生代</strong>收集器，且在进行垃圾回收时，必须暂停所有线程，直到它收集结束</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/serial.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Serial/Serial Old收集器运行示意图\n    </div>\n</center>\n\n<p>优点：简单而高效，是所有收集器里额外内存消耗最小的</p>\n<p>Serial收集器依然是HotSpot虚拟机运行在<strong>客户端模式</strong>下的默认新生代收集器。</p>\n<p>对于用户桌面的应用场景以及近年来流行的部分微服务应用之类的场景中，虚拟机可管理的内存很少，只要垃圾收集不是过于频繁，几十毫秒的停顿时间是完全可以接受的</p>\n<h4 id=\"2-ParNew收集器\"><a href=\"#2-ParNew收集器\" class=\"headerlink\" title=\"2. ParNew收集器\"></a>2. ParNew收集器</h4><p>ParNew收集器实质上是<strong>Serial收集器的多线程并行版本</strong>。</p>\n<p>除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>\n<p>ParNew收集器是不少运行在服务端模式下的HotSpot虚拟机机，尤其是JDK 7之前的遗留系统中首选的新生代收集器</p>\n<ul>\n<li>除了Serial收集器外，目前只有它能与CMS收集器配合工作</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/parnew.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ParNew/Serial Old收集器运行示意图\n    </div>\n</center>\n\n<h4 id=\"3-Parallel-Scavenge收集器\"><a href=\"#3-Parallel-Scavenge收集器\" class=\"headerlink\" title=\"3. Parallel Scavenge收集器\"></a>3. Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一款<strong>新生代收集器</strong>，它同样是<strong>基于标记-复制算法</strong>实现的收集器，也是能够并行收集的<strong>多线程</strong>收集器</p>\n<p>Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐量</strong>（Throughput），经常被称作“吞吐量优先收集器”。</p>\n<ul>\n<li>吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间（运行用户代码时间+运行垃圾收集时间）的比值。</li>\n</ul>\n<h4 id=\"4-Serial-Old收集器\"><a href=\"#4-Serial-Old收集器\" class=\"headerlink\" title=\"4. Serial Old收集器\"></a>4. Serial Old收集器</h4><p>Serial Old是Serial收集器的<strong>老年代</strong>版本，它同样是一个<strong>单线程</strong>收集器，使用<strong>标记-整理算法</strong>。</p>\n<p>用 途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>\n<h4 id=\"5-Parallel-Old收集器\"><a href=\"#5-Parallel-Old收集器\" class=\"headerlink\" title=\"5. Parallel Old收集器\"></a>5. Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的<strong>老年代</strong>版本，支持<strong>多线程</strong>并发收集，<strong>基于标记-整理算法</strong>实现</p>\n<h4 id=\"6-CMS收集器\"><a href=\"#6-CMS收集器\" class=\"headerlink\" title=\"6. CMS收集器\"></a>6. CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，<strong>基于标记-清除算法</strong>实现</p>\n<p>目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。</p>\n<p>收集过程：</p>\n<ol>\n<li><strong>初始标记</strong>：标记一下GC Roots能直接关联到的对象；<ul>\n<li>时间很短，需要“Stop The World”</li>\n</ul>\n</li>\n<li><strong>并发标记</strong>：就是从GC Roots的直接关联对象开始遍历整个对象图的过程<ul>\n<li>这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li>\n</ul>\n</li>\n<li><strong>重新标记</strong>：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录<ul>\n<li>比初始标记时间稍长，但远比并发标记短；需要“Stop The World”</li>\n</ul>\n</li>\n<li><strong>并发清除</strong>：清理删除掉标记阶段判断的已经死亡的对象<ul>\n<li>由于不需要移动存活对象，所以可以与用户线程同时并发</li>\n</ul>\n</li>\n</ol>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cms.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Concurrent Mark Sweep收集器运行示意图\n    </div>\n</center>\n\n<p>优点：并发收集、低停顿<br>缺点：</p>\n<ul>\n<li>对处理器资源非常敏感：并发阶段会占用部分用户资源，导致应用程序变慢</li>\n<li>无法处理“浮动垃圾”：本次垃圾收集过程中程序产生的新对象只能到下一次垃圾收集处理，因此不能等内存空间几乎完全占满才使用</li>\n<li>内存空间碎片化问题：“标记—清除”算法的弊端</li>\n</ul>\n<h4 id=\"7-Garbage-First收集器\"><a href=\"#7-Garbage-First收集器\" class=\"headerlink\" title=\"7. Garbage First收集器\"></a>7. Garbage First收集器</h4><p>即G1收集器，是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p>\n<p>G1是一款主要面向服务端应用的垃圾收集器。</p>\n<p><strong>可以由用户指定期望的停顿时间</strong>是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。</p>\n<p>收集过程大致可划分为以下四个步骤：</p>\n<ul>\n<li><strong>初始标记</strong>：仅仅只是标记一下GC Roots能直接关联到的对象<ul>\n<li>并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象</li>\n<li>这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿</li>\n</ul>\n</li>\n<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象<ul>\n<li>这阶段耗时较长，但可与用户程序并发执行</li>\n<li>当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象</li>\n</ul>\n</li>\n<li><strong>最终标记</strong>：处理并发阶段结束后仍遗留下来的最后那少量的SATB记录<ul>\n<li>对用户线程做另一个短暂的暂停</li>\n</ul>\n</li>\n<li><strong>筛选回收</strong>：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间<ul>\n<li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成</li>\n</ul>\n</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/g1.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        G1收集器运行示意图\n    </div>\n</center>\n\n<p>G1可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>\n<p><strong>基于Region的堆内存布局</strong>：</p>\n<ul>\n<li>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间</li>\n<li>收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果</li>\n</ul>\n<p><strong>可预测的停顿时间模型</strong>：</p>\n<ul>\n<li>将<strong>Region作为单次回收的最小单元</strong>，即每次收集到的内存空间都是Region大小的整数倍，避免在整个Java堆中进行全区域的垃圾收集</li>\n<li>G1收集器会跟踪<strong>各个Region里面的垃圾堆积的“价值”</strong> 大小（价值即回收所获得的空间大小以及回收所需时间的经验值）</li>\n<li>然后在后台维护一个<strong>优先级列表</strong>，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region（这也就是“Garbage First”名字的由来）</li>\n<li>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率</li>\n</ul>\n<p>需要解决的细节问题：</p>\n<ol>\n<li>跨Region引用对象如何解决？ —&gt; 每个Region都维护自己的<strong>记忆集</strong><ul>\n<li>G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号</li>\n<li>这种结构更复杂，占用内存量也更大</li>\n</ul>\n</li>\n<li>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？ —&gt; <strong>原始快照（SATB）算法</strong><ul>\n<li>新对象创建：G1为每一个Region设计了两个名为<strong>TAMS</strong>（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认它们是活的</li>\n</ul>\n</li>\n<li>怎样建立起可靠的停顿预测模型？ —&gt; 以衰减均值为理论基础<ul>\n<li>G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息</li>\n<li>衰减平均值更准确地代表“最近的”平均状态</li>\n<li>通过这些信息预测现在开始回收的话，可以计算由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Java基础故障处理工具\"><a href=\"#Java基础故障处理工具\" class=\"headerlink\" title=\"Java基础故障处理工具\"></a>Java基础故障处理工具</h2><h3 id=\"1-jps\"><a href=\"#1-jps\" class=\"headerlink\" title=\"1. jps\"></a>1. jps</h3><p>jps：JVM Process Status Tool，虚拟机进程状况工具</p>\n<p>功能和ps命令类似：可以<strong>列出正在运行的虚拟机进程</strong>，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）</p>\n<p>jps命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jps工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jps_options.png\">\n</center>\n\n<h3 id=\"2-jstat\"><a href=\"#2-jstat\" class=\"headerlink\" title=\"2. jstat\"></a>2. jstat</h3><p>jstat：JVM Statistics Monitoring Tool，虚拟机统计信息监视工具</p>\n<p>用于<strong>监视虚拟机各种运行状态信息</strong>的命令行工具，可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p>\n<p>jstat命令格式为：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure><br>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID 是一致的；如果是远程虚拟机进程，那VMID的格式应当是：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstat工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstat_options.png\">\n</center>\n\n<h3 id=\"3-jinfo\"><a href=\"#3-jinfo\" class=\"headerlink\" title=\"3. jinfo\"></a>3. jinfo</h3><p>jinfo：Configuration Info for Java，Java配置信息工具，作用是<strong>实时查看和调整虚拟机各项参数</strong></p>\n<p>jinfo命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [ option ] pid</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-jmap\"><a href=\"#4-jmap\" class=\"headerlink\" title=\"4. jmap\"></a>4. jmap</h3><p>jmap：Memory Map for Java，Java内存映像工具，用于<strong>生成堆转储快照</strong>（一般称为heapdump或dump文件），还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等</p>\n<p>jmap命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap [ option ] vmid</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jmap工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jmap_options.png\">\n</center>\n\n<h3 id=\"5-jhat\"><a href=\"#5-jhat\" class=\"headerlink\" title=\"5. jhat\"></a>5. jhat</h3><p>jhat：JVM Heap Analysis Tool，虚拟机堆转储快照分析工具，与jmap搭配使用，来<strong>分析jmap生成的堆转储快照</strong>。</p>\n<p>jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看</p>\n<h3 id=\"6-jstack\"><a href=\"#6-jstack\" class=\"headerlink\" title=\"6. jstack\"></a>6. jstack</h3><p>jstack：Stack Trace for Java，Java堆栈跟踪工具，用于<strong>生成虚拟机当前时刻的线程快照</strong>（一般称为threaddump或者 javacore文件）</p>\n<p>生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因</p>\n<p>jstack命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack [ option ] vmid</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstack工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstack_options.png\">\n</center>\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>详见书本《深入理解Java虚拟机》4.2.7节</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"Java内存区域\"><a href=\"#Java内存区域\" class=\"headerlink\" title=\"Java内存区域\"></a>Java内存区域</h2><p>Java虚拟机管理的内存包含以下几个运行时数据区域：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_memory.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时数据区\n    </div>\n</center>\n\n<p>各运行时数据区域内容如下：</p>\n<ul>\n<li><strong>程序计数器（Program Counter Register）</strong>：即线程执行字节码的行号指示器；<ul>\n<li>在JVM中每个线程都有一个，属于<strong>线程私有</strong>的资源</li>\n<li>如果执行的是Java方法，那么计数器值是虚拟机字节码的指令地址；</li>\n<li>如果执行的是本地(Native)方法，那么计数器值是空(Undefined)</li>\n</ul>\n</li>\n<li><strong>Java虚拟机栈</strong>：描述Java方法执行的线程内存模型；<strong>线程私有</strong><ul>\n<li>当出现方法调用时，虚拟机会同步创建<strong>栈帧(Stack Frame)</strong>入栈；调用完毕时，栈帧出栈</li>\n</ul>\n</li>\n<li><strong>本地方法栈（Native Method Stacks）</strong>：与虚拟机栈所发挥的作用非常相似，本地方法栈是为虚拟机使用到的本地（Native）方法服务<ul>\n<li>本地方法可简单理解为Java程序调用的外部代码，如c++、python脚本等</li>\n</ul>\n</li>\n<li><strong>Java堆（Java Heap）</strong>：所有线程共享的一块内存区域，在虚拟机启动时创建，用来<strong>存放对象实例</strong><ul>\n<li>Java堆也是垃圾收集器管理的内存区域，对象的“朝生暮死”就在这里发，因此又叫“GC”堆</li>\n</ul>\n</li>\n<li><strong>方法区（Method Area）</strong>：与Java堆一样，是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</li>\n<li><strong>运行时常量池（Runtime Constant Pool）</strong>：方法区的一部分，与已加载的类一一对应<ul>\n<li>常量池表(Constatnt Pool Table)是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中</li>\n<li>运行时常量池中包含了多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</li>\n</ul>\n</li>\n<li><strong>直接内存（Direct Memory）</strong>：不是虚拟机运行时数据区的一部分<ul>\n<li>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h3><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法 调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/runtime_stack_frame.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        运行时栈帧结构\n    </div>\n</center>\n\n<p>如上图，每一个栈帧都包括了<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法返回地址</strong>和一些额外的附加信息</p>\n<ul>\n<li><strong>局部变量表（Local Variables Table）</strong>：用于存放方法参数和方法内部定义的局部变量<ul>\n<li>记录在方法的<code>Code</code>属性的<code>max_locals</code>数据项中</li>\n<li>局部变量表的容量与变量槽（Variable Slot）为单位，变量槽的实际大小不固定，只是一种规范</li>\n</ul>\n</li>\n<li><strong>操作数栈（Operand Stack）</strong>：后入先出栈，最大深度记录在<code>Code</code>属性的<code>max_stacks</code>数据项中<ul>\n<li>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作；例如算术操作，会借助该栈完成计算</li>\n</ul>\n</li>\n<li><strong>动态连接（Dynamic Linking）</strong>：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接<ul>\n<li>Class文件的常量池中存在大量符号引用，在运行期间转化为直接引用的部分就是动态连接</li>\n</ul>\n</li>\n<li><strong>方法返回地址</strong>：方法执行完成/异常退出的返回地址<ul>\n<li>遇到方法返回的字节码指令，属于正常退出，这时主调方法的PC值就可以作为返回地址，从而保存在栈帧中</li>\n<li>因本方法执行过程中产生无法处理的异常（方法里的异常处理表没有对应的异常处理）而退出，属于异常退出，这要通过异常处理表来确定，一般栈帧就不会保存这部分信息</li>\n</ul>\n</li>\n<li>附加信息：一些规范里没有描述的信息到栈帧之中，例如与调试、 性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述</li>\n</ul>\n<h2 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h2><h3 id=\"可达性分析算法\"><a href=\"#可达性分析算法\" class=\"headerlink\" title=\"可达性分析算法\"></a>可达性分析算法</h3><p>基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>\n<p><strong>GC Roots</strong>的组成：</p>\n<ul>\n<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。</li>\n<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>\n<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>\n<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>\n<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>\n<li>所有被同步锁（synchronized关键字）持有的对象。</li>\n<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>\n</ul>\n<p>在可达性分析算法中被判定为不可达的对象，可以通过自身定义的finalize()方法“拯救”自己，该方法仅会调用一次，并且虚拟机并不一定会等待其调用结束。如果调用之后，算法将其判定为可达，那么其“拯救”成功；否则将被回收。</p>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><h4 id=\"理论：分代收集\"><a href=\"#理论：分代收集\" class=\"headerlink\" title=\"理论：分代收集\"></a>理论：分代收集</h4><p>分代假说：</p>\n<ul>\n<li><strong>弱分代假说</strong>（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的</li>\n<li><strong>强分代假说</strong>（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡</li>\n<li><strong>跨代引用假说</strong>（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>\n</ul>\n<p>收集器设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储</p>\n<p>以较高的频率回收新生代，以较低的频率回收老年代；同时由于跨代引用仅少量存在，因此可以通过<strong>记忆集(remembered set)</strong> 等数据结构实现跨代收集</p>\n<p>一些定义：</p>\n<ul>\n<li>部分收集(Partial GC)：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： <ul>\n<li><strong>新生代收集(Minor GC/Young GC)</strong>：指目标只是新生代的垃圾收集。</li>\n<li>老年代收集(Major GC/Old GC)：指目标只是老年代的垃圾收集。<ul>\n<li>目前只有CMS收集器会有单独收集老年代的行为。</li>\n<li>另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。 </li>\n</ul>\n</li>\n<li>混合收集(Mixed GC)：指目标是收集整个新生代以及部分老年代的垃圾收集<ul>\n<li>目前只有G1收集器会有这种行为</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>整堆收集(Full GC)</strong>：整个Java堆和方法区的垃圾收集</li>\n</ul>\n<h4 id=\"1-标记-清除算法\"><a href=\"#1-标记-清除算法\" class=\"headerlink\" title=\"1. 标记-清除算法\"></a>1. 标记-清除算法</h4><p>算法分为“<strong>标记</strong>”和“<strong>清除</strong>”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象（也可以反过来，标记存活的对象，统一回收所有未被标记的对象）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_sweep.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-清除”算法示意图\n    </div>\n</center>\n\n<p>缺点：</p>\n<ul>\n<li><strong>执行效率不稳定</strong>：标记和清除两个过程的执行效率都与对象数量有关，随对象数量增长而降低</li>\n<li><strong>内存空间碎片化问题</strong>：标记、清除之后会产生大量不连续的内存碎片，导致再次分配时效果不佳</li>\n</ul>\n<h4 id=\"2-标记-复制算法\"><a href=\"#2-标记-复制算法\" class=\"headerlink\" title=\"2. 标记-复制算法\"></a>2. 标记-复制算法</h4><p>“半区复制”（Semispace Copying）：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>\n<p>优点：</p>\n<ul>\n<li>分配内存很方便，移动堆顶指针即可<br>缺点：</li>\n<li>如果存活对象较多，则内存复制的开销较大</li>\n<li>可用内存减小到了原来的一半，过于浪费</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_copy.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-复制”算法示意图\n    </div>\n</center>\n\n\n<p>优化后的半区复制分代策略——Appel式回收：内存空间100% = Eden 80% <em> 1 + Survivor 10% </em> 2</p>\n<p>每次扫描Eden和一块Survivor，将存活对象转移到另一块Survivor上</p>\n<p>根据研究数据——新生代中的对象有98%熬不过第一轮收集，这能工作的很好</p>\n<h4 id=\"3-标记-整理算法\"><a href=\"#3-标记-整理算法\" class=\"headerlink\" title=\"3. 标记-整理算法\"></a>3. 标记-整理算法</h4><p>算法的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存</p>\n<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p>\n<p>优点：</p>\n<ul>\n<li>对象分配简单，移动堆顶即可<br>缺点：</li>\n<li>存活对象较多时，内存复制较多；且对象移动过程必须要全程暂停用户应用程序</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/mark_compact.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        “标记-整理”算法示意图\n    </div>\n</center>\n\n<h3 id=\"经典垃圾收集器\"><a href=\"#经典垃圾收集器\" class=\"headerlink\" title=\"经典垃圾收集器\"></a>经典垃圾收集器</h3><h4 id=\"1-Serial收集器\"><a href=\"#1-Serial收集器\" class=\"headerlink\" title=\"1. Serial收集器\"></a>1. Serial收集器</h4><p>Serial收集器是<strong>单线程</strong>的<strong>新生代</strong>收集器，且在进行垃圾回收时，必须暂停所有线程，直到它收集结束</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/serial.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Serial/Serial Old收集器运行示意图\n    </div>\n</center>\n\n<p>优点：简单而高效，是所有收集器里额外内存消耗最小的</p>\n<p>Serial收集器依然是HotSpot虚拟机运行在<strong>客户端模式</strong>下的默认新生代收集器。</p>\n<p>对于用户桌面的应用场景以及近年来流行的部分微服务应用之类的场景中，虚拟机可管理的内存很少，只要垃圾收集不是过于频繁，几十毫秒的停顿时间是完全可以接受的</p>\n<h4 id=\"2-ParNew收集器\"><a href=\"#2-ParNew收集器\" class=\"headerlink\" title=\"2. ParNew收集器\"></a>2. ParNew收集器</h4><p>ParNew收集器实质上是<strong>Serial收集器的多线程并行版本</strong>。</p>\n<p>除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>\n<p>ParNew收集器是不少运行在服务端模式下的HotSpot虚拟机机，尤其是JDK 7之前的遗留系统中首选的新生代收集器</p>\n<ul>\n<li>除了Serial收集器外，目前只有它能与CMS收集器配合工作</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/parnew.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ParNew/Serial Old收集器运行示意图\n    </div>\n</center>\n\n<h4 id=\"3-Parallel-Scavenge收集器\"><a href=\"#3-Parallel-Scavenge收集器\" class=\"headerlink\" title=\"3. Parallel Scavenge收集器\"></a>3. Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一款<strong>新生代收集器</strong>，它同样是<strong>基于标记-复制算法</strong>实现的收集器，也是能够并行收集的<strong>多线程</strong>收集器</p>\n<p>Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐量</strong>（Throughput），经常被称作“吞吐量优先收集器”。</p>\n<ul>\n<li>吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间（运行用户代码时间+运行垃圾收集时间）的比值。</li>\n</ul>\n<h4 id=\"4-Serial-Old收集器\"><a href=\"#4-Serial-Old收集器\" class=\"headerlink\" title=\"4. Serial Old收集器\"></a>4. Serial Old收集器</h4><p>Serial Old是Serial收集器的<strong>老年代</strong>版本，它同样是一个<strong>单线程</strong>收集器，使用<strong>标记-整理算法</strong>。</p>\n<p>用 途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>\n<h4 id=\"5-Parallel-Old收集器\"><a href=\"#5-Parallel-Old收集器\" class=\"headerlink\" title=\"5. Parallel Old收集器\"></a>5. Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的<strong>老年代</strong>版本，支持<strong>多线程</strong>并发收集，<strong>基于标记-整理算法</strong>实现</p>\n<h4 id=\"6-CMS收集器\"><a href=\"#6-CMS收集器\" class=\"headerlink\" title=\"6. CMS收集器\"></a>6. CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，<strong>基于标记-清除算法</strong>实现</p>\n<p>目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。</p>\n<p>收集过程：</p>\n<ol>\n<li><strong>初始标记</strong>：标记一下GC Roots能直接关联到的对象；<ul>\n<li>时间很短，需要“Stop The World”</li>\n</ul>\n</li>\n<li><strong>并发标记</strong>：就是从GC Roots的直接关联对象开始遍历整个对象图的过程<ul>\n<li>这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li>\n</ul>\n</li>\n<li><strong>重新标记</strong>：为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录<ul>\n<li>比初始标记时间稍长，但远比并发标记短；需要“Stop The World”</li>\n</ul>\n</li>\n<li><strong>并发清除</strong>：清理删除掉标记阶段判断的已经死亡的对象<ul>\n<li>由于不需要移动存活对象，所以可以与用户线程同时并发</li>\n</ul>\n</li>\n</ol>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cms.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Concurrent Mark Sweep收集器运行示意图\n    </div>\n</center>\n\n<p>优点：并发收集、低停顿<br>缺点：</p>\n<ul>\n<li>对处理器资源非常敏感：并发阶段会占用部分用户资源，导致应用程序变慢</li>\n<li>无法处理“浮动垃圾”：本次垃圾收集过程中程序产生的新对象只能到下一次垃圾收集处理，因此不能等内存空间几乎完全占满才使用</li>\n<li>内存空间碎片化问题：“标记—清除”算法的弊端</li>\n</ul>\n<h4 id=\"7-Garbage-First收集器\"><a href=\"#7-Garbage-First收集器\" class=\"headerlink\" title=\"7. Garbage First收集器\"></a>7. Garbage First收集器</h4><p>即G1收集器，是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p>\n<p>G1是一款主要面向服务端应用的垃圾收集器。</p>\n<p><strong>可以由用户指定期望的停顿时间</strong>是G1收集器很强大的一个功能，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。</p>\n<p>收集过程大致可划分为以下四个步骤：</p>\n<ul>\n<li><strong>初始标记</strong>：仅仅只是标记一下GC Roots能直接关联到的对象<ul>\n<li>并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象</li>\n<li>这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿</li>\n</ul>\n</li>\n<li><strong>并发标记</strong>：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象<ul>\n<li>这阶段耗时较长，但可与用户程序并发执行</li>\n<li>当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象</li>\n</ul>\n</li>\n<li><strong>最终标记</strong>：处理并发阶段结束后仍遗留下来的最后那少量的SATB记录<ul>\n<li>对用户线程做另一个短暂的暂停</li>\n</ul>\n</li>\n<li><strong>筛选回收</strong>：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间<ul>\n<li>这里的操作涉及存活对象的移动，是<strong>必须暂停用户线程</strong>，由多条收集器线程并行完成</li>\n</ul>\n</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/g1.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        G1收集器运行示意图\n    </div>\n</center>\n\n<p>G1可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>\n<p><strong>基于Region的堆内存布局</strong>：</p>\n<ul>\n<li>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间</li>\n<li>收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果</li>\n</ul>\n<p><strong>可预测的停顿时间模型</strong>：</p>\n<ul>\n<li>将<strong>Region作为单次回收的最小单元</strong>，即每次收集到的内存空间都是Region大小的整数倍，避免在整个Java堆中进行全区域的垃圾收集</li>\n<li>G1收集器会跟踪<strong>各个Region里面的垃圾堆积的“价值”</strong> 大小（价值即回收所获得的空间大小以及回收所需时间的经验值）</li>\n<li>然后在后台维护一个<strong>优先级列表</strong>，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region（这也就是“Garbage First”名字的由来）</li>\n<li>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率</li>\n</ul>\n<p>需要解决的细节问题：</p>\n<ol>\n<li>跨Region引用对象如何解决？ —&gt; 每个Region都维护自己的<strong>记忆集</strong><ul>\n<li>G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号</li>\n<li>这种结构更复杂，占用内存量也更大</li>\n</ul>\n</li>\n<li>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？ —&gt; <strong>原始快照（SATB）算法</strong><ul>\n<li>新对象创建：G1为每一个Region设计了两个名为<strong>TAMS</strong>（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认它们是活的</li>\n</ul>\n</li>\n<li>怎样建立起可靠的停顿预测模型？ —&gt; 以衰减均值为理论基础<ul>\n<li>G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息</li>\n<li>衰减平均值更准确地代表“最近的”平均状态</li>\n<li>通过这些信息预测现在开始回收的话，可以计算由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Java基础故障处理工具\"><a href=\"#Java基础故障处理工具\" class=\"headerlink\" title=\"Java基础故障处理工具\"></a>Java基础故障处理工具</h2><h3 id=\"1-jps\"><a href=\"#1-jps\" class=\"headerlink\" title=\"1. jps\"></a>1. jps</h3><p>jps：JVM Process Status Tool，虚拟机进程状况工具</p>\n<p>功能和ps命令类似：可以<strong>列出正在运行的虚拟机进程</strong>，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）</p>\n<p>jps命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jps [ options ] [ hostid ]</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jps工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jps_options.png\">\n</center>\n\n<h3 id=\"2-jstat\"><a href=\"#2-jstat\" class=\"headerlink\" title=\"2. jstat\"></a>2. jstat</h3><p>jstat：JVM Statistics Monitoring Tool，虚拟机统计信息监视工具</p>\n<p>用于<strong>监视虚拟机各种运行状态信息</strong>的命令行工具，可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据</p>\n<p>jstat命令格式为：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstat [ option vmid [interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure><br>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID 是一致的；如果是远程虚拟机进程，那VMID的格式应当是：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstat工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstat_options.png\">\n</center>\n\n<h3 id=\"3-jinfo\"><a href=\"#3-jinfo\" class=\"headerlink\" title=\"3. jinfo\"></a>3. jinfo</h3><p>jinfo：Configuration Info for Java，Java配置信息工具，作用是<strong>实时查看和调整虚拟机各项参数</strong></p>\n<p>jinfo命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jinfo [ option ] pid</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-jmap\"><a href=\"#4-jmap\" class=\"headerlink\" title=\"4. jmap\"></a>4. jmap</h3><p>jmap：Memory Map for Java，Java内存映像工具，用于<strong>生成堆转储快照</strong>（一般称为heapdump或dump文件），还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等</p>\n<p>jmap命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap [ option ] vmid</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jmap工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jmap_options.png\">\n</center>\n\n<h3 id=\"5-jhat\"><a href=\"#5-jhat\" class=\"headerlink\" title=\"5. jhat\"></a>5. jhat</h3><p>jhat：JVM Heap Analysis Tool，虚拟机堆转储快照分析工具，与jmap搭配使用，来<strong>分析jmap生成的堆转储快照</strong>。</p>\n<p>jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看</p>\n<h3 id=\"6-jstack\"><a href=\"#6-jstack\" class=\"headerlink\" title=\"6. jstack\"></a>6. jstack</h3><p>jstack：Stack Trace for Java，Java堆栈跟踪工具，用于<strong>生成虚拟机当前时刻的线程快照</strong>（一般称为threaddump或者 javacore文件）</p>\n<p>生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因</p>\n<p>jstack命令格式：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jstack [ option ] vmid</span><br></pre></td></tr></table></figure></p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        jstack工具主要选项\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/jstack_options.png\">\n</center>\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>详见书本《深入理解Java虚拟机》4.2.7节</p>\n"},{"title":"虚拟机执行","date":"2022-03-28T07:24:56.000Z","top_img":"/img/cover/java_class.png","cover":"/img/cover/java_class.png","_content":"\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## Java编译器\n解释器与编译器两者各有优势：\n+ 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行\n+ 当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率\n+ 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/interpreter_compiler.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        解释器与编译器的交互\n    </div>\n</center>\n\n### 编译器分类\n+ **前端编译器**：把`*.java`文件转变成`*.class`文件的过程\n    + JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）\n+ **即时编译器**：常称JIT编译器(Just In Time Compiler)，运行期把字节码转变成本地机器码的过程\n    + **提高热点代码的执行效率**\n    + HotSpot虚拟机的C1、C2编译器，Graal编译器\n+ **提前编译器**：常称AOT编译器(Ahead Of Time Compiler)，直接把程序编译成与目标机器指令集相关的二进制代码的过程\n    + JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET\n\n## Java类文件结构\n> 需要注意：Java中的类不必都以磁盘文件形式存在，可以动态生成，或者通过I/O输入等等\n\n任意有效的类或接口所满足的格式即为**Class文件格式**\n\nClass文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前(`Big Endian`)的方式分割成若干个8个字节进行存储。\n\nClass文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：**无符号数**和**表**\n+ **无符号数**属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。\n+ **表**是由多个无符号数或者其他表作为数据项构成的复合数据类型，用于描述有层次关系的复合结构的数据。为了便于区分，所有表的命名都习惯性地以“_info”结尾。\n\nClass文件格式如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件格式\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_struc.png\">\n</center>\n\n### 魔数\n每个Class文件的头4个字节被称为**魔数(Magic Number)**，它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的Class文件**。Class文件的魔数为`0xCAFEBABE`\n\n紧接着，第5和第6个字节是**次版本号**(Minor Version)，第7和第8个字节是**主版本号**(Major Version)\n\n高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。Class文件与JDK版本的兼容关系如下图所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件版本号\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_version.png\">\n</center>\n\n> 注：从JDK 9开始，Javac编译器不再支持使用-source参数编译版本号小于1.5的源码\n\n### 常量池\n版本号之后紧接着是常量池，它是**Class文件结构中与其他项目关联最多的数据**，通常也是**占用Class文件空间最大的数据项目之一**\n\n常量池中常量的数量并不固定，因此需要先放置一项`u2`类型的数据，表示**常量池容量计数值**(constant_pool_count)\n> Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始\n\n常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）\n+ **字面量**：文本字符串、被声明为final的常量值等\n+ **符号引用**：\n    + 被模块导出或者开放的包\n    + 类和接口的全限定名\n    + 字段的名称和描述符\n    + 方法的名称和描述符\n    + 方法句柄和方法类型\n    + 动态调用点和动态常量\n\n之后对常量池的解析是一种嵌套解析：因为每一个常量都是17种常量中的一种，有的格式简单；有的较为复杂，内部又由各种简单常量组成。总之，每个常量的解析都是先读取一个字节判断其属于17种常量中的哪一种，再根据这种常量的组成结构读取组成他的实际数据。Class文件组成紧密，并没有多余的停顿符号。\n\n> 更细致的解析过程详见原书6.3节，这里不再赘述\n\n17种常量类型如下：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        常量池的项目类型\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_constant.png\">\n</center>\n\n### 访问标志\n在常量池结束之后，**紧接着的2个字节代表访问标志(access_flags)**，这个标志用于**识别一些类或者接口层次的访问信息**，包括：\n+ 这个Class是类还是接口；\n+ 是否定义为public类型；\n+ 是否定义为abstract类型；\n+ 如果是类的话，是否被声明为final；等等\n\n当然，不同含义的标志位之间可以用 `|` 表示，具体的标志位以及标志的含义见下表：\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_access_flag.png\">\n</center>\n\n### 类索引、父类索引与接口索引集合\n类索引用于确定这个类的全限定名；\n\n父类索引用于确定这个类的父类的全限定名；\n\n接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。\n\n**Class文件中由这三项数据来确定该类型的继承关系**\n\n类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为`CONSTANT_Class_info`的类描述符常量，通过`CONSTANT_Class_info`类型的常量中的索引值可以找到定义在`CONSTANT_Utf8_info`类型的常量中的全限定名字符串。\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类索引查找全限定名的过程\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_this.png\">\n</center>\n\n对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。\n\n### 字段表集合\n字段表（field_info）用于**描述接口或者类中声明的变量**，包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_info.png\">\n</center>\n\n字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称\n\n字段修饰符放在`access_flags`项目中，它与类中的`access_flags`项目是非常类似的，都是一个`u2`的数据类型，其中可以设置的标志位和含义如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_access_flag.png\">\n</center>\n\n### 方法表集合\n方法表中的数据项目的含义与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别\n\n> 方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为**Code**的属性里面\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_info.png\">\n</center>\n\n因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。其中可以设置的标志位和含义如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_access_flag.png\">\n</center>\n\n### 属性表集合\n属性表集合的限制稍微宽松很多，不再要求各个属性表具有严格顺序\n\n> 《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息\n\n#### Code属性\nJava程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在`Code`属性内\n\n**`Code`属性用于描述代码，所有的其他数据项目都用于描述元数据**\n\n`Code`属性的结构将如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Code属性表的结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_code.png\">\n</center>\n\n各属性简要解析：\n+ `attribute_name_index`是一项指向`CONSTANT_Utf8_info`型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称\n+ `attribute_length`指示了属性值的长度\n    + 属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节 \n+ `max_stack`代表了操作数栈（Operand Stack）深度的最大值\n+ `max_locals`代表了局部变量表所需的存储空间\n    + `max_locals`的单位是变量槽（Slot），变量 槽是虚拟机为局部变量分配内存所使用的最小单位\n    + 根据同时生存的最大局部变量数量和类型计算出`max_locals`的大小\n+ `code_length`和`code`用来存储Java源程序编译后生成的字节码指令\n    + `code_length`代表字节码长度\n    + `code`是用于存储字节码指令的一系列字节流\n\n##### 异常表\n异常表属于Java代码的一部分，是代码里显式能处理的异常\n\n如果存在异常表，那它的格式应如下表所示，包含四个字段，这些字段的含义为：如果当字节码从第`start_pc`行到第`end_pc`行之间（不含第`end_pc`行）出现了类型为`catch_type`或者其子类的异常（`catch_type`为指向一个`CONSTANT_Class_info`型常量的索引），则转到第`handler_pc`行继续处理。当`catch_type`的值为0时，代表任意异常情况都需要转到`handler_pc`处进行处理。\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        异常表属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exception_table.png\">\n</center>\n\n#### Exceptions属性\n`Exceptions`属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在`throws`关键字后面列举的异常\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Exceptions属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exceptions.png\">\n</center>\n\n此属性中的`number_of_exceptions`项表示方法可能抛出`number_of_exceptions`种受查异常，每一种受查异常使用一个`exception_index_table`项表示；`exception_index_table`是一个指向常量池中 `CONSTANT_Class_info`型常量的索引，代表了该受查异常的类型。\n\n## 类加载\n### 类加载的过程\n一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_life_cycle.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类的生命周期\n    </div>\n</center>\n\n#### 加载阶段\n在加载阶段，Java虚拟机需要完成以下三件事情：\n+ 通过一个类的全限定名来获取定义此类的二进制字节流\n    + 从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。 \n    + 从网络中获取，这种场景最典型的应用就是Web Applet。 \n    + 运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。\n    + 由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。 \n    + 从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。\n    + 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。\n+ 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n#### 验证阶段\n这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。\n\n四个检验动作：\n+ 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理\n    + 是否以魔数0xCAFEBABE开头\n    + 主、次版本号是否在当前Java虚拟机接受范围之内\n    + 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）\n    + 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量\n    + CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据\n    + Class文件中各个部分及文件本身是否有被删除的或附加的其他信息\n+ 元数据验证：对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息\n    + 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）\n    + 这个类的父类是否继承了不允许被继承的类（被final修饰的类）\n    + 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法\n    + 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）\n+ 字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的\n    + 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作\n    + 保证任何跳转指令都不会跳转到方法体以外的字节码指令上\n    + 保证方法体中的类型转换总是有效的\n+ 符号引用验证：主要目的是确保解析行为能正常执行；发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生\n    + 符号引用中通过字符串描述的全限定名是否能找到对应的类\n    + 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段\n    + 符号引用中的类、字段、方法的可访问性是否可被当前类访问\n\n**文件格式验证阶段的验证是基于二进制字节流进行的**，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以**后面的三个验证阶段全部是基于方法区的存储结构上进行的**，不会再直接读取、操作字节流\n\n#### 准备阶段\n准备阶段是正式**为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值**的阶段\n+ 这时候进行内存分配的仅包括类变量，而不包括实例变量\n+ 初始值通常情况下是数值类型的零值（`final`字段会直接赋最终值）\n\n#### 解析阶段\n解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程\n+ 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。\n+ 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在\n\n#### 初始化阶段\n初始化阶段就是执行类构造器`<clinit>()`方法的过程\n+ `<clinit>()`方法是由编译器自动收集类中的**所有类变量的赋值动作**和**静态语句块**（`static{}`块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问\n\n由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作\n\n**同一个类加载器下，一个类型只会被初始化一次**\n\n### 类加载器\n**对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**\n\n每一个类加载器，都拥有一个独立的类名称空间\n\n三层类加载器\n+ 启动类加载器：这个类加载器负责加载存放在`<JAVA_HOME>\\lib`目录，或者被`-Xbootclasspath`参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如`rt.jar`、`tools.jar`，名字不符合的类库即使放在`lib`目录中也不会被加载）类库加载到虚拟机的内存中\n+ 扩展类加载器：负责加载`<JAVA_HOME>\\lib\\ext`目录中，或者被`java.ext.dirs`系统变量所指定的路径中所有的类库\n+ 应用程序加载器：`ClassLoader`类中的`getSystem-ClassLoader()`方法的返回值，所以有些场合中也称它为“系统类加载器”。负责加载用户类路径(`ClassPath`)上所有的类库，开发者同样可以直接在代码中使用这个类加载器\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/classloader.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类加载器双亲委派模型\n    </div>\n</center>\n\n#### 双亲委派模型\n双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用**组合**（Composition）关系来复用父加载器的代码。\n\n双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。**\n\n破坏双亲委派模型：。。。","source":"_posts/虚拟机执行.md","raw":"---\ntitle: 虚拟机执行\ndate: 2022-03-28 15:24:56\ntop_img: /img/cover/java_class.png\ncover: /img/cover/java_class.png\ntags: [Java, 笔记]\n---\n\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## Java编译器\n解释器与编译器两者各有优势：\n+ 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行\n+ 当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率\n+ 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/interpreter_compiler.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        解释器与编译器的交互\n    </div>\n</center>\n\n### 编译器分类\n+ **前端编译器**：把`*.java`文件转变成`*.class`文件的过程\n    + JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）\n+ **即时编译器**：常称JIT编译器(Just In Time Compiler)，运行期把字节码转变成本地机器码的过程\n    + **提高热点代码的执行效率**\n    + HotSpot虚拟机的C1、C2编译器，Graal编译器\n+ **提前编译器**：常称AOT编译器(Ahead Of Time Compiler)，直接把程序编译成与目标机器指令集相关的二进制代码的过程\n    + JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET\n\n## Java类文件结构\n> 需要注意：Java中的类不必都以磁盘文件形式存在，可以动态生成，或者通过I/O输入等等\n\n任意有效的类或接口所满足的格式即为**Class文件格式**\n\nClass文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前(`Big Endian`)的方式分割成若干个8个字节进行存储。\n\nClass文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：**无符号数**和**表**\n+ **无符号数**属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。\n+ **表**是由多个无符号数或者其他表作为数据项构成的复合数据类型，用于描述有层次关系的复合结构的数据。为了便于区分，所有表的命名都习惯性地以“_info”结尾。\n\nClass文件格式如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件格式\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_struc.png\">\n</center>\n\n### 魔数\n每个Class文件的头4个字节被称为**魔数(Magic Number)**，它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的Class文件**。Class文件的魔数为`0xCAFEBABE`\n\n紧接着，第5和第6个字节是**次版本号**(Minor Version)，第7和第8个字节是**主版本号**(Major Version)\n\n高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。Class文件与JDK版本的兼容关系如下图所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件版本号\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_version.png\">\n</center>\n\n> 注：从JDK 9开始，Javac编译器不再支持使用-source参数编译版本号小于1.5的源码\n\n### 常量池\n版本号之后紧接着是常量池，它是**Class文件结构中与其他项目关联最多的数据**，通常也是**占用Class文件空间最大的数据项目之一**\n\n常量池中常量的数量并不固定，因此需要先放置一项`u2`类型的数据，表示**常量池容量计数值**(constant_pool_count)\n> Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始\n\n常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）\n+ **字面量**：文本字符串、被声明为final的常量值等\n+ **符号引用**：\n    + 被模块导出或者开放的包\n    + 类和接口的全限定名\n    + 字段的名称和描述符\n    + 方法的名称和描述符\n    + 方法句柄和方法类型\n    + 动态调用点和动态常量\n\n之后对常量池的解析是一种嵌套解析：因为每一个常量都是17种常量中的一种，有的格式简单；有的较为复杂，内部又由各种简单常量组成。总之，每个常量的解析都是先读取一个字节判断其属于17种常量中的哪一种，再根据这种常量的组成结构读取组成他的实际数据。Class文件组成紧密，并没有多余的停顿符号。\n\n> 更细致的解析过程详见原书6.3节，这里不再赘述\n\n17种常量类型如下：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        常量池的项目类型\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_constant.png\">\n</center>\n\n### 访问标志\n在常量池结束之后，**紧接着的2个字节代表访问标志(access_flags)**，这个标志用于**识别一些类或者接口层次的访问信息**，包括：\n+ 这个Class是类还是接口；\n+ 是否定义为public类型；\n+ 是否定义为abstract类型；\n+ 如果是类的话，是否被声明为final；等等\n\n当然，不同含义的标志位之间可以用 `|` 表示，具体的标志位以及标志的含义见下表：\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_access_flag.png\">\n</center>\n\n### 类索引、父类索引与接口索引集合\n类索引用于确定这个类的全限定名；\n\n父类索引用于确定这个类的父类的全限定名；\n\n接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。\n\n**Class文件中由这三项数据来确定该类型的继承关系**\n\n类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为`CONSTANT_Class_info`的类描述符常量，通过`CONSTANT_Class_info`类型的常量中的索引值可以找到定义在`CONSTANT_Utf8_info`类型的常量中的全限定名字符串。\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类索引查找全限定名的过程\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_this.png\">\n</center>\n\n对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。\n\n### 字段表集合\n字段表（field_info）用于**描述接口或者类中声明的变量**，包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_info.png\">\n</center>\n\n字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称\n\n字段修饰符放在`access_flags`项目中，它与类中的`access_flags`项目是非常类似的，都是一个`u2`的数据类型，其中可以设置的标志位和含义如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_access_flag.png\">\n</center>\n\n### 方法表集合\n方法表中的数据项目的含义与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别\n\n> 方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为**Code**的属性里面\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_info.png\">\n</center>\n\n因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。其中可以设置的标志位和含义如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_access_flag.png\">\n</center>\n\n### 属性表集合\n属性表集合的限制稍微宽松很多，不再要求各个属性表具有严格顺序\n\n> 《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息\n\n#### Code属性\nJava程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在`Code`属性内\n\n**`Code`属性用于描述代码，所有的其他数据项目都用于描述元数据**\n\n`Code`属性的结构将如下表所示：\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Code属性表的结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_code.png\">\n</center>\n\n各属性简要解析：\n+ `attribute_name_index`是一项指向`CONSTANT_Utf8_info`型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称\n+ `attribute_length`指示了属性值的长度\n    + 属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节 \n+ `max_stack`代表了操作数栈（Operand Stack）深度的最大值\n+ `max_locals`代表了局部变量表所需的存储空间\n    + `max_locals`的单位是变量槽（Slot），变量 槽是虚拟机为局部变量分配内存所使用的最小单位\n    + 根据同时生存的最大局部变量数量和类型计算出`max_locals`的大小\n+ `code_length`和`code`用来存储Java源程序编译后生成的字节码指令\n    + `code_length`代表字节码长度\n    + `code`是用于存储字节码指令的一系列字节流\n\n##### 异常表\n异常表属于Java代码的一部分，是代码里显式能处理的异常\n\n如果存在异常表，那它的格式应如下表所示，包含四个字段，这些字段的含义为：如果当字节码从第`start_pc`行到第`end_pc`行之间（不含第`end_pc`行）出现了类型为`catch_type`或者其子类的异常（`catch_type`为指向一个`CONSTANT_Class_info`型常量的索引），则转到第`handler_pc`行继续处理。当`catch_type`的值为0时，代表任意异常情况都需要转到`handler_pc`处进行处理。\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        异常表属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exception_table.png\">\n</center>\n\n#### Exceptions属性\n`Exceptions`属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在`throws`关键字后面列举的异常\n\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Exceptions属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exceptions.png\">\n</center>\n\n此属性中的`number_of_exceptions`项表示方法可能抛出`number_of_exceptions`种受查异常，每一种受查异常使用一个`exception_index_table`项表示；`exception_index_table`是一个指向常量池中 `CONSTANT_Class_info`型常量的索引，代表了该受查异常的类型。\n\n## 类加载\n### 类加载的过程\n一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_life_cycle.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类的生命周期\n    </div>\n</center>\n\n#### 加载阶段\n在加载阶段，Java虚拟机需要完成以下三件事情：\n+ 通过一个类的全限定名来获取定义此类的二进制字节流\n    + 从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。 \n    + 从网络中获取，这种场景最典型的应用就是Web Applet。 \n    + 运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。\n    + 由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。 \n    + 从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。\n    + 可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。\n+ 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构\n+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n#### 验证阶段\n这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。\n\n四个检验动作：\n+ 文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理\n    + 是否以魔数0xCAFEBABE开头\n    + 主、次版本号是否在当前Java虚拟机接受范围之内\n    + 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）\n    + 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量\n    + CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据\n    + Class文件中各个部分及文件本身是否有被删除的或附加的其他信息\n+ 元数据验证：对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息\n    + 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）\n    + 这个类的父类是否继承了不允许被继承的类（被final修饰的类）\n    + 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法\n    + 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）\n+ 字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的\n    + 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作\n    + 保证任何跳转指令都不会跳转到方法体以外的字节码指令上\n    + 保证方法体中的类型转换总是有效的\n+ 符号引用验证：主要目的是确保解析行为能正常执行；发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生\n    + 符号引用中通过字符串描述的全限定名是否能找到对应的类\n    + 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段\n    + 符号引用中的类、字段、方法的可访问性是否可被当前类访问\n\n**文件格式验证阶段的验证是基于二进制字节流进行的**，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以**后面的三个验证阶段全部是基于方法区的存储结构上进行的**，不会再直接读取、操作字节流\n\n#### 准备阶段\n准备阶段是正式**为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值**的阶段\n+ 这时候进行内存分配的仅包括类变量，而不包括实例变量\n+ 初始值通常情况下是数值类型的零值（`final`字段会直接赋最终值）\n\n#### 解析阶段\n解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程\n+ 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。\n+ 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在\n\n#### 初始化阶段\n初始化阶段就是执行类构造器`<clinit>()`方法的过程\n+ `<clinit>()`方法是由编译器自动收集类中的**所有类变量的赋值动作**和**静态语句块**（`static{}`块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问\n\n由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作\n\n**同一个类加载器下，一个类型只会被初始化一次**\n\n### 类加载器\n**对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**\n\n每一个类加载器，都拥有一个独立的类名称空间\n\n三层类加载器\n+ 启动类加载器：这个类加载器负责加载存放在`<JAVA_HOME>\\lib`目录，或者被`-Xbootclasspath`参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如`rt.jar`、`tools.jar`，名字不符合的类库即使放在`lib`目录中也不会被加载）类库加载到虚拟机的内存中\n+ 扩展类加载器：负责加载`<JAVA_HOME>\\lib\\ext`目录中，或者被`java.ext.dirs`系统变量所指定的路径中所有的类库\n+ 应用程序加载器：`ClassLoader`类中的`getSystem-ClassLoader()`方法的返回值，所以有些场合中也称它为“系统类加载器”。负责加载用户类路径(`ClassPath`)上所有的类库，开发者同样可以直接在代码中使用这个类加载器\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/classloader.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类加载器双亲委派模型\n    </div>\n</center>\n\n#### 双亲委派模型\n双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用**组合**（Composition）关系来复用父加载器的代码。\n\n双亲委派模型的工作过程是：**如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。**\n\n破坏双亲委派模型：。。。","slug":"虚拟机执行","published":1,"updated":"2022-09-21T07:30:46.940Z","_id":"cl1aejytb0000g0tp84ergwts","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"Java编译器\"><a href=\"#Java编译器\" class=\"headerlink\" title=\"Java编译器\"></a>Java编译器</h2><p>解释器与编译器两者各有优势：</p>\n<ul>\n<li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行</li>\n<li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率</li>\n<li>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/interpreter_compiler.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        解释器与编译器的交互\n    </div>\n</center>\n\n<h3 id=\"编译器分类\"><a href=\"#编译器分类\" class=\"headerlink\" title=\"编译器分类\"></a>编译器分类</h3><ul>\n<li><strong>前端编译器</strong>：把<code>*.java</code>文件转变成<code>*.class</code>文件的过程<ul>\n<li>JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>\n</ul>\n</li>\n<li><strong>即时编译器</strong>：常称JIT编译器(Just In Time Compiler)，运行期把字节码转变成本地机器码的过程<ul>\n<li><strong>提高热点代码的执行效率</strong></li>\n<li>HotSpot虚拟机的C1、C2编译器，Graal编译器</li>\n</ul>\n</li>\n<li><strong>提前编译器</strong>：常称AOT编译器(Ahead Of Time Compiler)，直接把程序编译成与目标机器指令集相关的二进制代码的过程<ul>\n<li>JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java类文件结构\"><a href=\"#Java类文件结构\" class=\"headerlink\" title=\"Java类文件结构\"></a>Java类文件结构</h2><blockquote>\n<p>需要注意：Java中的类不必都以磁盘文件形式存在，可以动态生成，或者通过I/O输入等等</p>\n</blockquote>\n<p>任意有效的类或接口所满足的格式即为<strong>Class文件格式</strong></p>\n<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前(<code>Big Endian</code>)的方式分割成若干个8个字节进行存储。</p>\n<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong></p>\n<ul>\n<li><strong>无符号数</strong>属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>\n<li><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的复合数据类型，用于描述有层次关系的复合结构的数据。为了便于区分，所有表的命名都习惯性地以“_info”结尾。</li>\n</ul>\n<p>Class文件格式如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件格式\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_struc.png\">\n</center>\n\n<h3 id=\"魔数\"><a href=\"#魔数\" class=\"headerlink\" title=\"魔数\"></a>魔数</h3><p>每个Class文件的头4个字节被称为<strong>魔数(Magic Number)</strong>，它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong>。Class文件的魔数为<code>0xCAFEBABE</code></p>\n<p>紧接着，第5和第6个字节是<strong>次版本号</strong>(Minor Version)，第7和第8个字节是<strong>主版本号</strong>(Major Version)</p>\n<p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。Class文件与JDK版本的兼容关系如下图所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件版本号\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_version.png\">\n</center>\n\n<blockquote>\n<p>注：从JDK 9开始，Javac编译器不再支持使用-source参数编译版本号小于1.5的源码</p>\n</blockquote>\n<h3 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h3><p>版本号之后紧接着是常量池，它是<strong>Class文件结构中与其他项目关联最多的数据</strong>，通常也是<strong>占用Class文件空间最大的数据项目之一</strong></p>\n<p>常量池中常量的数量并不固定，因此需要先放置一项<code>u2</code>类型的数据，表示<strong>常量池容量计数值</strong>(constant_pool_count)</p>\n<blockquote>\n<p>Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始</p>\n</blockquote>\n<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p>\n<ul>\n<li><strong>字面量</strong>：文本字符串、被声明为final的常量值等</li>\n<li><strong>符号引用</strong>：<ul>\n<li>被模块导出或者开放的包</li>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n<li>方法句柄和方法类型</li>\n<li>动态调用点和动态常量</li>\n</ul>\n</li>\n</ul>\n<p>之后对常量池的解析是一种嵌套解析：因为每一个常量都是17种常量中的一种，有的格式简单；有的较为复杂，内部又由各种简单常量组成。总之，每个常量的解析都是先读取一个字节判断其属于17种常量中的哪一种，再根据这种常量的组成结构读取组成他的实际数据。Class文件组成紧密，并没有多余的停顿符号。</p>\n<blockquote>\n<p>更细致的解析过程详见原书6.3节，这里不再赘述</p>\n</blockquote>\n<p>17种常量类型如下：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        常量池的项目类型\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_constant.png\">\n</center>\n\n<h3 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h3><p>在常量池结束之后，<strong>紧接着的2个字节代表访问标志(access_flags)</strong>，这个标志用于<strong>识别一些类或者接口层次的访问信息</strong>，包括：</p>\n<ul>\n<li>这个Class是类还是接口；</li>\n<li>是否定义为public类型；</li>\n<li>是否定义为abstract类型；</li>\n<li>如果是类的话，是否被声明为final；等等</li>\n</ul>\n<p>当然，不同含义的标志位之间可以用 <code>|</code> 表示，具体的标志位以及标志的含义见下表：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_access_flag.png\">\n</center>\n\n<h3 id=\"类索引、父类索引与接口索引集合\"><a href=\"#类索引、父类索引与接口索引集合\" class=\"headerlink\" title=\"类索引、父类索引与接口索引集合\"></a>类索引、父类索引与接口索引集合</h3><p>类索引用于确定这个类的全限定名；</p>\n<p>父类索引用于确定这个类的父类的全限定名；</p>\n<p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>\n<p><strong>Class文件中由这三项数据来确定该类型的继承关系</strong></p>\n<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串。</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类索引查找全限定名的过程\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_this.png\">\n</center>\n\n<p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p>\n<h3 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h3><p>字段表（field_info）用于<strong>描述接口或者类中声明的变量</strong>，包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_info.png\">\n</center>\n\n<p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称</p>\n<p>字段修饰符放在<code>access_flags</code>项目中，它与类中的<code>access_flags</code>项目是非常类似的，都是一个<code>u2</code>的数据类型，其中可以设置的标志位和含义如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_access_flag.png\">\n</center>\n\n<h3 id=\"方法表集合\"><a href=\"#方法表集合\" class=\"headerlink\" title=\"方法表集合\"></a>方法表集合</h3><p>方法表中的数据项目的含义与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别</p>\n<blockquote>\n<p>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为<strong>Code</strong>的属性里面</p>\n</blockquote>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_info.png\">\n</center>\n\n<p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。其中可以设置的标志位和含义如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_access_flag.png\">\n</center>\n\n<h3 id=\"属性表集合\"><a href=\"#属性表集合\" class=\"headerlink\" title=\"属性表集合\"></a>属性表集合</h3><p>属性表集合的限制稍微宽松很多，不再要求各个属性表具有严格顺序</p>\n<blockquote>\n<p>《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息</p>\n</blockquote>\n<h4 id=\"Code属性\"><a href=\"#Code属性\" class=\"headerlink\" title=\"Code属性\"></a>Code属性</h4><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在<code>Code</code>属性内</p>\n<p><strong><code>Code</code>属性用于描述代码，所有的其他数据项目都用于描述元数据</strong></p>\n<p><code>Code</code>属性的结构将如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Code属性表的结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_code.png\">\n</center>\n\n<p>各属性简要解析：</p>\n<ul>\n<li><code>attribute_name_index</code>是一项指向<code>CONSTANT_Utf8_info</code>型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称</li>\n<li><code>attribute_length</code>指示了属性值的长度<ul>\n<li>属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节 </li>\n</ul>\n</li>\n<li><code>max_stack</code>代表了操作数栈（Operand Stack）深度的最大值</li>\n<li><code>max_locals</code>代表了局部变量表所需的存储空间<ul>\n<li><code>max_locals</code>的单位是变量槽（Slot），变量 槽是虚拟机为局部变量分配内存所使用的最小单位</li>\n<li>根据同时生存的最大局部变量数量和类型计算出<code>max_locals</code>的大小</li>\n</ul>\n</li>\n<li><code>code_length</code>和<code>code</code>用来存储Java源程序编译后生成的字节码指令<ul>\n<li><code>code_length</code>代表字节码长度</li>\n<li><code>code</code>是用于存储字节码指令的一系列字节流</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"异常表\"><a href=\"#异常表\" class=\"headerlink\" title=\"异常表\"></a>异常表</h5><p>异常表属于Java代码的一部分，是代码里显式能处理的异常</p>\n<p>如果存在异常表，那它的格式应如下表所示，包含四个字段，这些字段的含义为：如果当字节码从第<code>start_pc</code>行到第<code>end_pc</code>行之间（不含第<code>end_pc</code>行）出现了类型为<code>catch_type</code>或者其子类的异常（<code>catch_type</code>为指向一个<code>CONSTANT_Class_info</code>型常量的索引），则转到第<code>handler_pc</code>行继续处理。当<code>catch_type</code>的值为0时，代表任意异常情况都需要转到<code>handler_pc</code>处进行处理。</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        异常表属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exception_table.png\">\n</center>\n\n<h4 id=\"Exceptions属性\"><a href=\"#Exceptions属性\" class=\"headerlink\" title=\"Exceptions属性\"></a>Exceptions属性</h4><p><code>Exceptions</code>属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在<code>throws</code>关键字后面列举的异常</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Exceptions属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exceptions.png\">\n</center>\n\n<p>此属性中的<code>number_of_exceptions</code>项表示方法可能抛出<code>number_of_exceptions</code>种受查异常，每一种受查异常使用一个<code>exception_index_table</code>项表示；<code>exception_index_table</code>是一个指向常量池中 <code>CONSTANT_Class_info</code>型常量的索引，代表了该受查异常的类型。</p>\n<h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><h3 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_life_cycle.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类的生命周期\n    </div>\n</center>\n\n<h4 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h4><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流<ul>\n<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。 </li>\n<li>从网络中获取，这种场景最典型的应用就是Web Applet。 </li>\n<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>\n<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。 </li>\n<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>\n<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li>\n</ul>\n</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<h4 id=\"验证阶段\"><a href=\"#验证阶段\" class=\"headerlink\" title=\"验证阶段\"></a>验证阶段</h4><p>这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>\n<p>四个检验动作：</p>\n<ul>\n<li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理<ul>\n<li>是否以魔数0xCAFEBABE开头</li>\n<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>\n<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）</li>\n<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>\n<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>\n<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>\n</ul>\n</li>\n<li>元数据验证：对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息<ul>\n<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>\n<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>\n<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>\n<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）</li>\n</ul>\n</li>\n<li>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>\n<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>\n<li>保证方法体中的类型转换总是有效的</li>\n</ul>\n</li>\n<li>符号引用验证：主要目的是确保解析行为能正常执行；发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的可访问性是否可被当前类访问</li>\n</ul>\n</li>\n</ul>\n<p><strong>文件格式验证阶段的验证是基于二进制字节流进行的</strong>，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以<strong>后面的三个验证阶段全部是基于方法区的存储结构上进行的</strong>，不会再直接读取、操作字节流</p>\n<h4 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h4><p>准备阶段是正式<strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值</strong>的阶段</p>\n<ul>\n<li>这时候进行内存分配的仅包括类变量，而不包括实例变量</li>\n<li>初始值通常情况下是数值类型的零值（<code>final</code>字段会直接赋最终值）</li>\n</ul>\n<h4 id=\"解析阶段\"><a href=\"#解析阶段\" class=\"headerlink\" title=\"解析阶段\"></a>解析阶段</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>\n<ul>\n<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>\n<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在</li>\n</ul>\n<h4 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h4><p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</p>\n<ul>\n<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态语句块</strong>（<code>static{}</code>块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li>\n</ul>\n<p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</p>\n<p><strong>同一个类加载器下，一个类型只会被初始化一次</strong></p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p><strong>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性</strong></p>\n<p>每一个类加载器，都拥有一个独立的类名称空间</p>\n<p>三层类加载器</p>\n<ul>\n<li>启动类加载器：这个类加载器负责加载存放在<code>&lt;JAVA_HOME&gt;\\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如<code>rt.jar</code>、<code>tools.jar</code>，名字不符合的类库即使放在<code>lib</code>目录中也不会被加载）类库加载到虚拟机的内存中</li>\n<li>扩展类加载器：负责加载<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库</li>\n<li>应用程序加载器：<code>ClassLoader</code>类中的<code>getSystem-ClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。负责加载用户类路径(<code>ClassPath</code>)上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/classloader.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类加载器双亲委派模型\n    </div>\n</center>\n\n<h4 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h4><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用<strong>组合</strong>（Composition）关系来复用父加载器的代码。</p>\n<p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p>\n<p>破坏双亲委派模型：。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"Java编译器\"><a href=\"#Java编译器\" class=\"headerlink\" title=\"Java编译器\"></a>Java编译器</h2><p>解释器与编译器两者各有优势：</p>\n<ul>\n<li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行</li>\n<li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率</li>\n<li>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/interpreter_compiler.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        解释器与编译器的交互\n    </div>\n</center>\n\n<h3 id=\"编译器分类\"><a href=\"#编译器分类\" class=\"headerlink\" title=\"编译器分类\"></a>编译器分类</h3><ul>\n<li><strong>前端编译器</strong>：把<code>*.java</code>文件转变成<code>*.class</code>文件的过程<ul>\n<li>JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>\n</ul>\n</li>\n<li><strong>即时编译器</strong>：常称JIT编译器(Just In Time Compiler)，运行期把字节码转变成本地机器码的过程<ul>\n<li><strong>提高热点代码的执行效率</strong></li>\n<li>HotSpot虚拟机的C1、C2编译器，Graal编译器</li>\n</ul>\n</li>\n<li><strong>提前编译器</strong>：常称AOT编译器(Ahead Of Time Compiler)，直接把程序编译成与目标机器指令集相关的二进制代码的过程<ul>\n<li>JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java类文件结构\"><a href=\"#Java类文件结构\" class=\"headerlink\" title=\"Java类文件结构\"></a>Java类文件结构</h2><blockquote>\n<p>需要注意：Java中的类不必都以磁盘文件形式存在，可以动态生成，或者通过I/O输入等等</p>\n</blockquote>\n<p>任意有效的类或接口所满足的格式即为<strong>Class文件格式</strong></p>\n<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文 件之中，中间没有添加任何分隔符。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前(<code>Big Endian</code>)的方式分割成若干个8个字节进行存储。</p>\n<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数 据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong></p>\n<ul>\n<li><strong>无符号数</strong>属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>\n<li><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的复合数据类型，用于描述有层次关系的复合结构的数据。为了便于区分，所有表的命名都习惯性地以“_info”结尾。</li>\n</ul>\n<p>Class文件格式如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件格式\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_struc.png\">\n</center>\n\n<h3 id=\"魔数\"><a href=\"#魔数\" class=\"headerlink\" title=\"魔数\"></a>魔数</h3><p>每个Class文件的头4个字节被称为<strong>魔数(Magic Number)</strong>，它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接受的Class文件</strong>。Class文件的魔数为<code>0xCAFEBABE</code></p>\n<p>紧接着，第5和第6个字节是<strong>次版本号</strong>(Minor Version)，第7和第8个字节是<strong>主版本号</strong>(Major Version)</p>\n<p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。Class文件与JDK版本的兼容关系如下图所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Class文件版本号\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_version.png\">\n</center>\n\n<blockquote>\n<p>注：从JDK 9开始，Javac编译器不再支持使用-source参数编译版本号小于1.5的源码</p>\n</blockquote>\n<h3 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h3><p>版本号之后紧接着是常量池，它是<strong>Class文件结构中与其他项目关联最多的数据</strong>，通常也是<strong>占用Class文件空间最大的数据项目之一</strong></p>\n<p>常量池中常量的数量并不固定，因此需要先放置一项<code>u2</code>类型的数据，表示<strong>常量池容量计数值</strong>(constant_pool_count)</p>\n<blockquote>\n<p>Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始</p>\n</blockquote>\n<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）</p>\n<ul>\n<li><strong>字面量</strong>：文本字符串、被声明为final的常量值等</li>\n<li><strong>符号引用</strong>：<ul>\n<li>被模块导出或者开放的包</li>\n<li>类和接口的全限定名</li>\n<li>字段的名称和描述符</li>\n<li>方法的名称和描述符</li>\n<li>方法句柄和方法类型</li>\n<li>动态调用点和动态常量</li>\n</ul>\n</li>\n</ul>\n<p>之后对常量池的解析是一种嵌套解析：因为每一个常量都是17种常量中的一种，有的格式简单；有的较为复杂，内部又由各种简单常量组成。总之，每个常量的解析都是先读取一个字节判断其属于17种常量中的哪一种，再根据这种常量的组成结构读取组成他的实际数据。Class文件组成紧密，并没有多余的停顿符号。</p>\n<blockquote>\n<p>更细致的解析过程详见原书6.3节，这里不再赘述</p>\n</blockquote>\n<p>17种常量类型如下：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        常量池的项目类型\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_constant.png\">\n</center>\n\n<h3 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h3><p>在常量池结束之后，<strong>紧接着的2个字节代表访问标志(access_flags)</strong>，这个标志用于<strong>识别一些类或者接口层次的访问信息</strong>，包括：</p>\n<ul>\n<li>这个Class是类还是接口；</li>\n<li>是否定义为public类型；</li>\n<li>是否定义为abstract类型；</li>\n<li>如果是类的话，是否被声明为final；等等</li>\n</ul>\n<p>当然，不同含义的标志位之间可以用 <code>|</code> 表示，具体的标志位以及标志的含义见下表：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_access_flag.png\">\n</center>\n\n<h3 id=\"类索引、父类索引与接口索引集合\"><a href=\"#类索引、父类索引与接口索引集合\" class=\"headerlink\" title=\"类索引、父类索引与接口索引集合\"></a>类索引、父类索引与接口索引集合</h3><p>类索引用于确定这个类的全限定名；</p>\n<p>父类索引用于确定这个类的父类的全限定名；</p>\n<p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>\n<p><strong>Class文件中由这三项数据来确定该类型的继承关系</strong></p>\n<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串。</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类索引查找全限定名的过程\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_this.png\">\n</center>\n\n<p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p>\n<h3 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h3><p>字段表（field_info）用于<strong>描述接口或者类中声明的变量</strong>，包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_info.png\">\n</center>\n\n<p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称</p>\n<p>字段修饰符放在<code>access_flags</code>项目中，它与类中的<code>access_flags</code>项目是非常类似的，都是一个<code>u2</code>的数据类型，其中可以设置的标志位和含义如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        字段访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_attr_access_flag.png\">\n</center>\n\n<h3 id=\"方法表集合\"><a href=\"#方法表集合\" class=\"headerlink\" title=\"方法表集合\"></a>方法表集合</h3><p>方法表中的数据项目的含义与字段表中的非常类似，仅在访问标志和属性表集合的可选项中有所区别</p>\n<blockquote>\n<p>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为<strong>Code</strong>的属性里面</p>\n</blockquote>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_info.png\">\n</center>\n\n<p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。其中可以设置的标志位和含义如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法访问标志\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_method_access_flag.png\">\n</center>\n\n<h3 id=\"属性表集合\"><a href=\"#属性表集合\" class=\"headerlink\" title=\"属性表集合\"></a>属性表集合</h3><p>属性表集合的限制稍微宽松很多，不再要求各个属性表具有严格顺序</p>\n<blockquote>\n<p>《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息</p>\n</blockquote>\n<h4 id=\"Code属性\"><a href=\"#Code属性\" class=\"headerlink\" title=\"Code属性\"></a>Code属性</h4><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在<code>Code</code>属性内</p>\n<p><strong><code>Code</code>属性用于描述代码，所有的其他数据项目都用于描述元数据</strong></p>\n<p><code>Code</code>属性的结构将如下表所示：</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Code属性表的结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_code.png\">\n</center>\n\n<p>各属性简要解析：</p>\n<ul>\n<li><code>attribute_name_index</code>是一项指向<code>CONSTANT_Utf8_info</code>型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称</li>\n<li><code>attribute_length</code>指示了属性值的长度<ul>\n<li>属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节 </li>\n</ul>\n</li>\n<li><code>max_stack</code>代表了操作数栈（Operand Stack）深度的最大值</li>\n<li><code>max_locals</code>代表了局部变量表所需的存储空间<ul>\n<li><code>max_locals</code>的单位是变量槽（Slot），变量 槽是虚拟机为局部变量分配内存所使用的最小单位</li>\n<li>根据同时生存的最大局部变量数量和类型计算出<code>max_locals</code>的大小</li>\n</ul>\n</li>\n<li><code>code_length</code>和<code>code</code>用来存储Java源程序编译后生成的字节码指令<ul>\n<li><code>code_length</code>代表字节码长度</li>\n<li><code>code</code>是用于存储字节码指令的一系列字节流</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"异常表\"><a href=\"#异常表\" class=\"headerlink\" title=\"异常表\"></a>异常表</h5><p>异常表属于Java代码的一部分，是代码里显式能处理的异常</p>\n<p>如果存在异常表，那它的格式应如下表所示，包含四个字段，这些字段的含义为：如果当字节码从第<code>start_pc</code>行到第<code>end_pc</code>行之间（不含第<code>end_pc</code>行）出现了类型为<code>catch_type</code>或者其子类的异常（<code>catch_type</code>为指向一个<code>CONSTANT_Class_info</code>型常量的索引），则转到第<code>handler_pc</code>行继续处理。当<code>catch_type</code>的值为0时，代表任意异常情况都需要转到<code>handler_pc</code>处进行处理。</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        异常表属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exception_table.png\">\n</center>\n\n<h4 id=\"Exceptions属性\"><a href=\"#Exceptions属性\" class=\"headerlink\" title=\"Exceptions属性\"></a>Exceptions属性</h4><p><code>Exceptions</code>属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在<code>throws</code>关键字后面列举的异常</p>\n<center>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Exceptions属性结构\n    </div>\n    <br>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_exceptions.png\">\n</center>\n\n<p>此属性中的<code>number_of_exceptions</code>项表示方法可能抛出<code>number_of_exceptions</code>种受查异常，每一种受查异常使用一个<code>exception_index_table</code>项表示；<code>exception_index_table</code>是一个指向常量池中 <code>CONSTANT_Class_info</code>型常量的索引，代表了该受查异常的类型。</p>\n<h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><h3 id=\"类加载的过程\"><a href=\"#类加载的过程\" class=\"headerlink\" title=\"类加载的过程\"></a>类加载的过程</h3><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如下图所示。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/class_life_cycle.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类的生命周期\n    </div>\n</center>\n\n<h4 id=\"加载阶段\"><a href=\"#加载阶段\" class=\"headerlink\" title=\"加载阶段\"></a>加载阶段</h4><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流<ul>\n<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。 </li>\n<li>从网络中获取，这种场景最典型的应用就是Web Applet。 </li>\n<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>\n<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。 </li>\n<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>\n<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li>\n</ul>\n</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<h4 id=\"验证阶段\"><a href=\"#验证阶段\" class=\"headerlink\" title=\"验证阶段\"></a>验证阶段</h4><p>这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>\n<p>四个检验动作：</p>\n<ul>\n<li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理<ul>\n<li>是否以魔数0xCAFEBABE开头</li>\n<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>\n<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）</li>\n<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>\n<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>\n<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>\n</ul>\n</li>\n<li>元数据验证：对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息<ul>\n<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>\n<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>\n<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>\n<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）</li>\n</ul>\n</li>\n<li>字节码验证：通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li>\n<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>\n<li>保证方法体中的类型转换总是有效的</li>\n</ul>\n</li>\n<li>符号引用验证：主要目的是确保解析行为能正常执行；发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>\n<li>符号引用中的类、字段、方法的可访问性是否可被当前类访问</li>\n</ul>\n</li>\n</ul>\n<p><strong>文件格式验证阶段的验证是基于二进制字节流进行的</strong>，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以<strong>后面的三个验证阶段全部是基于方法区的存储结构上进行的</strong>，不会再直接读取、操作字节流</p>\n<h4 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h4><p>准备阶段是正式<strong>为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值</strong>的阶段</p>\n<ul>\n<li>这时候进行内存分配的仅包括类变量，而不包括实例变量</li>\n<li>初始值通常情况下是数值类型的零值（<code>final</code>字段会直接赋最终值）</li>\n</ul>\n<h4 id=\"解析阶段\"><a href=\"#解析阶段\" class=\"headerlink\" title=\"解析阶段\"></a>解析阶段</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>\n<ul>\n<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>\n<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在</li>\n</ul>\n<h4 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h4><p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</p>\n<ul>\n<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态语句块</strong>（<code>static{}</code>块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问</li>\n</ul>\n<p>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作</p>\n<p><strong>同一个类加载器下，一个类型只会被初始化一次</strong></p>\n<h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><p><strong>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性</strong></p>\n<p>每一个类加载器，都拥有一个独立的类名称空间</p>\n<p>三层类加载器</p>\n<ul>\n<li>启动类加载器：这个类加载器负责加载存放在<code>&lt;JAVA_HOME&gt;\\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如<code>rt.jar</code>、<code>tools.jar</code>，名字不符合的类库即使放在<code>lib</code>目录中也不会被加载）类库加载到虚拟机的内存中</li>\n<li>扩展类加载器：负责加载<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库</li>\n<li>应用程序加载器：<code>ClassLoader</code>类中的<code>getSystem-ClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。负责加载用户类路径(<code>ClassPath</code>)上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li>\n</ul>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/classloader.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        类加载器双亲委派模型\n    </div>\n</center>\n\n<h4 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h4><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用<strong>组合</strong>（Composition）关系来复用父加载器的代码。</p>\n<p>双亲委派模型的工作过程是：<strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong></p>\n<p>破坏双亲委派模型：。。。</p>\n"},{"title":"方法调用","date":"2022-03-29T06:30:59.000Z","top_img":"/img/cover/method_invoke.jpg","cover":"/img/cover/method_invoke.jpg","_content":"\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## 方法调用\n前面已经了解了`Class`文件的组成结构，了解了字节码的组成方式以及被加载到内存中的过程，并且虚拟机的运行时数据区域结构也已经描述过，接下来了解虚拟机的方法调用过程\n\n方法调用过程并不是代码执行过程，而是指**如何确定被调用方法的版本的过程**。\n\n按之前的了解，`Class`文件中的常量池一项中记录了类相关的符号引用，类加载之后就保存在运行时常量池中。\n\n这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析**。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为**动态连接**。\n\n### 解析\n在**类加载的解析阶段**，有部分符号引用会转化成直接引用，这类方法的特点是：**方法在程序运行之前就有一个可确定且唯一的版本，并且这个方法的调用版本在运行期不会被改变**。\n\n能被`invokestatic`和`invokespecial`指令调用的方法，都满足以上特点，因此可以在解析阶段转换，更准确的说是以下5类方法：\n+ **静态方法**\n+ **私有方法**\n+ **实例构造器`<init>()`方法**\n+ **父类方法**\n+ **被`final`修饰的方法**（它使用`invokevirtual`指令调用）\n\n这些方法统称为“非虚方法”(Non-Virtual Method)，与之相反，其他方法就被称为“虚方法”(Virtual Method)\n\n解析调用一定是个**静态**的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。\n\n### 分派\n分派(Dispatch)调用复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况\n\n#### 1.静态分派\n所有**依赖静态类型来决定方法执行版本的分派**动作，都称为静态分派。静态分派最典型应用表现就是**方法重载**\n\n首先解释静态类型和实际类型：\n+ 静态类型：静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的\n+ 实际类型：实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么\n\n示例代码：\n```java\npackage org.fenixsoft.polymorphic;\n\n/**\n * 方法静态分派演示\n * @author zzm\n */ \npublic class StaticDispatch {\n\n    static abstract class Human { }\n    static class Man extends Human { }\n    static class Woman extends Human { }\n    \n    public void sayHello(Human guy) {\n        System.out.println(\"hello,guy!\");\n    }\n    \n    public void sayHello(Man guy) {\n        System.out.println(\"hello,gentleman!\");\n    }\n    \n    public void sayHello(Woman guy) {\n        System.out.println(\"hello,lady!\");\n    }\n    \n    public static void main(String[] args) {\n        Human man = new Man();\n        Human woman = new Woman();\n        StaticDispatch sr = new StaticDispatch();\n        sr.sayHello(man);   // 1\n        sr.sayHello(woman); // 2\n\n        sr.sayHello((Man)man);  // 3\n        sr.sayHello((Woman)woman);  // 4\n    }\n}\n```\n如上，对于变量`man`，它的静态类型是`Human`，而它的实际类型是`Man`。编译器在编译时可以确定的是静态类型（因为实际类型有可能是`Man`或者`Woman`），所以静态分派只会根据变量的静态类型确定调用的方法类型。\n\n以上代码的输出：\n```sh\nhello,guy!\nhello,guy!\nhello,gentleman!\nhello,lady!\n```\n\n> 注意：Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。（详细案例见书本8.3.2节）\n\n#### 2.动态分派\n**在运行期根据实际类型确定方法执行版本的分派**过程称为动态分派。\n\n这与面向对象的**重写**对应，Java的多态就体现在这。\n\n> 这很类似于c++中的虚函数调用\n\n`invokevirtual`指令先找到对象的实际类型，然后查找它的方法是否存在符合的，如果没有，就去查找其父类，以此类推。因此，**实际类型**在这里十分关键。\n\n示例代码如下：\n```java\npackage org.fenixsoft.polymorphic;\n\n/**\n  * 方法动态分派演示\n  * @author zzm\n  */\npublic class DynamicDispatch {\n    static abstract class Human {\n        protected abstract void sayHello();\n    }\n\n    static class Man extends Human {\n        @Override\n        protected void sayHello() {\n            System.out.println(\"man say hello\");\n        }\n    }\n\n    static class Woman extends Human {\n        @Override\n        protected void sayHello() {\n            System.out.println(\"woman say hello\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        Human man = new Man();\n        Human woman = new Woman();\n        man.sayHello();\n        woman.sayHello();\n        man = new Woman();\n        man.sayHello();\n    }\n}\n```\n输出如下：\n```sh\nman say hello\nwoman say hello\nwoman say hello\n```\n\n> 书上的第2个例子很有趣，值得一看，这里不再赘述\n\n动态分派通过在类的方法区中建立**虚方法表**(Virtual Method Table，也称为vtable)来实现。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。\n\n> 这与c++很类似\n\n方法表结构示意图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/vtable.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n</center>\n\n#### 3.单分派与多分派\n方法调用者和方法参数都是宗量\n\nJava中静态分派的方法调用，首先确定调用者的静态类型是什么，然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个，需要根据这两个宗量来编译，所以是静态分派是多分派\n\nJava中动态分派的方法调用，在运行期间，虚拟机会根据调用者的实际类型调用对应的方法，秩序根据这一个宗量就可以确定要调用的方法，所以动态分派是单分派\n\n### 动态类型语言支持\n动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、 JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl等等\n\n静态类型语言与动态类型语言的优缺点：\n+ 静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。\n+ 动态类型语言在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通常也就意味着开发效率的提升。\n\nJava并不是动态类型语言，因此接下来要说的`invokedynamic`指令貌似与平常的使用无关，是Java虚拟机为支持其他语言在虚拟机上的使用而做的实现\n\n> `invokedynamic`指令具体的示例细节见8.4.4节，这里不赘述了\n\n每一处含有`invokedynamic`指令的位置都被称作“动态调用点(`Dynamically-Computed Call Site`)”，这条指令的第一个参数不再是代表方法符号引用的`CONSTANT_Methodref_info`常量，而是变为JDK 7时新加入的`CONSTANT_InvokeDynamic_info`常量，从这个新常量中可以得到3项信息：引导方法(`BootstrapMethod`，该方法存放在新增的`BootstrapMethods`属性中）、方法类型(`MethodType`)和名称。引导方法是有固定的参数，并且返回值规定是`java.lang.invoke.CallSite`对象，这个对象代表了真正要执行的目标方法调用。根据`CONSTANT_InvokeDynamic_info`常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个`CallSite`对象，最终调用到要执行的目标方法上。\n","source":"_posts/方法调用.md","raw":"---\ntitle: 方法调用\ndate: 2022-03-29 14:30:59\ntop_img: /img/cover/method_invoke.jpg\ncover: /img/cover/method_invoke.jpg\ntags: [Java, 笔记]\n---\n\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## 方法调用\n前面已经了解了`Class`文件的组成结构，了解了字节码的组成方式以及被加载到内存中的过程，并且虚拟机的运行时数据区域结构也已经描述过，接下来了解虚拟机的方法调用过程\n\n方法调用过程并不是代码执行过程，而是指**如何确定被调用方法的版本的过程**。\n\n按之前的了解，`Class`文件中的常量池一项中记录了类相关的符号引用，类加载之后就保存在运行时常量池中。\n\n这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为**静态解析**。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为**动态连接**。\n\n### 解析\n在**类加载的解析阶段**，有部分符号引用会转化成直接引用，这类方法的特点是：**方法在程序运行之前就有一个可确定且唯一的版本，并且这个方法的调用版本在运行期不会被改变**。\n\n能被`invokestatic`和`invokespecial`指令调用的方法，都满足以上特点，因此可以在解析阶段转换，更准确的说是以下5类方法：\n+ **静态方法**\n+ **私有方法**\n+ **实例构造器`<init>()`方法**\n+ **父类方法**\n+ **被`final`修饰的方法**（它使用`invokevirtual`指令调用）\n\n这些方法统称为“非虚方法”(Non-Virtual Method)，与之相反，其他方法就被称为“虚方法”(Virtual Method)\n\n解析调用一定是个**静态**的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。\n\n### 分派\n分派(Dispatch)调用复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况\n\n#### 1.静态分派\n所有**依赖静态类型来决定方法执行版本的分派**动作，都称为静态分派。静态分派最典型应用表现就是**方法重载**\n\n首先解释静态类型和实际类型：\n+ 静态类型：静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的\n+ 实际类型：实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么\n\n示例代码：\n```java\npackage org.fenixsoft.polymorphic;\n\n/**\n * 方法静态分派演示\n * @author zzm\n */ \npublic class StaticDispatch {\n\n    static abstract class Human { }\n    static class Man extends Human { }\n    static class Woman extends Human { }\n    \n    public void sayHello(Human guy) {\n        System.out.println(\"hello,guy!\");\n    }\n    \n    public void sayHello(Man guy) {\n        System.out.println(\"hello,gentleman!\");\n    }\n    \n    public void sayHello(Woman guy) {\n        System.out.println(\"hello,lady!\");\n    }\n    \n    public static void main(String[] args) {\n        Human man = new Man();\n        Human woman = new Woman();\n        StaticDispatch sr = new StaticDispatch();\n        sr.sayHello(man);   // 1\n        sr.sayHello(woman); // 2\n\n        sr.sayHello((Man)man);  // 3\n        sr.sayHello((Woman)woman);  // 4\n    }\n}\n```\n如上，对于变量`man`，它的静态类型是`Human`，而它的实际类型是`Man`。编译器在编译时可以确定的是静态类型（因为实际类型有可能是`Man`或者`Woman`），所以静态分派只会根据变量的静态类型确定调用的方法类型。\n\n以上代码的输出：\n```sh\nhello,guy!\nhello,guy!\nhello,gentleman!\nhello,lady!\n```\n\n> 注意：Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。（详细案例见书本8.3.2节）\n\n#### 2.动态分派\n**在运行期根据实际类型确定方法执行版本的分派**过程称为动态分派。\n\n这与面向对象的**重写**对应，Java的多态就体现在这。\n\n> 这很类似于c++中的虚函数调用\n\n`invokevirtual`指令先找到对象的实际类型，然后查找它的方法是否存在符合的，如果没有，就去查找其父类，以此类推。因此，**实际类型**在这里十分关键。\n\n示例代码如下：\n```java\npackage org.fenixsoft.polymorphic;\n\n/**\n  * 方法动态分派演示\n  * @author zzm\n  */\npublic class DynamicDispatch {\n    static abstract class Human {\n        protected abstract void sayHello();\n    }\n\n    static class Man extends Human {\n        @Override\n        protected void sayHello() {\n            System.out.println(\"man say hello\");\n        }\n    }\n\n    static class Woman extends Human {\n        @Override\n        protected void sayHello() {\n            System.out.println(\"woman say hello\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        Human man = new Man();\n        Human woman = new Woman();\n        man.sayHello();\n        woman.sayHello();\n        man = new Woman();\n        man.sayHello();\n    }\n}\n```\n输出如下：\n```sh\nman say hello\nwoman say hello\nwoman say hello\n```\n\n> 书上的第2个例子很有趣，值得一看，这里不再赘述\n\n动态分派通过在类的方法区中建立**虚方法表**(Virtual Method Table，也称为vtable)来实现。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。\n\n> 这与c++很类似\n\n方法表结构示意图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/vtable.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n</center>\n\n#### 3.单分派与多分派\n方法调用者和方法参数都是宗量\n\nJava中静态分派的方法调用，首先确定调用者的静态类型是什么，然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个，需要根据这两个宗量来编译，所以是静态分派是多分派\n\nJava中动态分派的方法调用，在运行期间，虚拟机会根据调用者的实际类型调用对应的方法，秩序根据这一个宗量就可以确定要调用的方法，所以动态分派是单分派\n\n### 动态类型语言支持\n动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、 JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl等等\n\n静态类型语言与动态类型语言的优缺点：\n+ 静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。\n+ 动态类型语言在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通常也就意味着开发效率的提升。\n\nJava并不是动态类型语言，因此接下来要说的`invokedynamic`指令貌似与平常的使用无关，是Java虚拟机为支持其他语言在虚拟机上的使用而做的实现\n\n> `invokedynamic`指令具体的示例细节见8.4.4节，这里不赘述了\n\n每一处含有`invokedynamic`指令的位置都被称作“动态调用点(`Dynamically-Computed Call Site`)”，这条指令的第一个参数不再是代表方法符号引用的`CONSTANT_Methodref_info`常量，而是变为JDK 7时新加入的`CONSTANT_InvokeDynamic_info`常量，从这个新常量中可以得到3项信息：引导方法(`BootstrapMethod`，该方法存放在新增的`BootstrapMethods`属性中）、方法类型(`MethodType`)和名称。引导方法是有固定的参数，并且返回值规定是`java.lang.invoke.CallSite`对象，这个对象代表了真正要执行的目标方法调用。根据`CONSTANT_InvokeDynamic_info`常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个`CallSite`对象，最终调用到要执行的目标方法上。\n","slug":"方法调用","published":1,"updated":"2022-09-21T07:30:46.940Z","_id":"cl1bv8yw00000aktpa2p28h64","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h2><p>前面已经了解了<code>Class</code>文件的组成结构，了解了字节码的组成方式以及被加载到内存中的过程，并且虚拟机的运行时数据区域结构也已经描述过，接下来了解虚拟机的方法调用过程</p>\n<p>方法调用过程并不是代码执行过程，而是指<strong>如何确定被调用方法的版本的过程</strong>。</p>\n<p>按之前的了解，<code>Class</code>文件中的常量池一项中记录了类相关的符号引用，类加载之后就保存在运行时常量池中。</p>\n<p>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为<strong>静态解析</strong>。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为<strong>动态连接</strong>。</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>在<strong>类加载的解析阶段</strong>，有部分符号引用会转化成直接引用，这类方法的特点是：<strong>方法在程序运行之前就有一个可确定且唯一的版本，并且这个方法的调用版本在运行期不会被改变</strong>。</p>\n<p>能被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法，都满足以上特点，因此可以在解析阶段转换，更准确的说是以下5类方法：</p>\n<ul>\n<li><strong>静态方法</strong></li>\n<li><strong>私有方法</strong></li>\n<li><strong>实例构造器<code>&lt;init&gt;()</code>方法</strong></li>\n<li><strong>父类方法</strong></li>\n<li><strong>被<code>final</code>修饰的方法</strong>（它使用<code>invokevirtual</code>指令调用）</li>\n</ul>\n<p>这些方法统称为“非虚方法”(Non-Virtual Method)，与之相反，其他方法就被称为“虚方法”(Virtual Method)</p>\n<p>解析调用一定是个<strong>静态</strong>的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p>\n<h3 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h3><p>分派(Dispatch)调用复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况</p>\n<h4 id=\"1-静态分派\"><a href=\"#1-静态分派\" class=\"headerlink\" title=\"1.静态分派\"></a>1.静态分派</h4><p>所有<strong>依赖静态类型来决定方法执行版本的分派</strong>动作，都称为静态分派。静态分派最典型应用表现就是<strong>方法重载</strong></p>\n<p>首先解释静态类型和实际类型：</p>\n<ul>\n<li>静态类型：静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的</li>\n<li>实际类型：实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么</li>\n</ul>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.fenixsoft.polymorphic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法静态分派演示</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zzm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StaticDispatch</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(Human guy)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,guy!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(Man guy)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,gentleman!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(Woman guy)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,lady!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human man = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\">        Human woman = <span class=\"keyword\">new</span> Woman();</span><br><span class=\"line\">        StaticDispatch sr = <span class=\"keyword\">new</span> StaticDispatch();</span><br><span class=\"line\">        sr.sayHello(man);   <span class=\"comment\">// 1</span></span><br><span class=\"line\">        sr.sayHello(woman); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        sr.sayHello((Man)man);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">        sr.sayHello((Woman)woman);  <span class=\"comment\">// 4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如上，对于变量<code>man</code>，它的静态类型是<code>Human</code>，而它的实际类型是<code>Man</code>。编译器在编译时可以确定的是静态类型（因为实际类型有可能是<code>Man</code>或者<code>Woman</code>），所以静态分派只会根据变量的静态类型确定调用的方法类型。</p>\n<p>以上代码的输出：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello,guy!</span><br><span class=\"line\">hello,guy!</span><br><span class=\"line\">hello,gentleman!</span><br><span class=\"line\">hello,lady!</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。（详细案例见书本8.3.2节）</p>\n</blockquote>\n<h4 id=\"2-动态分派\"><a href=\"#2-动态分派\" class=\"headerlink\" title=\"2.动态分派\"></a>2.动态分派</h4><p><strong>在运行期根据实际类型确定方法执行版本的分派</strong>过程称为动态分派。</p>\n<p>这与面向对象的<strong>重写</strong>对应，Java的多态就体现在这。</p>\n<blockquote>\n<p>这很类似于c++中的虚函数调用</p>\n</blockquote>\n<p><code>invokevirtual</code>指令先找到对象的实际类型，然后查找它的方法是否存在符合的，如果没有，就去查找其父类，以此类推。因此，<strong>实际类型</strong>在这里十分关键。</p>\n<p>示例代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.fenixsoft.polymorphic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 方法动态分派演示</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@author</span> zzm</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDispatch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"man say hello\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"woman say hello\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human man = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\">        Human woman = <span class=\"keyword\">new</span> Woman();</span><br><span class=\"line\">        man.sayHello();</span><br><span class=\"line\">        woman.sayHello();</span><br><span class=\"line\">        man = <span class=\"keyword\">new</span> Woman();</span><br><span class=\"line\">        man.sayHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>输出如下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man say hello</span><br><span class=\"line\">woman say hello</span><br><span class=\"line\">woman say hello</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>书上的第2个例子很有趣，值得一看，这里不再赘述</p>\n</blockquote>\n<p>动态分派通过在类的方法区中建立<strong>虚方法表</strong>(Virtual Method Table，也称为vtable)来实现。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>\n<blockquote>\n<p>这与c++很类似</p>\n</blockquote>\n<p>方法表结构示意图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/vtable.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n</center>\n\n<h4 id=\"3-单分派与多分派\"><a href=\"#3-单分派与多分派\" class=\"headerlink\" title=\"3.单分派与多分派\"></a>3.单分派与多分派</h4><p>方法调用者和方法参数都是宗量</p>\n<p>Java中静态分派的方法调用，首先确定调用者的静态类型是什么，然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个，需要根据这两个宗量来编译，所以是静态分派是多分派</p>\n<p>Java中动态分派的方法调用，在运行期间，虚拟机会根据调用者的实际类型调用对应的方法，秩序根据这一个宗量就可以确定要调用的方法，所以动态分派是单分派</p>\n<h3 id=\"动态类型语言支持\"><a href=\"#动态类型语言支持\" class=\"headerlink\" title=\"动态类型语言支持\"></a>动态类型语言支持</h3><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、 JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl等等</p>\n<p>静态类型语言与动态类型语言的优缺点：</p>\n<ul>\n<li>静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。</li>\n<li>动态类型语言在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通常也就意味着开发效率的提升。</li>\n</ul>\n<p>Java并不是动态类型语言，因此接下来要说的<code>invokedynamic</code>指令貌似与平常的使用无关，是Java虚拟机为支持其他语言在虚拟机上的使用而做的实现</p>\n<blockquote>\n<p><code>invokedynamic</code>指令具体的示例细节见8.4.4节，这里不赘述了</p>\n</blockquote>\n<p>每一处含有<code>invokedynamic</code>指令的位置都被称作“动态调用点(<code>Dynamically-Computed Call Site</code>)”，这条指令的第一个参数不再是代表方法符号引用的<code>CONSTANT_Methodref_info</code>常量，而是变为JDK 7时新加入的<code>CONSTANT_InvokeDynamic_info</code>常量，从这个新常量中可以得到3项信息：引导方法(<code>BootstrapMethod</code>，该方法存放在新增的<code>BootstrapMethods</code>属性中）、方法类型(<code>MethodType</code>)和名称。引导方法是有固定的参数，并且返回值规定是<code>java.lang.invoke.CallSite</code>对象，这个对象代表了真正要执行的目标方法调用。根据<code>CONSTANT_InvokeDynamic_info</code>常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个<code>CallSite</code>对象，最终调用到要执行的目标方法上。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"方法调用\"></a>方法调用</h2><p>前面已经了解了<code>Class</code>文件的组成结构，了解了字节码的组成方式以及被加载到内存中的过程，并且虚拟机的运行时数据区域结构也已经描述过，接下来了解虚拟机的方法调用过程</p>\n<p>方法调用过程并不是代码执行过程，而是指<strong>如何确定被调用方法的版本的过程</strong>。</p>\n<p>按之前的了解，<code>Class</code>文件中的常量池一项中记录了类相关的符号引用，类加载之后就保存在运行时常量池中。</p>\n<p>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为<strong>静态解析</strong>。另外一部分将在每一次运行期间都转化为直接引用，这部分就称为<strong>动态连接</strong>。</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>在<strong>类加载的解析阶段</strong>，有部分符号引用会转化成直接引用，这类方法的特点是：<strong>方法在程序运行之前就有一个可确定且唯一的版本，并且这个方法的调用版本在运行期不会被改变</strong>。</p>\n<p>能被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法，都满足以上特点，因此可以在解析阶段转换，更准确的说是以下5类方法：</p>\n<ul>\n<li><strong>静态方法</strong></li>\n<li><strong>私有方法</strong></li>\n<li><strong>实例构造器<code>&lt;init&gt;()</code>方法</strong></li>\n<li><strong>父类方法</strong></li>\n<li><strong>被<code>final</code>修饰的方法</strong>（它使用<code>invokevirtual</code>指令调用）</li>\n</ul>\n<p>这些方法统称为“非虚方法”(Non-Virtual Method)，与之相反，其他方法就被称为“虚方法”(Virtual Method)</p>\n<p>解析调用一定是个<strong>静态</strong>的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p>\n<h3 id=\"分派\"><a href=\"#分派\" class=\"headerlink\" title=\"分派\"></a>分派</h3><p>分派(Dispatch)调用复杂许多，它可能是静态的也可能是动态的，按照分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派4种分派组合情况</p>\n<h4 id=\"1-静态分派\"><a href=\"#1-静态分派\" class=\"headerlink\" title=\"1.静态分派\"></a>1.静态分派</h4><p>所有<strong>依赖静态类型来决定方法执行版本的分派</strong>动作，都称为静态分派。静态分派最典型应用表现就是<strong>方法重载</strong></p>\n<p>首先解释静态类型和实际类型：</p>\n<ul>\n<li>静态类型：静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的</li>\n<li>实际类型：实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么</li>\n</ul>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.fenixsoft.polymorphic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 方法静态分派演示</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> zzm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StaticDispatch</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(Human guy)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,guy!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(Man guy)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,gentleman!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">(Woman guy)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hello,lady!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human man = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\">        Human woman = <span class=\"keyword\">new</span> Woman();</span><br><span class=\"line\">        StaticDispatch sr = <span class=\"keyword\">new</span> StaticDispatch();</span><br><span class=\"line\">        sr.sayHello(man);   <span class=\"comment\">// 1</span></span><br><span class=\"line\">        sr.sayHello(woman); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        sr.sayHello((Man)man);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">        sr.sayHello((Woman)woman);  <span class=\"comment\">// 4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如上，对于变量<code>man</code>，它的静态类型是<code>Human</code>，而它的实际类型是<code>Man</code>。编译器在编译时可以确定的是静态类型（因为实际类型有可能是<code>Man</code>或者<code>Woman</code>），所以静态分派只会根据变量的静态类型确定调用的方法类型。</p>\n<p>以上代码的输出：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hello,guy!</span><br><span class=\"line\">hello,guy!</span><br><span class=\"line\">hello,gentleman!</span><br><span class=\"line\">hello,lady!</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。（详细案例见书本8.3.2节）</p>\n</blockquote>\n<h4 id=\"2-动态分派\"><a href=\"#2-动态分派\" class=\"headerlink\" title=\"2.动态分派\"></a>2.动态分派</h4><p><strong>在运行期根据实际类型确定方法执行版本的分派</strong>过程称为动态分派。</p>\n<p>这与面向对象的<strong>重写</strong>对应，Java的多态就体现在这。</p>\n<blockquote>\n<p>这很类似于c++中的虚函数调用</p>\n</blockquote>\n<p><code>invokevirtual</code>指令先找到对象的实际类型，然后查找它的方法是否存在符合的，如果没有，就去查找其父类，以此类推。因此，<strong>实际类型</strong>在这里十分关键。</p>\n<p>示例代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.fenixsoft.polymorphic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 方法动态分派演示</span></span><br><span class=\"line\"><span class=\"comment\">  * <span class=\"doctag\">@author</span> zzm</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDispatch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"man say hello\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Woman</span> <span class=\"keyword\">extends</span> <span class=\"title\">Human</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"woman say hello\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Human man = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\">        Human woman = <span class=\"keyword\">new</span> Woman();</span><br><span class=\"line\">        man.sayHello();</span><br><span class=\"line\">        woman.sayHello();</span><br><span class=\"line\">        man = <span class=\"keyword\">new</span> Woman();</span><br><span class=\"line\">        man.sayHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>输出如下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man say hello</span><br><span class=\"line\">woman say hello</span><br><span class=\"line\">woman say hello</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>书上的第2个例子很有趣，值得一看，这里不再赘述</p>\n</blockquote>\n<p>动态分派通过在类的方法区中建立<strong>虚方法表</strong>(Virtual Method Table，也称为vtable)来实现。虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>\n<blockquote>\n<p>这与c++很类似</p>\n</blockquote>\n<p>方法表结构示意图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/vtable.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        方法表结构\n    </div>\n</center>\n\n<h4 id=\"3-单分派与多分派\"><a href=\"#3-单分派与多分派\" class=\"headerlink\" title=\"3.单分派与多分派\"></a>3.单分派与多分派</h4><p>方法调用者和方法参数都是宗量</p>\n<p>Java中静态分派的方法调用，首先确定调用者的静态类型是什么，然后根据要调用的方法参数的静态类型(声明类型)确定所有重载方法中要调用哪一个，需要根据这两个宗量来编译，所以是静态分派是多分派</p>\n<p>Java中动态分派的方法调用，在运行期间，虚拟机会根据调用者的实际类型调用对应的方法，秩序根据这一个宗量就可以确定要调用的方法，所以动态分派是单分派</p>\n<h3 id=\"动态类型语言支持\"><a href=\"#动态类型语言支持\" class=\"headerlink\" title=\"动态类型语言支持\"></a>动态类型语言支持</h3><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：APL、Clojure、Erlang、Groovy、 JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl等等</p>\n<p>静态类型语言与动态类型语言的优缺点：</p>\n<ul>\n<li>静态类型语言能够在编译期确定变量类型，最显著的好处是编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。</li>\n<li>动态类型语言在运行期才确定类型，这可以为开发人员提供极大的灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，清晰简洁通常也就意味着开发效率的提升。</li>\n</ul>\n<p>Java并不是动态类型语言，因此接下来要说的<code>invokedynamic</code>指令貌似与平常的使用无关，是Java虚拟机为支持其他语言在虚拟机上的使用而做的实现</p>\n<blockquote>\n<p><code>invokedynamic</code>指令具体的示例细节见8.4.4节，这里不赘述了</p>\n</blockquote>\n<p>每一处含有<code>invokedynamic</code>指令的位置都被称作“动态调用点(<code>Dynamically-Computed Call Site</code>)”，这条指令的第一个参数不再是代表方法符号引用的<code>CONSTANT_Methodref_info</code>常量，而是变为JDK 7时新加入的<code>CONSTANT_InvokeDynamic_info</code>常量，从这个新常量中可以得到3项信息：引导方法(<code>BootstrapMethod</code>，该方法存放在新增的<code>BootstrapMethods</code>属性中）、方法类型(<code>MethodType</code>)和名称。引导方法是有固定的参数，并且返回值规定是<code>java.lang.invoke.CallSite</code>对象，这个对象代表了真正要执行的目标方法调用。根据<code>CONSTANT_InvokeDynamic_info</code>常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个<code>CallSite</code>对象，最终调用到要执行的目标方法上。</p>\n"},{"title":"内存模型与线程","date":"2022-03-29T14:31:50.000Z","top_img":"/img/cover/memory_model.png","cover":"/img/cover/memory_model.png","_content":"\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## Java内存模型\nJava内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。这里关注的主要是线程共有的实例字段、静态字段和构成数组对象的元素，它们会被存在主存中，以实现数据一致性。\n\n虚拟机拥有的内存分为线程共有的主内存和线程私有的工作内存，Java内存模型规定所有变量都存储在主内存中，线程的工作内存保存有该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据\n\nJava内存模型如下图所示：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/memory_model.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程、主内存、工作内存三者的交互关系\n    </div>\n</center>\n\n### 内存操作\nJava内存模型定义了8种操作来实现工作内存与主内存之间的交互，这8种操作都是原子的\n> double和long类型的变量，由于其需要占据多于1个变量槽，因此稍有区别\n\n8种操作具体如下：\n+ **lock（锁定）**：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。\n+ **unlock（解锁）**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定。\n+ **read（读取）**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以 便随后的load动作使用。\n+ **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。\n+ **use（使用）**：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\n+ **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n+ **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随 后的write操作使用。\n+ **write（写入）**：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。\n\n操作之间的先后执行顺序以及是否执行都有严格的约束，书上表述的十分详细，这里可以简单理解为：\n+ 先读后写：**lock** -> **read** -> **load** -> **use** -> **assign** -> **store** -> **write** -> **unlock**\n\n### volatile关键字\n两个特性：\n1. 保证被修饰的变量对所有线程的可见性（必须要从内存中访问最新值）\n2. 禁止指令重排序优化（让线程更安全，比锁更轻量，但并不能保证线程安全）\n\n### 先行发生原则\n+ 原子性：Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write\n+ 可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改\n+ 有序性：\n    + 如果在本线程内观察，所有的操作都是有序的；（线程内似表现为串行的语义）\n    + 如果在一个线程中观察另一个线程，所有的操作都是无序的；（“指令重排序”现象和“工作内存与主内存同步延迟”现象）\n\n为了保证多线程并发执行的安全性，Java有一个**先行发生原则**，它是判断数据是否存在竞争、线程是否安全的有效手段。有它的存在，一般的线程的安全得到保证\n\n两个操作之间的”先行发生“关系，指定了两个操作之间的偏序关系，简单说开发者可以默认其发生的先后顺序，而无须再精细判断，虚拟机也无法对他们进行肆意排序。\n\nJava内存模型中一些“天然的”先行发生关系如下：\n\n+ **程序次序规则**(Program Order Rule)：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作\n    > 注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构\n+ **管程锁定规则**(Monitor Lock Rule)：一个`unlock`操作先行发生于后面对同一个锁的lock操作\n    > 这里必须强调的是“同一个锁”，而“后面”是指时间上的先后\n+ **volatile变量规则**(Volatile Variable Rule)：对一个`volatile`变量的写操作先行发生于后面对这个变量的读操作\n    > 这里的“后面”同样是指时间上的先后\n+ **线程启动规则**(Thread Start Rule)：`Thread`对象的`start()`方法先行发生于此线程的每一个动作\n+ **线程终止规则**(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测\n    > 可以通过`Thread::join()`方法是否结束、`Thread::isAlive()`的返回值等手段检测线程是否已经终止执行\n+ **线程中断规则**(Thread Interruption Rule)：对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n    > 可以通过`Thread::interrupted()`方法检测到是否有中断发生\n+ **对象终结规则**(Finalizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的`finalize()`方法的开始\n+ **传递性**(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那操作A先行发生于操作C\n\n> 注意：时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准\n\n## Java线程\n实现线程主要有三种方式：\n+ 使用内核线程实现（1：1实现）\n+ 使用用户线程实现（1：N实现）\n+ 使用用户线程加轻量级进程混合实现（N：M实现）\n\n主流商用Java虚拟机的线程模型普遍都采用基于操作系统的原生线程模型来实现，即采用**1:1的线程模型**\n+ **缺陷**：切换、调度成本高昂，系统能容纳的线程数量也很有限，不太适用于当今并发量超高的应用\n\n线程调度方式：\n+ 协同式：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去\n    + 实现简单\n    + 切换线程对线程可知，且线程执行时间不稳定\n+ 抢占式：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定\n    + 线程执行时间是系统可控的，切换线程对线程不可知\n\n### 线程状态转换\n6种线程状态：\n+ **新建(New)**：创建后尚未启动的线程处于这种状态。 \n+ **运行(Runnable)**：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。 \n+ **无限期等待(Waiting)**：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：\n    + 没有设置`Timeout`参数的`Object::wait()`方法\n    + 没有设置`Timeout`参数的`Thread::join()`方法\n    + `LockSupport::park()`方法\n+ **限期等待(Timed Waiting)**：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：\n    + `Thread::sleep()`方法\n    + 设置了`Timeout`参数的`Object::wait()`方法\n    + 设置了`Timeout`参数的`Thread::join()`方法\n    + `LockSupport::parkNanos()`方法\n    + `LockSupport::parkUntil()`方法\n+ **阻塞(Blocked)**：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 \n+ **结束(Terminated)**：已终止线程的线程状态，线程已经结束执行。\n\n线程状态转换的关系如下图所示：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_state.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程状态转换关系\n    </div>\n</center>\n\n","source":"_posts/内存模型与线程.md","raw":"---\ntitle: 内存模型与线程\ndate: 2022-03-29 22:31:50\ntop_img: /img/cover/memory_model.png\ncover: /img/cover/memory_model.png\ntags: [Java, 笔记]\n---\n\n## 前言\n疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## Java内存模型\nJava内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。这里关注的主要是线程共有的实例字段、静态字段和构成数组对象的元素，它们会被存在主存中，以实现数据一致性。\n\n虚拟机拥有的内存分为线程共有的主内存和线程私有的工作内存，Java内存模型规定所有变量都存储在主内存中，线程的工作内存保存有该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据\n\nJava内存模型如下图所示：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/memory_model.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程、主内存、工作内存三者的交互关系\n    </div>\n</center>\n\n### 内存操作\nJava内存模型定义了8种操作来实现工作内存与主内存之间的交互，这8种操作都是原子的\n> double和long类型的变量，由于其需要占据多于1个变量槽，因此稍有区别\n\n8种操作具体如下：\n+ **lock（锁定）**：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。\n+ **unlock（解锁）**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定。\n+ **read（读取）**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以 便随后的load动作使用。\n+ **load（载入）**：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。\n+ **use（使用）**：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\n+ **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\n+ **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随 后的write操作使用。\n+ **write（写入）**：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。\n\n操作之间的先后执行顺序以及是否执行都有严格的约束，书上表述的十分详细，这里可以简单理解为：\n+ 先读后写：**lock** -> **read** -> **load** -> **use** -> **assign** -> **store** -> **write** -> **unlock**\n\n### volatile关键字\n两个特性：\n1. 保证被修饰的变量对所有线程的可见性（必须要从内存中访问最新值）\n2. 禁止指令重排序优化（让线程更安全，比锁更轻量，但并不能保证线程安全）\n\n### 先行发生原则\n+ 原子性：Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write\n+ 可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改\n+ 有序性：\n    + 如果在本线程内观察，所有的操作都是有序的；（线程内似表现为串行的语义）\n    + 如果在一个线程中观察另一个线程，所有的操作都是无序的；（“指令重排序”现象和“工作内存与主内存同步延迟”现象）\n\n为了保证多线程并发执行的安全性，Java有一个**先行发生原则**，它是判断数据是否存在竞争、线程是否安全的有效手段。有它的存在，一般的线程的安全得到保证\n\n两个操作之间的”先行发生“关系，指定了两个操作之间的偏序关系，简单说开发者可以默认其发生的先后顺序，而无须再精细判断，虚拟机也无法对他们进行肆意排序。\n\nJava内存模型中一些“天然的”先行发生关系如下：\n\n+ **程序次序规则**(Program Order Rule)：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作\n    > 注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构\n+ **管程锁定规则**(Monitor Lock Rule)：一个`unlock`操作先行发生于后面对同一个锁的lock操作\n    > 这里必须强调的是“同一个锁”，而“后面”是指时间上的先后\n+ **volatile变量规则**(Volatile Variable Rule)：对一个`volatile`变量的写操作先行发生于后面对这个变量的读操作\n    > 这里的“后面”同样是指时间上的先后\n+ **线程启动规则**(Thread Start Rule)：`Thread`对象的`start()`方法先行发生于此线程的每一个动作\n+ **线程终止规则**(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测\n    > 可以通过`Thread::join()`方法是否结束、`Thread::isAlive()`的返回值等手段检测线程是否已经终止执行\n+ **线程中断规则**(Thread Interruption Rule)：对线程`interrupt()`方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n    > 可以通过`Thread::interrupted()`方法检测到是否有中断发生\n+ **对象终结规则**(Finalizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的`finalize()`方法的开始\n+ **传递性**(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那操作A先行发生于操作C\n\n> 注意：时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准\n\n## Java线程\n实现线程主要有三种方式：\n+ 使用内核线程实现（1：1实现）\n+ 使用用户线程实现（1：N实现）\n+ 使用用户线程加轻量级进程混合实现（N：M实现）\n\n主流商用Java虚拟机的线程模型普遍都采用基于操作系统的原生线程模型来实现，即采用**1:1的线程模型**\n+ **缺陷**：切换、调度成本高昂，系统能容纳的线程数量也很有限，不太适用于当今并发量超高的应用\n\n线程调度方式：\n+ 协同式：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去\n    + 实现简单\n    + 切换线程对线程可知，且线程执行时间不稳定\n+ 抢占式：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定\n    + 线程执行时间是系统可控的，切换线程对线程不可知\n\n### 线程状态转换\n6种线程状态：\n+ **新建(New)**：创建后尚未启动的线程处于这种状态。 \n+ **运行(Runnable)**：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。 \n+ **无限期等待(Waiting)**：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：\n    + 没有设置`Timeout`参数的`Object::wait()`方法\n    + 没有设置`Timeout`参数的`Thread::join()`方法\n    + `LockSupport::park()`方法\n+ **限期等待(Timed Waiting)**：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：\n    + `Thread::sleep()`方法\n    + 设置了`Timeout`参数的`Object::wait()`方法\n    + 设置了`Timeout`参数的`Thread::join()`方法\n    + `LockSupport::parkNanos()`方法\n    + `LockSupport::parkUntil()`方法\n+ **阻塞(Blocked)**：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 \n+ **结束(Terminated)**：已终止线程的线程状态，线程已经结束执行。\n\n线程状态转换的关系如下图所示：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_state.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程状态转换关系\n    </div>\n</center>\n\n","slug":"内存模型与线程","published":1,"updated":"2022-09-21T07:30:46.940Z","_id":"cl1cbxlx3000034tp35kf9ylm","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。这里关注的主要是线程共有的实例字段、静态字段和构成数组对象的元素，它们会被存在主存中，以实现数据一致性。</p>\n<p>虚拟机拥有的内存分为线程共有的主内存和线程私有的工作内存，Java内存模型规定所有变量都存储在主内存中，线程的工作内存保存有该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据</p>\n<p>Java内存模型如下图所示：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/memory_model.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程、主内存、工作内存三者的交互关系\n    </div>\n</center>\n\n<h3 id=\"内存操作\"><a href=\"#内存操作\" class=\"headerlink\" title=\"内存操作\"></a>内存操作</h3><p>Java内存模型定义了8种操作来实现工作内存与主内存之间的交互，这8种操作都是原子的</p>\n<blockquote>\n<p>double和long类型的变量，由于其需要占据多于1个变量槽，因此稍有区别</p>\n</blockquote>\n<p>8种操作具体如下：</p>\n<ul>\n<li><strong>lock（锁定）</strong>：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>\n<li><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定。</li>\n<li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以 便随后的load动作使用。</li>\n<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。</li>\n<li><strong>use（使用）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>\n<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>\n<li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随 后的write操作使用。</li>\n<li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。</li>\n</ul>\n<p>操作之间的先后执行顺序以及是否执行都有严格的约束，书上表述的十分详细，这里可以简单理解为：</p>\n<ul>\n<li>先读后写：<strong>lock</strong> -&gt; <strong>read</strong> -&gt; <strong>load</strong> -&gt; <strong>use</strong> -&gt; <strong>assign</strong> -&gt; <strong>store</strong> -&gt; <strong>write</strong> -&gt; <strong>unlock</strong></li>\n</ul>\n<h3 id=\"volatile关键字\"><a href=\"#volatile关键字\" class=\"headerlink\" title=\"volatile关键字\"></a>volatile关键字</h3><p>两个特性：</p>\n<ol>\n<li>保证被修饰的变量对所有线程的可见性（必须要从内存中访问最新值）</li>\n<li>禁止指令重排序优化（让线程更安全，比锁更轻量，但并不能保证线程安全）</li>\n</ol>\n<h3 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h3><ul>\n<li>原子性：Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write</li>\n<li>可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</li>\n<li>有序性：<ul>\n<li>如果在本线程内观察，所有的操作都是有序的；（线程内似表现为串行的语义）</li>\n<li>如果在一个线程中观察另一个线程，所有的操作都是无序的；（“指令重排序”现象和“工作内存与主内存同步延迟”现象）</li>\n</ul>\n</li>\n</ul>\n<p>为了保证多线程并发执行的安全性，Java有一个<strong>先行发生原则</strong>，它是判断数据是否存在竞争、线程是否安全的有效手段。有它的存在，一般的线程的安全得到保证</p>\n<p>两个操作之间的”先行发生“关系，指定了两个操作之间的偏序关系，简单说开发者可以默认其发生的先后顺序，而无须再精细判断，虚拟机也无法对他们进行肆意排序。</p>\n<p>Java内存模型中一些“天然的”先行发生关系如下：</p>\n<ul>\n<li><strong>程序次序规则</strong>(Program Order Rule)：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作<blockquote>\n<p>注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构</p>\n</blockquote>\n</li>\n<li><strong>管程锁定规则</strong>(Monitor Lock Rule)：一个<code>unlock</code>操作先行发生于后面对同一个锁的lock操作<blockquote>\n<p>这里必须强调的是“同一个锁”，而“后面”是指时间上的先后</p>\n</blockquote>\n</li>\n<li><strong>volatile变量规则</strong>(Volatile Variable Rule)：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作<blockquote>\n<p>这里的“后面”同样是指时间上的先后</p>\n</blockquote>\n</li>\n<li><strong>线程启动规则</strong>(Thread Start Rule)：<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作</li>\n<li><strong>线程终止规则</strong>(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测<blockquote>\n<p>可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行</p>\n</blockquote>\n</li>\n<li><strong>线程中断规则</strong>(Thread Interruption Rule)：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生<blockquote>\n<p>可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生</p>\n</blockquote>\n</li>\n<li><strong>对象终结规则</strong>(Finalizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始</li>\n<li><strong>传递性</strong>(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那操作A先行发生于操作C</li>\n</ul>\n<blockquote>\n<p>注意：时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准</p>\n</blockquote>\n<h2 id=\"Java线程\"><a href=\"#Java线程\" class=\"headerlink\" title=\"Java线程\"></a>Java线程</h2><p>实现线程主要有三种方式：</p>\n<ul>\n<li>使用内核线程实现（1：1实现）</li>\n<li>使用用户线程实现（1：N实现）</li>\n<li>使用用户线程加轻量级进程混合实现（N：M实现）</li>\n</ul>\n<p>主流商用Java虚拟机的线程模型普遍都采用基于操作系统的原生线程模型来实现，即采用<strong>1:1的线程模型</strong></p>\n<ul>\n<li><strong>缺陷</strong>：切换、调度成本高昂，系统能容纳的线程数量也很有限，不太适用于当今并发量超高的应用</li>\n</ul>\n<p>线程调度方式：</p>\n<ul>\n<li>协同式：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去<ul>\n<li>实现简单</li>\n<li>切换线程对线程可知，且线程执行时间不稳定</li>\n</ul>\n</li>\n<li>抢占式：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定<ul>\n<li>线程执行时间是系统可控的，切换线程对线程不可知</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程状态转换\"><a href=\"#线程状态转换\" class=\"headerlink\" title=\"线程状态转换\"></a>线程状态转换</h3><p>6种线程状态：</p>\n<ul>\n<li><strong>新建(New)</strong>：创建后尚未启动的线程处于这种状态。 </li>\n<li><strong>运行(Runnable)</strong>：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。 </li>\n<li><strong>无限期等待(Waiting)</strong>：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：<ul>\n<li>没有设置<code>Timeout</code>参数的<code>Object::wait()</code>方法</li>\n<li>没有设置<code>Timeout</code>参数的<code>Thread::join()</code>方法</li>\n<li><code>LockSupport::park()</code>方法</li>\n</ul>\n</li>\n<li><strong>限期等待(Timed Waiting)</strong>：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>\n<li><code>Thread::sleep()</code>方法</li>\n<li>设置了<code>Timeout</code>参数的<code>Object::wait()</code>方法</li>\n<li>设置了<code>Timeout</code>参数的<code>Thread::join()</code>方法</li>\n<li><code>LockSupport::parkNanos()</code>方法</li>\n<li><code>LockSupport::parkUntil()</code>方法</li>\n</ul>\n</li>\n<li><strong>阻塞(Blocked)</strong>：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 </li>\n<li><strong>结束(Terminated)</strong>：已终止线程的线程状态，线程已经结束执行。</li>\n</ul>\n<p>线程状态转换的关系如下图所示：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_state.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程状态转换关系\n    </div>\n</center>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《深入理解Java虚拟机》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"Java内存模型\"><a href=\"#Java内存模型\" class=\"headerlink\" title=\"Java内存模型\"></a>Java内存模型</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。这里关注的主要是线程共有的实例字段、静态字段和构成数组对象的元素，它们会被存在主存中，以实现数据一致性。</p>\n<p>虚拟机拥有的内存分为线程共有的主内存和线程私有的工作内存，Java内存模型规定所有变量都存储在主内存中，线程的工作内存保存有该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据</p>\n<p>Java内存模型如下图所示：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/memory_model.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程、主内存、工作内存三者的交互关系\n    </div>\n</center>\n\n<h3 id=\"内存操作\"><a href=\"#内存操作\" class=\"headerlink\" title=\"内存操作\"></a>内存操作</h3><p>Java内存模型定义了8种操作来实现工作内存与主内存之间的交互，这8种操作都是原子的</p>\n<blockquote>\n<p>double和long类型的变量，由于其需要占据多于1个变量槽，因此稍有区别</p>\n</blockquote>\n<p>8种操作具体如下：</p>\n<ul>\n<li><strong>lock（锁定）</strong>：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>\n<li><strong>unlock（解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量 才可以被其他线程锁定。</li>\n<li><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以 便随后的load动作使用。</li>\n<li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。</li>\n<li><strong>use（使用）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚 拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>\n<li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量， 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>\n<li><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随 后的write操作使用。</li>\n<li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的 变量中。</li>\n</ul>\n<p>操作之间的先后执行顺序以及是否执行都有严格的约束，书上表述的十分详细，这里可以简单理解为：</p>\n<ul>\n<li>先读后写：<strong>lock</strong> -&gt; <strong>read</strong> -&gt; <strong>load</strong> -&gt; <strong>use</strong> -&gt; <strong>assign</strong> -&gt; <strong>store</strong> -&gt; <strong>write</strong> -&gt; <strong>unlock</strong></li>\n</ul>\n<h3 id=\"volatile关键字\"><a href=\"#volatile关键字\" class=\"headerlink\" title=\"volatile关键字\"></a>volatile关键字</h3><p>两个特性：</p>\n<ol>\n<li>保证被修饰的变量对所有线程的可见性（必须要从内存中访问最新值）</li>\n<li>禁止指令重排序优化（让线程更安全，比锁更轻量，但并不能保证线程安全）</li>\n</ol>\n<h3 id=\"先行发生原则\"><a href=\"#先行发生原则\" class=\"headerlink\" title=\"先行发生原则\"></a>先行发生原则</h3><ul>\n<li>原子性：Java内存模型直接保证的原子性变量操作包括read、load、assign、use、store和write</li>\n<li>可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</li>\n<li>有序性：<ul>\n<li>如果在本线程内观察，所有的操作都是有序的；（线程内似表现为串行的语义）</li>\n<li>如果在一个线程中观察另一个线程，所有的操作都是无序的；（“指令重排序”现象和“工作内存与主内存同步延迟”现象）</li>\n</ul>\n</li>\n</ul>\n<p>为了保证多线程并发执行的安全性，Java有一个<strong>先行发生原则</strong>，它是判断数据是否存在竞争、线程是否安全的有效手段。有它的存在，一般的线程的安全得到保证</p>\n<p>两个操作之间的”先行发生“关系，指定了两个操作之间的偏序关系，简单说开发者可以默认其发生的先后顺序，而无须再精细判断，虚拟机也无法对他们进行肆意排序。</p>\n<p>Java内存模型中一些“天然的”先行发生关系如下：</p>\n<ul>\n<li><strong>程序次序规则</strong>(Program Order Rule)：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作<blockquote>\n<p>注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构</p>\n</blockquote>\n</li>\n<li><strong>管程锁定规则</strong>(Monitor Lock Rule)：一个<code>unlock</code>操作先行发生于后面对同一个锁的lock操作<blockquote>\n<p>这里必须强调的是“同一个锁”，而“后面”是指时间上的先后</p>\n</blockquote>\n</li>\n<li><strong>volatile变量规则</strong>(Volatile Variable Rule)：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作<blockquote>\n<p>这里的“后面”同样是指时间上的先后</p>\n</blockquote>\n</li>\n<li><strong>线程启动规则</strong>(Thread Start Rule)：<code>Thread</code>对象的<code>start()</code>方法先行发生于此线程的每一个动作</li>\n<li><strong>线程终止规则</strong>(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测<blockquote>\n<p>可以通过<code>Thread::join()</code>方法是否结束、<code>Thread::isAlive()</code>的返回值等手段检测线程是否已经终止执行</p>\n</blockquote>\n</li>\n<li><strong>线程中断规则</strong>(Thread Interruption Rule)：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生<blockquote>\n<p>可以通过<code>Thread::interrupted()</code>方法检测到是否有中断发生</p>\n</blockquote>\n</li>\n<li><strong>对象终结规则</strong>(Finalizer Rule)：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始</li>\n<li><strong>传递性</strong>(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那操作A先行发生于操作C</li>\n</ul>\n<blockquote>\n<p>注意：时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准</p>\n</blockquote>\n<h2 id=\"Java线程\"><a href=\"#Java线程\" class=\"headerlink\" title=\"Java线程\"></a>Java线程</h2><p>实现线程主要有三种方式：</p>\n<ul>\n<li>使用内核线程实现（1：1实现）</li>\n<li>使用用户线程实现（1：N实现）</li>\n<li>使用用户线程加轻量级进程混合实现（N：M实现）</li>\n</ul>\n<p>主流商用Java虚拟机的线程模型普遍都采用基于操作系统的原生线程模型来实现，即采用<strong>1:1的线程模型</strong></p>\n<ul>\n<li><strong>缺陷</strong>：切换、调度成本高昂，系统能容纳的线程数量也很有限，不太适用于当今并发量超高的应用</li>\n</ul>\n<p>线程调度方式：</p>\n<ul>\n<li>协同式：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去<ul>\n<li>实现简单</li>\n<li>切换线程对线程可知，且线程执行时间不稳定</li>\n</ul>\n</li>\n<li>抢占式：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定<ul>\n<li>线程执行时间是系统可控的，切换线程对线程不可知</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程状态转换\"><a href=\"#线程状态转换\" class=\"headerlink\" title=\"线程状态转换\"></a>线程状态转换</h3><p>6种线程状态：</p>\n<ul>\n<li><strong>新建(New)</strong>：创建后尚未启动的线程处于这种状态。 </li>\n<li><strong>运行(Runnable)</strong>：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。 </li>\n<li><strong>无限期等待(Waiting)</strong>：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：<ul>\n<li>没有设置<code>Timeout</code>参数的<code>Object::wait()</code>方法</li>\n<li>没有设置<code>Timeout</code>参数的<code>Thread::join()</code>方法</li>\n<li><code>LockSupport::park()</code>方法</li>\n</ul>\n</li>\n<li><strong>限期等待(Timed Waiting)</strong>：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>\n<li><code>Thread::sleep()</code>方法</li>\n<li>设置了<code>Timeout</code>参数的<code>Object::wait()</code>方法</li>\n<li>设置了<code>Timeout</code>参数的<code>Thread::join()</code>方法</li>\n<li><code>LockSupport::parkNanos()</code>方法</li>\n<li><code>LockSupport::parkUntil()</code>方法</li>\n</ul>\n</li>\n<li><strong>阻塞(Blocked)</strong>：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。 </li>\n<li><strong>结束(Terminated)</strong>：已终止线程的线程状态，线程已经结束执行。</li>\n</ul>\n<p>线程状态转换的关系如下图所示：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_state.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程状态转换关系\n    </div>\n</center>\n\n"},{"title":"并发编程","date":"2022-03-30T04:36:02.000Z","top_img":"/img/cover/thread_lifecycle.jpg","cover":"/img/cover/thread_lifecycle.jpg","_content":"\n## 前言\n疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n# 并发编程\nJava并发编程的核心目的是识别出任务中必须串行和可以并行的部分，将可以并行的部分尽量交给多线程并行处理，高效利用多处理器，以提高程序整体的性能。同时，由于多线程并行会引起线程安全性、活跃性和性能等多方面的问题，如何规避这些问题同样十分重要。\n\n多线程带来的风险：\n+ **安全性问题**：多线程的操作执行顺序不可预测，甚至会产生奇怪的结果，在没有充足同步的情况下，线程安全无法保证。解决线程安全性问题，则需要保证“**永远不会发生糟糕的事情**”\n+ **活跃性问题**：“**某件正确的事情最终会发生**”，这也是由于多线程竞争和轮序执行会导致的问题。例如，线程A错误的无限循环可能导致线程B无法被执行。\n    + 常见问题：死锁、饥饿、活锁\n+ **性能问题**：希望“**正确的事情尽快发生**”，解决活跃性问题并不能保证程序的性能\n    + 常见问题：服务时间过长、响应不灵敏等\n\n## 线程安全性\n**线程安全性**：当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的\n\n为了维护线程安全性，主要有2种思路：\n1. 避免对象发布，将对象实现为线程内部的变量，让其他线程无法访问，例如`private`修饰的变量，`ThreadLocal`修饰的变量\n    + 适用于本身就无需于其他线程共享的变量，此时仅需要做好变量的管理，避免逸出\n2. 通过加锁、原子性变量、同步容器实现对象的安全发布\n    + 适用于必然共享的变量，在发布之前确保其安全性\n\n## 线程活跃性\n导致线程活跃性问题的一般情况有死锁、饥饿、糟糕的响应性、活锁等\n\n+ **饥饿**：当线程无法访问它所需要的资源而不能继续执行时，就导致饥饿，最常见的资源就是**时钟周期**\n    + 线程调度与线程优先级有关，操作系统会尽力去平衡\n+ **糟糕的响应性**：线程的长时间执行导致其他线程无法执行，导致其响应时间过长\n+ **活锁**：线程不会被阻塞，但也没法继续执行，因为会一直重复执行相同的操作（比如重复尝试拿锁）\n    + 解决：在重试机制中引入随机性，以避免重复多次的竞争失败（只要每次有人成功，就能执行下去）\n\n### 死锁：\n+ 锁顺序死锁：线程拿锁的顺序不同，导致握有对方需要的锁同时需要对方握有的资源，引起死锁\n    + 解决：对加锁行为进行全局分析，制定拿锁的顺序\n+ 动态的锁顺序死锁：以`transferMOney(Account fromAccount, Account toAccount)`为例，看似拿锁顺序固定，但由于业务多变，传参时仍可能出现顺序死锁的可能性\n    + 解决：对每个`Account`进行哈希，得到固定的大小顺序；若哈希值相同，则可以使用`Tie-Breaking`锁\n+ 在协作对象之间发生的死锁：协作对象的方法都有加锁，在某个方法调用其他对象的加锁方法，就会出现顺序死锁的问题，但其十分隐晦\n    + 如果在持有锁的情况下调用某个外部方法，就需要小心死锁\n    + 解决：开放调用，缩小锁的粒度，不在方法级实现加锁，而在关键变量访问的地方加锁即可\n+ 资源死锁：举例：线程A持有与数据库D1的连接，并等待与数据库D2的连接；线程B持有与数据库D2的连接，并等待与数据库D1的连接\n\n死锁的判断：\n1. 两阶段策略：找出需要获取的锁，对这些实例进行分析，确保拿锁顺序的一致性\n2. 支持定时的锁：用显式锁`Lock`代替内置锁，`Lock`有`tryLock`功能，还可以设置超时时间`Timeout`\n3. 通过线程转储信息来分析死锁\n\n## 线程性能\n根据Amdahl定律，在包含`N`个处理器的机器中，最高加速比为：$Speedup \\leq \\frac{1}{F+\\frac{(1-F)}{N}}$，当`N`趋于无穷大时，最大加速比仅为 $\\frac{1}{F}$\n\n公式说明，引入并行确实可以加速程序运行，但即便处理器数量真的无限，并行的部分也是有限的，且引入并行的过程中（如创建线程的过程）也会增加新的串行部分\n\n+ 线程引入的开销\n    + **上下文切换**：线程调度过程中需要访问由操作系统和JVM共享的数据结构，且它们和用户线程使用同一组CPU，新线程创建时可能会有缓存缺失等等。这些都是上下文切换带来的开销\n    + **内存同步**：根据Java内存模型可知，为了保持多个线程共享的变量的一致性，对变量的读写都需要更新到主内存中，这在一定程度上降低了线程性能\n    + **阻塞**：当线程由于竞争锁失败或I/O操作等原因阻塞时，可以通过自旋等待或直接挂起的方式处理，具体选择取决于上下文切换的开销等。\n\n**串行操作会降低可伸缩性**（即程序在多处理器下的性能增加程度），并且**上下文切换会降低程序性能**，而在锁上发生竞争时会同时导致这两种问题。如何减少锁的竞争：\n+ 缩小锁的范围：将锁无关的代码移出同步代码块，实现“快进快出”\n+ 减小锁的粒度：降低锁的请求频率，减小竞争发生的可能性\n+ 锁分段\n+ 避免热点域\n+ 替代独占锁：并发容器、读写锁、不可变对象、原子变量\n\n## 参考\n原本打算把每个关键字和工具都记录一下的，正好看到了别人的记录，觉得挺好的，分享一下\n[Java并发编程相关](https://github.com/CL0610/Java-concurrency)","source":"_posts/并发编程.md","raw":"---\ntitle: 并发编程\ndate: 2022-03-30 12:36:02\ntop_img: /img/cover/thread_lifecycle.jpg\ncover: /img/cover/thread_lifecycle.jpg\ntags: [Java, 笔记]\n---\n\n## 前言\n疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n# 并发编程\nJava并发编程的核心目的是识别出任务中必须串行和可以并行的部分，将可以并行的部分尽量交给多线程并行处理，高效利用多处理器，以提高程序整体的性能。同时，由于多线程并行会引起线程安全性、活跃性和性能等多方面的问题，如何规避这些问题同样十分重要。\n\n多线程带来的风险：\n+ **安全性问题**：多线程的操作执行顺序不可预测，甚至会产生奇怪的结果，在没有充足同步的情况下，线程安全无法保证。解决线程安全性问题，则需要保证“**永远不会发生糟糕的事情**”\n+ **活跃性问题**：“**某件正确的事情最终会发生**”，这也是由于多线程竞争和轮序执行会导致的问题。例如，线程A错误的无限循环可能导致线程B无法被执行。\n    + 常见问题：死锁、饥饿、活锁\n+ **性能问题**：希望“**正确的事情尽快发生**”，解决活跃性问题并不能保证程序的性能\n    + 常见问题：服务时间过长、响应不灵敏等\n\n## 线程安全性\n**线程安全性**：当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的\n\n为了维护线程安全性，主要有2种思路：\n1. 避免对象发布，将对象实现为线程内部的变量，让其他线程无法访问，例如`private`修饰的变量，`ThreadLocal`修饰的变量\n    + 适用于本身就无需于其他线程共享的变量，此时仅需要做好变量的管理，避免逸出\n2. 通过加锁、原子性变量、同步容器实现对象的安全发布\n    + 适用于必然共享的变量，在发布之前确保其安全性\n\n## 线程活跃性\n导致线程活跃性问题的一般情况有死锁、饥饿、糟糕的响应性、活锁等\n\n+ **饥饿**：当线程无法访问它所需要的资源而不能继续执行时，就导致饥饿，最常见的资源就是**时钟周期**\n    + 线程调度与线程优先级有关，操作系统会尽力去平衡\n+ **糟糕的响应性**：线程的长时间执行导致其他线程无法执行，导致其响应时间过长\n+ **活锁**：线程不会被阻塞，但也没法继续执行，因为会一直重复执行相同的操作（比如重复尝试拿锁）\n    + 解决：在重试机制中引入随机性，以避免重复多次的竞争失败（只要每次有人成功，就能执行下去）\n\n### 死锁：\n+ 锁顺序死锁：线程拿锁的顺序不同，导致握有对方需要的锁同时需要对方握有的资源，引起死锁\n    + 解决：对加锁行为进行全局分析，制定拿锁的顺序\n+ 动态的锁顺序死锁：以`transferMOney(Account fromAccount, Account toAccount)`为例，看似拿锁顺序固定，但由于业务多变，传参时仍可能出现顺序死锁的可能性\n    + 解决：对每个`Account`进行哈希，得到固定的大小顺序；若哈希值相同，则可以使用`Tie-Breaking`锁\n+ 在协作对象之间发生的死锁：协作对象的方法都有加锁，在某个方法调用其他对象的加锁方法，就会出现顺序死锁的问题，但其十分隐晦\n    + 如果在持有锁的情况下调用某个外部方法，就需要小心死锁\n    + 解决：开放调用，缩小锁的粒度，不在方法级实现加锁，而在关键变量访问的地方加锁即可\n+ 资源死锁：举例：线程A持有与数据库D1的连接，并等待与数据库D2的连接；线程B持有与数据库D2的连接，并等待与数据库D1的连接\n\n死锁的判断：\n1. 两阶段策略：找出需要获取的锁，对这些实例进行分析，确保拿锁顺序的一致性\n2. 支持定时的锁：用显式锁`Lock`代替内置锁，`Lock`有`tryLock`功能，还可以设置超时时间`Timeout`\n3. 通过线程转储信息来分析死锁\n\n## 线程性能\n根据Amdahl定律，在包含`N`个处理器的机器中，最高加速比为：$Speedup \\leq \\frac{1}{F+\\frac{(1-F)}{N}}$，当`N`趋于无穷大时，最大加速比仅为 $\\frac{1}{F}$\n\n公式说明，引入并行确实可以加速程序运行，但即便处理器数量真的无限，并行的部分也是有限的，且引入并行的过程中（如创建线程的过程）也会增加新的串行部分\n\n+ 线程引入的开销\n    + **上下文切换**：线程调度过程中需要访问由操作系统和JVM共享的数据结构，且它们和用户线程使用同一组CPU，新线程创建时可能会有缓存缺失等等。这些都是上下文切换带来的开销\n    + **内存同步**：根据Java内存模型可知，为了保持多个线程共享的变量的一致性，对变量的读写都需要更新到主内存中，这在一定程度上降低了线程性能\n    + **阻塞**：当线程由于竞争锁失败或I/O操作等原因阻塞时，可以通过自旋等待或直接挂起的方式处理，具体选择取决于上下文切换的开销等。\n\n**串行操作会降低可伸缩性**（即程序在多处理器下的性能增加程度），并且**上下文切换会降低程序性能**，而在锁上发生竞争时会同时导致这两种问题。如何减少锁的竞争：\n+ 缩小锁的范围：将锁无关的代码移出同步代码块，实现“快进快出”\n+ 减小锁的粒度：降低锁的请求频率，减小竞争发生的可能性\n+ 锁分段\n+ 避免热点域\n+ 替代独占锁：并发容器、读写锁、不可变对象、原子变量\n\n## 参考\n原本打算把每个关键字和工具都记录一下的，正好看到了别人的记录，觉得挺好的，分享一下\n[Java并发编程相关](https://github.com/CL0610/Java-concurrency)","slug":"并发编程","published":1,"updated":"2022-09-21T07:30:46.940Z","_id":"cl1d78r540000l4tpdu6nh90a","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h1 id=\"并发编程\"><a href=\"#并发编程\" class=\"headerlink\" title=\"并发编程\"></a>并发编程</h1><p>Java并发编程的核心目的是识别出任务中必须串行和可以并行的部分，将可以并行的部分尽量交给多线程并行处理，高效利用多处理器，以提高程序整体的性能。同时，由于多线程并行会引起线程安全性、活跃性和性能等多方面的问题，如何规避这些问题同样十分重要。</p>\n<p>多线程带来的风险：</p>\n<ul>\n<li><strong>安全性问题</strong>：多线程的操作执行顺序不可预测，甚至会产生奇怪的结果，在没有充足同步的情况下，线程安全无法保证。解决线程安全性问题，则需要保证“<strong>永远不会发生糟糕的事情</strong>”</li>\n<li><strong>活跃性问题</strong>：“<strong>某件正确的事情最终会发生</strong>”，这也是由于多线程竞争和轮序执行会导致的问题。例如，线程A错误的无限循环可能导致线程B无法被执行。<ul>\n<li>常见问题：死锁、饥饿、活锁</li>\n</ul>\n</li>\n<li><strong>性能问题</strong>：希望“<strong>正确的事情尽快发生</strong>”，解决活跃性问题并不能保证程序的性能<ul>\n<li>常见问题：服务时间过长、响应不灵敏等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程安全性\"><a href=\"#线程安全性\" class=\"headerlink\" title=\"线程安全性\"></a>线程安全性</h2><p><strong>线程安全性</strong>：当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的</p>\n<p>为了维护线程安全性，主要有2种思路：</p>\n<ol>\n<li>避免对象发布，将对象实现为线程内部的变量，让其他线程无法访问，例如<code>private</code>修饰的变量，<code>ThreadLocal</code>修饰的变量<ul>\n<li>适用于本身就无需于其他线程共享的变量，此时仅需要做好变量的管理，避免逸出</li>\n</ul>\n</li>\n<li>通过加锁、原子性变量、同步容器实现对象的安全发布<ul>\n<li>适用于必然共享的变量，在发布之前确保其安全性</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"线程活跃性\"><a href=\"#线程活跃性\" class=\"headerlink\" title=\"线程活跃性\"></a>线程活跃性</h2><p>导致线程活跃性问题的一般情况有死锁、饥饿、糟糕的响应性、活锁等</p>\n<ul>\n<li><strong>饥饿</strong>：当线程无法访问它所需要的资源而不能继续执行时，就导致饥饿，最常见的资源就是<strong>时钟周期</strong><ul>\n<li>线程调度与线程优先级有关，操作系统会尽力去平衡</li>\n</ul>\n</li>\n<li><strong>糟糕的响应性</strong>：线程的长时间执行导致其他线程无法执行，导致其响应时间过长</li>\n<li><strong>活锁</strong>：线程不会被阻塞，但也没法继续执行，因为会一直重复执行相同的操作（比如重复尝试拿锁）<ul>\n<li>解决：在重试机制中引入随机性，以避免重复多次的竞争失败（只要每次有人成功，就能执行下去）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"死锁：\"><a href=\"#死锁：\" class=\"headerlink\" title=\"死锁：\"></a>死锁：</h3><ul>\n<li>锁顺序死锁：线程拿锁的顺序不同，导致握有对方需要的锁同时需要对方握有的资源，引起死锁<ul>\n<li>解决：对加锁行为进行全局分析，制定拿锁的顺序</li>\n</ul>\n</li>\n<li>动态的锁顺序死锁：以<code>transferMOney(Account fromAccount, Account toAccount)</code>为例，看似拿锁顺序固定，但由于业务多变，传参时仍可能出现顺序死锁的可能性<ul>\n<li>解决：对每个<code>Account</code>进行哈希，得到固定的大小顺序；若哈希值相同，则可以使用<code>Tie-Breaking</code>锁</li>\n</ul>\n</li>\n<li>在协作对象之间发生的死锁：协作对象的方法都有加锁，在某个方法调用其他对象的加锁方法，就会出现顺序死锁的问题，但其十分隐晦<ul>\n<li>如果在持有锁的情况下调用某个外部方法，就需要小心死锁</li>\n<li>解决：开放调用，缩小锁的粒度，不在方法级实现加锁，而在关键变量访问的地方加锁即可</li>\n</ul>\n</li>\n<li>资源死锁：举例：线程A持有与数据库D1的连接，并等待与数据库D2的连接；线程B持有与数据库D2的连接，并等待与数据库D1的连接</li>\n</ul>\n<p>死锁的判断：</p>\n<ol>\n<li>两阶段策略：找出需要获取的锁，对这些实例进行分析，确保拿锁顺序的一致性</li>\n<li>支持定时的锁：用显式锁<code>Lock</code>代替内置锁，<code>Lock</code>有<code>tryLock</code>功能，还可以设置超时时间<code>Timeout</code></li>\n<li>通过线程转储信息来分析死锁</li>\n</ol>\n<h2 id=\"线程性能\"><a href=\"#线程性能\" class=\"headerlink\" title=\"线程性能\"></a>线程性能</h2><p>根据Amdahl定律，在包含<code>N</code>个处理器的机器中，最高加速比为：$Speedup \\leq \\frac{1}{F+\\frac{(1-F)}{N}}$，当<code>N</code>趋于无穷大时，最大加速比仅为 $\\frac{1}{F}$</p>\n<p>公式说明，引入并行确实可以加速程序运行，但即便处理器数量真的无限，并行的部分也是有限的，且引入并行的过程中（如创建线程的过程）也会增加新的串行部分</p>\n<ul>\n<li>线程引入的开销<ul>\n<li><strong>上下文切换</strong>：线程调度过程中需要访问由操作系统和JVM共享的数据结构，且它们和用户线程使用同一组CPU，新线程创建时可能会有缓存缺失等等。这些都是上下文切换带来的开销</li>\n<li><strong>内存同步</strong>：根据Java内存模型可知，为了保持多个线程共享的变量的一致性，对变量的读写都需要更新到主内存中，这在一定程度上降低了线程性能</li>\n<li><strong>阻塞</strong>：当线程由于竞争锁失败或I/O操作等原因阻塞时，可以通过自旋等待或直接挂起的方式处理，具体选择取决于上下文切换的开销等。</li>\n</ul>\n</li>\n</ul>\n<p><strong>串行操作会降低可伸缩性</strong>（即程序在多处理器下的性能增加程度），并且<strong>上下文切换会降低程序性能</strong>，而在锁上发生竞争时会同时导致这两种问题。如何减少锁的竞争：</p>\n<ul>\n<li>缩小锁的范围：将锁无关的代码移出同步代码块，实现“快进快出”</li>\n<li>减小锁的粒度：降低锁的请求频率，减小竞争发生的可能性</li>\n<li>锁分段</li>\n<li>避免热点域</li>\n<li>替代独占锁：并发容器、读写锁、不可变对象、原子变量</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>原本打算把每个关键字和工具都记录一下的，正好看到了别人的记录，觉得挺好的，分享一下<br><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Java并发编程相关</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h1 id=\"并发编程\"><a href=\"#并发编程\" class=\"headerlink\" title=\"并发编程\"></a>并发编程</h1><p>Java并发编程的核心目的是识别出任务中必须串行和可以并行的部分，将可以并行的部分尽量交给多线程并行处理，高效利用多处理器，以提高程序整体的性能。同时，由于多线程并行会引起线程安全性、活跃性和性能等多方面的问题，如何规避这些问题同样十分重要。</p>\n<p>多线程带来的风险：</p>\n<ul>\n<li><strong>安全性问题</strong>：多线程的操作执行顺序不可预测，甚至会产生奇怪的结果，在没有充足同步的情况下，线程安全无法保证。解决线程安全性问题，则需要保证“<strong>永远不会发生糟糕的事情</strong>”</li>\n<li><strong>活跃性问题</strong>：“<strong>某件正确的事情最终会发生</strong>”，这也是由于多线程竞争和轮序执行会导致的问题。例如，线程A错误的无限循环可能导致线程B无法被执行。<ul>\n<li>常见问题：死锁、饥饿、活锁</li>\n</ul>\n</li>\n<li><strong>性能问题</strong>：希望“<strong>正确的事情尽快发生</strong>”，解决活跃性问题并不能保证程序的性能<ul>\n<li>常见问题：服务时间过长、响应不灵敏等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程安全性\"><a href=\"#线程安全性\" class=\"headerlink\" title=\"线程安全性\"></a>线程安全性</h2><p><strong>线程安全性</strong>：当多个线程访问某个类时，不管运行环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的</p>\n<p>为了维护线程安全性，主要有2种思路：</p>\n<ol>\n<li>避免对象发布，将对象实现为线程内部的变量，让其他线程无法访问，例如<code>private</code>修饰的变量，<code>ThreadLocal</code>修饰的变量<ul>\n<li>适用于本身就无需于其他线程共享的变量，此时仅需要做好变量的管理，避免逸出</li>\n</ul>\n</li>\n<li>通过加锁、原子性变量、同步容器实现对象的安全发布<ul>\n<li>适用于必然共享的变量，在发布之前确保其安全性</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"线程活跃性\"><a href=\"#线程活跃性\" class=\"headerlink\" title=\"线程活跃性\"></a>线程活跃性</h2><p>导致线程活跃性问题的一般情况有死锁、饥饿、糟糕的响应性、活锁等</p>\n<ul>\n<li><strong>饥饿</strong>：当线程无法访问它所需要的资源而不能继续执行时，就导致饥饿，最常见的资源就是<strong>时钟周期</strong><ul>\n<li>线程调度与线程优先级有关，操作系统会尽力去平衡</li>\n</ul>\n</li>\n<li><strong>糟糕的响应性</strong>：线程的长时间执行导致其他线程无法执行，导致其响应时间过长</li>\n<li><strong>活锁</strong>：线程不会被阻塞，但也没法继续执行，因为会一直重复执行相同的操作（比如重复尝试拿锁）<ul>\n<li>解决：在重试机制中引入随机性，以避免重复多次的竞争失败（只要每次有人成功，就能执行下去）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"死锁：\"><a href=\"#死锁：\" class=\"headerlink\" title=\"死锁：\"></a>死锁：</h3><ul>\n<li>锁顺序死锁：线程拿锁的顺序不同，导致握有对方需要的锁同时需要对方握有的资源，引起死锁<ul>\n<li>解决：对加锁行为进行全局分析，制定拿锁的顺序</li>\n</ul>\n</li>\n<li>动态的锁顺序死锁：以<code>transferMOney(Account fromAccount, Account toAccount)</code>为例，看似拿锁顺序固定，但由于业务多变，传参时仍可能出现顺序死锁的可能性<ul>\n<li>解决：对每个<code>Account</code>进行哈希，得到固定的大小顺序；若哈希值相同，则可以使用<code>Tie-Breaking</code>锁</li>\n</ul>\n</li>\n<li>在协作对象之间发生的死锁：协作对象的方法都有加锁，在某个方法调用其他对象的加锁方法，就会出现顺序死锁的问题，但其十分隐晦<ul>\n<li>如果在持有锁的情况下调用某个外部方法，就需要小心死锁</li>\n<li>解决：开放调用，缩小锁的粒度，不在方法级实现加锁，而在关键变量访问的地方加锁即可</li>\n</ul>\n</li>\n<li>资源死锁：举例：线程A持有与数据库D1的连接，并等待与数据库D2的连接；线程B持有与数据库D2的连接，并等待与数据库D1的连接</li>\n</ul>\n<p>死锁的判断：</p>\n<ol>\n<li>两阶段策略：找出需要获取的锁，对这些实例进行分析，确保拿锁顺序的一致性</li>\n<li>支持定时的锁：用显式锁<code>Lock</code>代替内置锁，<code>Lock</code>有<code>tryLock</code>功能，还可以设置超时时间<code>Timeout</code></li>\n<li>通过线程转储信息来分析死锁</li>\n</ol>\n<h2 id=\"线程性能\"><a href=\"#线程性能\" class=\"headerlink\" title=\"线程性能\"></a>线程性能</h2><p>根据Amdahl定律，在包含<code>N</code>个处理器的机器中，最高加速比为：$Speedup \\leq \\frac{1}{F+\\frac{(1-F)}{N}}$，当<code>N</code>趋于无穷大时，最大加速比仅为 $\\frac{1}{F}$</p>\n<p>公式说明，引入并行确实可以加速程序运行，但即便处理器数量真的无限，并行的部分也是有限的，且引入并行的过程中（如创建线程的过程）也会增加新的串行部分</p>\n<ul>\n<li>线程引入的开销<ul>\n<li><strong>上下文切换</strong>：线程调度过程中需要访问由操作系统和JVM共享的数据结构，且它们和用户线程使用同一组CPU，新线程创建时可能会有缓存缺失等等。这些都是上下文切换带来的开销</li>\n<li><strong>内存同步</strong>：根据Java内存模型可知，为了保持多个线程共享的变量的一致性，对变量的读写都需要更新到主内存中，这在一定程度上降低了线程性能</li>\n<li><strong>阻塞</strong>：当线程由于竞争锁失败或I/O操作等原因阻塞时，可以通过自旋等待或直接挂起的方式处理，具体选择取决于上下文切换的开销等。</li>\n</ul>\n</li>\n</ul>\n<p><strong>串行操作会降低可伸缩性</strong>（即程序在多处理器下的性能增加程度），并且<strong>上下文切换会降低程序性能</strong>，而在锁上发生竞争时会同时导致这两种问题。如何减少锁的竞争：</p>\n<ul>\n<li>缩小锁的范围：将锁无关的代码移出同步代码块，实现“快进快出”</li>\n<li>减小锁的粒度：降低锁的请求频率，减小竞争发生的可能性</li>\n<li>锁分段</li>\n<li>避免热点域</li>\n<li>替代独占锁：并发容器、读写锁、不可变对象、原子变量</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>原本打算把每个关键字和工具都记录一下的，正好看到了别人的记录，觉得挺好的，分享一下<br><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Java并发编程相关</a></p>\n"},{"title":"线程池与并发工具","date":"2022-03-31T12:53:05.000Z","top_img":"/img/cover/thread_pool.png","cover":"/img/cover/thread_pool.png","_content":"\n## 前言\n疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## 线程池\n使用线程池的好处：\n+ **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗\n+ **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行\n+ **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\n\n线程池的类关系如图所示：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/ScheduledThreadPoolExecutor.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程池的类关系图\n    </div>\n</center>\n\n### Executor框架接口\nExecutor框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架，目的是提供一种机制，**将“任务提交”与“任务如何运行”分离开来**。\n\nJ.U.C中有三个Executor接口：\n+ **Executor**：一个运行新任务的简单接口；\n+ **ExecutorService**：扩展了`Executor`接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；\n+ **ScheduledExecutorService**：扩展了`ExecutorService`接口。支持`Future`和定期执行任务。\n\n#### Executor接口\nExecutor接口只有一个`execute`方法，用来替代创建或启动线程的方法\n```java\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n\n例如，使用`Thread`来创建并启动线程的代码如下：\n```java\nThread t = new Thread();\nt.start();\n```\n\n而使用`Executor`来启动线程就是：\n```java\nThread t = new Thread();\nexecutor.execute(t);\n```\n\n至于`execute()`方法如何执行代码，则要结合实际的线程池实现考虑\n\n#### ExecutorService接口\n`ExecutorService`接口继承自`Executor`接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成`Future`的方法。增加了`shutDown()`，`shutDownNow()`，`invokeAll()`，`invokeAny()`和`submit()`等方法。如果需要支持即时关闭，也就是`shutDownNow()`方法，则任务需要正确处理中断。\n\n```java\n// 执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括哪些还未开始执行的任务\nvoid shutdown();\n// 执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务\nList<Runnable> shutdownNow();\n// 等待ExecutorService到达终止状态\nboolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n// 提交任务，通过返回的Future跟踪任务的运行状态\n<T> Future<T> submit(Callable<T> task);\n// 执行批量任务\n<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n// 执行批量任务中的任意一个\n<T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n```\n\n在`ExecutorService`关闭后提交的任务将由“拒绝执行处理器(`RejectExecutionHandler`)”来处理，它会抛弃任务，或者使得`execute`方法抛出一个未检查的`RejectedExecutionException`。\n\n#### ScheduledExecutorService接口\n`ScheduledExecutorService`扩展`ExecutorService`接口并增加了`schedule`方法。\n\n```java\n// 创建并执行在给定延迟后启用的一次性操作\npublic ScheduledFuture<?> schedule(Runnable command,\n                                    long delay, TimeUnit unit);\n// 创建并执行在给定延迟后启用的 ScheduledFuture\npublic <V> ScheduledFuture<V> schedule(Callable<V> callable,\n                                        long delay, TimeUnit unit);\n```\n\n调用`schedule`方法可以在指定的延时后执行一个`Runnable`或者`Callable`任务。`ScheduledExecutorService`接口还定义了按照指定时间间隔定期执行任务的`scheduleAtFixedRate()`方法和`scheduleWithFixedDelay()`方法。\n\n### ThreadPoolExecutor\n`ThreadPoolExecutor`继承自`AbstractExecutorService`，也实现了`ExecutorService`接口。`ThreadPoolExecutor`构造方法如下：\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue<Runnable> workQueue,\n                            ThreadFactory threadFactory,\n                            RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n\n构造方法中的字段含义如下：\n+ **corePoolSize**：核心线程数量，当有新任务在`execute()`方法提交时，会执行以下判断：\n    + 如果运行的线程少于`corePoolSize`，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；\n    + 如果线程池中的线程数量大于等于`corePoolSize`且小于`maximumPoolSize`，则只有当`workQueue`满时才创建新的线程去处理任务；\n    + 如果设置的`corePoolSize`和`maximumPoolSize`相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若`workQueue`未满，则将请求放入`workQueue`中，等待有空闲的线程去从`workQueue`中取任务并处理；\n    + 如果运行的线程数量大于等于`maximumPoolSize`，这时如果`workQueue`已经满了，则通过`handler`所指定的策略来处理任务；\n    所以任务提交时，判断的顺序为 `corePoolSize` –> `workQueue` –> `maximumPoolSize`。\n+ **maximumPoolSize**：最大线程数量；\n+ **workQueue**：等待队列，当任务提交时，如果线程池中的线程数量大于等于`corePoolSize`的时候，把该任务封装成一个Worker对象放入等待队列；\n+ **workQueue**：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:\n    + **直接切换**：这种方式常用的队列是`SynchronousQueue`，但现在还没有研究过该队列，这里暂时还没法介绍；\n    + **使用无界队列**：一般使用基于链表的阻塞队列`LinkedBlockingQueue`。如果使用这种方式，那么线程池中能够创建的最大线程数就是`corePoolSize`，而`maximumPoolSize`就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是`RUNNING`状态时，这时一个新的任务提交就会放入等待队列中。\n    + **使用有界队列**：一般使用`ArrayBlockingQueue`。使用该方式可以将线程池的最大线程数量限制为`maximumPoolSize`，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。\n        + 如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。\n        + 如果提交的任务经常发生阻塞，那么可以考虑通过调用`setMaximumPoolSize()` 方法来重新设定线程池的容量。\n        + 如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。\n+ **keepAliveTime**：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于`corePoolSize`的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了`keepAliveTime`；\n+ **threadFactory**：它是`ThreadFactory`类型的变量，用来创建新线程。默认使用`Executors.defaultThreadFactory()`来创建线程。使用默认的`ThreadFactory`来创建线程时，会使新创建的线程具有相同的`NORM_PRIORITY`优先级并且是非守护线程，同时也设置了线程的名称。\n+ **handler**：它是`RejectedExecutionHandler`类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：\n    + AbortPolicy：直接抛出异常，这是默认策略；\n    + CallerRunsPolicy：用调用者所在的线程来执行任务；\n    + DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n    + DiscardPolicy：直接丢弃任务；\n\n#### execute方法\n`execute()`方法用来提交任务，执行逻辑如下图：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_pool_execute.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        execute()执行逻辑\n    </div>\n</center>\n\n+ 如果当前运行的线程少于`corePoolSize`，则会创建新的线程来执行新的任务；\n+ 如果运行的线程个数等于或者大于`corePoolSize`，则会将提交的任务存放到阻塞队列`workQueue`中；\n+ 如果当前`workQueue`队列已满的话，则会创建新的线程来执行任务；\n+ 如果线程个数已经超过了`maximumPoolSize`，则会使用饱和策略`RejectedExecutionHandler`来进行处理。\n\n### ScheduledThreadPoolExecutor\n`ScheduledThreadPoolExecutor`继承了`ThreadPoolExecutor`，拥有`execute()`和 `submit()`提交异步任务的基础功能；同时实现了`ScheduledExecutorService`接口，拥有延时执行任务和周期执行任务的功能。\n\n```java\n// 达到给定的延时时间后，执行任务。这里传入的是实现Runnable接口的任务，\n// 因此通过ScheduledFuture.get()获取结果为null\npublic ScheduledFuture<?> schedule(Runnable command,\n                                    long delay, TimeUnit unit);\n// 达到给定的延时时间后，执行任务。这里传入的是实现Callable接口的任务，\n// 因此，返回的是任务的最终计算结果\npublic <V> ScheduledFuture<V> schedule(Callable<V> callable,\n                                        long delay, TimeUnit unit);\n// 是以上一个任务开始的时间计时，period时间过去后，\n// 检测上一个任务是否执行完毕，如果上一个任务执行完毕，\n// 则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                                long initialDelay,\n                                                long period,\n                                                TimeUnit unit);\n// 当达到延时时间initialDelay后，任务开始执行。上一个任务执行结束后到下一次\n// 任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                long initialDelay,\n                                                long delay,\n                                                TimeUnit unit);\n```\n\n`ScheduledThreadPoolExecutor`中为了实现可延时执行任务和周期性执行任务的特性，任务会被转换成`ScheduledFutureTask`类，该类继承了`FutureTask`，并重写了`run`方法。\n\n`ScheduledThreadPoolExecutor`也两个重要的内部类：`DelayedWorkQueue`和`ScheduledFutureTask`。`DelayedWorkQueue`实现了`BlockingQueue`接口，也就是一个阻塞队列；`ScheduledFutureTask`则是继承了`FutureTask`类，也表示该类用于返回异步任务的结果。\n+ `ScheduledFutureTask`最主要的功能是根据当前任务是否具有周期性，对异步任务进行进一步封装。如果不是周期性任务（调用`schedule`方法）则直接通过`run()`执行，若是周期性任务，则需要在每一次执行完后，重设下一次执行的时间，然后将下一次任务继续放入到阻塞队列中。\n+ `DelayedWorkQueue`是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行。\n\n### FutureTask基本操作\n在`Executors`框架体系中，`FutureTask`用来表示可获取结果的异步任务。`FutureTask`实现了`Future`接口，`FutureTask`提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法。通过`get()`方法来获取异步任务的结果，但是会阻塞当前线程直至异步任务执行结束。一旦任务执行结束，任务不能重新启动或取消，除非调用`runAndReset()`方法。\n\n`FutureTask`的3种状态：\n+ **未启动**：`FutureTask.run()`方法还没有被执行之前，`FutureTask`处于未启动状态。当创建一个 `FutureTask`，还没有执行 `FutureTask.run()`方法之前，`FutureTask`处于未启动状态。\n+ **已启动**：`FutureTask.run()`方法被执行的过程中，`FutureTask`处于已启动状态。\n+ **已完成**：`FutureTask.run()`方法执行结束，或者调用`FutureTask.cancel(...)`方法取消任务，或者在执行任务期间抛出异常，这些情况都称之为`FutureTask`的已完成状态。\n\n主要方法如下：\n```java\n// 当 FutureTask 处于未启动或已启动状态时，执行 FutureTask.get()方法将导致调用线程阻塞\n// 如果 FutureTask 处于已完成状态，调用 FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常\nget()\n\n// 与get()相同，但是阻塞时是有时限的等待\nget(long timeout, TimeUnit unit)\n\n// 当 FutureTask 处于未启动状态时，执行 FutureTask.cancel()方法将此任务永远不会执行；\n// 当 FutureTask 处于已启动状态时，执行 FutureTask.cancel(true)方法将以中断线程的方式来阻止任务\n//    继续进行，如果执行 FutureTask.cancel(false)将不会对正在执行任务的线程有任何影响；\n// 当FutureTask处于已完成状态时，执行 FutureTask.cancel(...)方法将返回 false。\ncancel()\n\n// 来自RunnableFuture接口，运行任务\nrun()\n\n// 想执行多次会调用\nrunAndReset()\n```\n\n`FutureTask`除了实现`Future`接口外，还实现了`Runnable`接口。因此，`FutureTask`可以出现在任何替代`Runnable`的地方，也可以被线程直接调用`FutureTask.run()`。\n\n`Future`本身适用于解决多线程执行若干个任务，每个任务只需只需一次的情况，用`Future`可避免不必要的多次执行。\n\n最后放一个线程池的示例代码：\n```java\npublic class FutureRenderer {\n    private final ExecutorService = new ThreadPoolExecutor();\n\n    void renderPage() {\n        final List<ImageInfo> imageInfos = scanForImageInfo(source);\n        Callable<List<ImageData>> task =\n            new Callable<List<ImageData>> () {\n                public List<ImageData> call() {\n                    List<ImageData> result = new ArrayList<ImageData>();\n                    for (ImageInfo imageInfo : imageInfos) {\n                        result.add(imageInfo.downloadImage());\n                    }\n                    return result;\n                }\n            };\n        \n        Future<List<ImageData>> future = executor.submit(task);\n        renderText(source);\n\n        try {\n            List<ImageData> imageData = future.get();\n            for (ImageData data : imageData) {\n                renderImage(data);\n            }\n        } catch (InterruptedException e) {\n            // 重新设置线程的中断状态\n            Thread.currentThread().interrupt();\n            // 由于不需要结果，因此取消任务\n            future.cancel(true);\n        } catch (ExecutionException e) {\n            throw launderThrowable(e.getCause());\n        }\n    }\n}\n```\n`renderPage()`方法负责渲染一个页面，其中页面可分为文字和图片两部分，图片下载时间较慢，因此通过多线程并行的方式加快速度。当然这个程序还能继续做并行，这里仅为了演示，不再深入，详见书本`6.3.3`节。\n\n## 并发工具\n这里主要记录一下书中提到的几种并发工具\n\n### AbstractQueuedSynchronizer(AQS)\nAQS是实现`CountDownLatch`、`Semaphore`等同步工具的基础，它负责管理同步器中的状态。\n\n它管理了一个整数状态信息，可以通过`getState`、`setState`以及`compareAndSetState`等`protected`类型的方法进行操作。这个整数可以表示任何信息，如在`ReentrantLock`中表示所有者线程已经重复获取该锁的次数；`Semaphore`用它来表示剩余的许可数量；`FutureTask`用它来表示任务的状态，等等\n\n\n如下代码给出了AQS中获取操作与释放操作的形式。根据同步器的不同，获取操作可以是一种独占操作（如`ReentrantLock`），也可以是一个非独占操作（如`Semaphore`和`CountDownLatch`）。\n\n一个获取操作包括两部分。首先，同步器判断当前状态是否允许获得操作，如果是，则允许线程执行，否则获取操作将阻塞或失败。\n其次就是更新同步器的状态，获取同步器的某个线程可能会对其他线程能否也获取该同步器造成影响。例如，当获取一个锁后，锁的状态将从“未被持有”变成“已被持有”，而从`Semaphore`中获取一个许可后，将把剩余许可的数量减一。\n```java\nboolean acquire() throws InterruptedException {\n    while (当前状态不允许获取操作) {\n        if (需要阻塞获取请求) {\n            如果当前线程不在队列中，则将其插入队列\n            阻塞当前线程\n        } else {\n            返回失败\n        }\n    }\n    可能更新同步器的状态\n    如果线程位于队列中，则将其移出队列\n    返回成功\n}\n\nvoid release() {\n    更新同步器的状态\n    if (新的状态允许某个被阻塞的线程获取成功) {\n        解除队列中一个或多个线程的阻塞状态\n    }\n}\n```\n\n利用AQS实现闭锁的示例：\n```java\npublic class OneShotLatch {\n    private final Sync sync = new Sync();\n    public void signal() { sync.releaseShared(0); }\n    public void await() throws InterruptedException {\n        sync.acquireSharedInterruptibly(0);\n    }\n\n    private class Sync extends AbstractQueuedSynchronizer {\n        protected int tryAcquireShared(int ignored) {\n            // 如果闭锁是开的(state == 1)，那么这个操作将成功，否则失败\n            return (getState() == 1) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int ignored) {\n            setState(1);    // 现在打开闭锁\n            return true;    // 现在其他的线程可以获取该闭锁\n        }\n    }\n}\n```\n\n### ReentrantLock\n`ReentrantLock`只支持独占的获取操作，因此它实现了`tryAcquire`、`tryRelease`和`isHeldExclusively`。\n\n`ReentrantLock`将同步状态用于保存锁获取操作的次数，并且还维护一个`owner`变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要放锁的时候，才会修改这个变量。在`tryRelease`中检查`owner`域，从而确保当前线程在执行unlock操作之前已经获取到了锁；在`tryAcquire`中将使用这个域来区分获取操作是重入的还是竞争的。\n\n```java\nprotected boolean tryAcquire(int ignored) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    // 无人持有锁\n    if (c == 0) {\n        // 利用原子更新尝试拿锁\n        if (compareAndSetState(0, 1)) {\n            owner = current;\n            return true;\n        }\n    // 已经有人持有锁，判断是否是自己重入\n    } else if (current == owner) {\n        setState(c + 1);\n        return true;\n    }\n    // 尝试拿锁失败\n    return false;\n}\n```\n\n### CountDownLatch\n倒计时器\n\n在多线程协作完成任务时，通常需要主线程等待其他线程运行完成后继续往下执行。这时通常可以使用`Thread`的`join`方法，也可以使用`CountDownLatch`\n\n先从`CountDownLatch`的构造方法看起\n```java\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n```\n其核心的内部对象就是`sync`，是一个继承了AQS的静态final私有类，它控制着倒计时器的同步逻辑\n\n`CountDownLatch`的其他方法如下\n```java\n// 阻塞等待，直到当前CountDownLatch的计数变为0\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n// 阻塞等待，直到当前CountDownLatch的计数变为0；或者等待时间超时\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n\n// 减小计数，如果计数为0，就释放所有调用await()阻塞的线程\npublic void countDown() {\n    sync.releaseShared(1);\n}\n\n// 返回当前计数\npublic long getCount() {\n    return sync.getCount();\n}\n```\n\n示例代码如下：\n```java\npublic class CountDownLatchDemo {\n    private static CountDownLatch startSignal = new CountDownLatch(1);\n    //用来表示裁判员需要维护的是6个运动员\n    private static CountDownLatch endSignal = new CountDownLatch(6);\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(6);\n        for (int i = 0; i < 6; i++) {\n            executorService.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 运动员等待裁判员响哨！！！\");\n                    // 阻塞，等待主线程中的startSignal.countDown()，然后开始执行\n                    startSignal.await();\n                    System.out.println(Thread.currentThread().getName() + \"正在全力冲刺\");\n                    // 计数--\n                    endSignal.countDown();\n                    System.out.println(Thread.currentThread().getName() + \"  到达终点\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        System.out.println(\"裁判员发号施令啦！！！\");\n        // 计数--，线程池开始同时执行\n        startSignal.countDown();\n        // 阻塞，等待所有线程中的endSignal.countDown()，计数为0后开始执行\n        endSignal.await();\n        System.out.println(\"所有运动员到达终点，比赛结束！\");\n        executorService.shutdown();\n    }\n}\n```\n\n### CyclicBarrier\n循环栅栏\n\n`CyclicBarrier`与`CountDownLatch`功能类似，都有等待计数的功能，但功能比`CountDownLatch`更加强大。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cyclicbarrier_count.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        CyclicBarrier示意图\n    </div>\n</center>\n\n\n`CyclicBarrier`的主要方法如下所示：\n```java\n// 构造方法，指定线程均到达以后，执行barrierAction定义的操作（然后各线程再继续向下执行）\npublic CyclicBarrier(int parties, Runnable barrierAction)\n\n// 等到所有的线程都到达指定的临界点\nawait() throws InterruptedException, BrokenBarrierException\n\n// 与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止\nawait(long timeout, TimeUnit unit) throws InterruptedException,\nBrokenBarrierException, TimeoutException\n\n// 获取当前有多少个线程阻塞等待在临界点上\nint getNumberWaiting()\n\n// 用于查询阻塞等待的线程是否被中断\nboolean isBroken()\n\n// 将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException\nvoid reset()\n```\n\n示例代码：\n```java\npublic class CyclicBarrierDemo {\n    // 指定必须有3个运动员到达才行\n    private static CyclicBarrier barrier = new CyclicBarrier(3, () -> {\n        System.out.println(\"所有运动员入场，裁判员一声令下！！！！！\");\n    });\n\n    public static void main(String[] args) {\n        System.out.println(\"运动员准备进场，全场欢呼............\");\n        ExecutorService service = Executors.newFixedThreadPool(3);\n        for (int i = 0; i <= 3; i++) {\n            service.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 运动员，进场\");\n                    // 等指定数量的线程都到了之后再一起往下执行\n                    barrier.await();\n                    System.out.println(Thread.currentThread().getName() + \"  运动员出发\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }\n}\n```\n\n输出结果：\n```sh\n运动员准备进场，全场欢呼............\npool-1-thread-2 运动员，进场\npool-1-thread-1 运动员，进场\npool-1-thread-3 运动员，进场\n所有运动员入场，裁判员一声令下！！！！！\npool-1-thread-1  运动员出发\npool-1-thread-3  运动员出发\npool-1-thread-2  运动员出发\n```\n\n#### CountDownLatch与CyclicBarrier的比较\n`CountDownLatch`与`CyclicBarrier`都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n+ `CountDownLatch`一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而`CyclicBarrier`一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；\n+ 调用`CountDownLatch`的`countDown`方法后，当前线程并不会阻塞，会继续往下执行；而调用`CyclicBarrier`的`await`方法，会阻塞当前线程，直到`CyclicBarrier`指定的线程全部都到达了指定点的时候，才能继续往下执行；\n+ `CountDownLatch` 方法比较少，操作比较简单，而`CyclicBarrier`提供的方法更多，比如能够通过`getNumberWaiting()`，`isBroken()`这些方法获取当前多个线程的状态，并且`CyclicBarrier`的构造方法可以传入`barrierAction`，指定当所有线程都到达时执行的业务功能；\n+ `CountDownLatch` 是不能复用的，而`CyclicBarrier`是可以复用的。\n\n### Semaphore\n`Semaphore`可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。与`Lock`相似但不同，`Semaphore`支持同时有多个线程获取到资格。\n\n`Semaphore`可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。\n\n`Semaphore`的内部也保存有通过继承AQS实现的私有静态final类，负责实现同步的逻辑\n\n`Semaphore`的主要方法如下：\n```java\n// 获取许可，如果无法获取到，则阻塞等待直至能够获取为止\nvoid acquire() throws InterruptedException\n// 同acquire方法功能基本一样，只不过该方法可以一次获取多个许可\nvoid acquire(int permits) throws InterruptedException\n// 释放许可\nvoid release()\n// 释放指定个数的许可\nvoid release(int permits)\n// 尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false\nboolean tryAcquire()\n// 与tryAcquire方法一致，只不过这里可以指定获取多个许可\nboolean tryAcquire(int permits)\n// 尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false\nboolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n// 与上一个方法一致，只不过这里能够获取多个许可\nboolean tryAcquire(int permits, long timeout, TimeUnit unit)\n// 返回当前可用的许可证个数\nint availablePermits()\n// 返回正在等待获取许可证的线程数\nint getQueueLength()\n// 是否有线程正在等待获取许可证\nboolean hasQueuedThreads()\n// 获取所有正在等待许可的线程集合\nCollection<Thread> getQueuedThreads()\n```\n\n`Semaphore`也支持公平性和非公平性，默认是非公平性，这样吞吐量更高\n\n示例代码：\n```java\npublic class SemaphoreDemo {\n\n    //表示老师只有10支笔\n    private static Semaphore semaphore = new Semaphore(5);\n\n    public static void main(String[] args) {\n        //表示50个学生\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 10; i++) {\n            service.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  同学准备获取笔......\");\n                    // 尝试获取资源，会阻塞\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  同学获取到笔\");\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  填写表格ing.....\");\n                    TimeUnit.SECONDS.sleep(3);\n                    // 释放资源\n                    semaphore.release();\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  填写完表格，归还了笔！\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        service.shutdown();\n    }\n}\n\n```\n\n### Exchanger\n`Exchanger`是一个用于线程间协作的工具类（模板类）。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据的方法就是`exchange`方法\n\n主要方法如下：\n```java\n// 当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点\n// 将数据交换给另一个线程，同时返回获取的数据\nV exchange(V x) throws InterruptedException\n// 同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间\nV exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException\n```\n\n示例代码：\n```java\npublic class ExchangerDemo {\n    private static Exchanger<String> exchanger = new Exchanger();\n    public static void main(String[] args) {\n        //代表男生和女生\n        ExecutorService service = Executors.newFixedThreadPool(2);\n        service.execute(() -> {\n            try {\n                //男生对女生说的话\n                String girl = exchanger.exchange(\"我其实暗恋你很久了......\");\n                System.out.println(\"女孩儿说：\" + girl);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        service.execute(() -> {\n            try {\n                System.out.println(\"女生慢慢的从教室你走出来......\");\n                TimeUnit.SECONDS.sleep(3);\n                //男生对女生说的话\n                String boy = exchanger.exchange(\"我也很喜欢你......\");\n                System.out.println(\"男孩儿说：\" + boy);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n}\n```\n\n输出结果：\n```sh\n女生慢慢的从教室你走出来......\n女孩儿说：我也很喜欢你......\n男孩儿说：我其实暗恋你很久了......\n```\n\n## 参考\n由于这部分的内容相对复杂，且需要深入到源码理解，才能比较透彻，因此参考了别人的笔记\n[深入理解Java线程池：ThreadPoolExecutor](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95)  \n[Github: Java-concurrency](https://github.com/CL0610/Java-concurrency)  \n","source":"_posts/线程池与并发工具.md","raw":"---\ntitle: 线程池与并发工具\ndate: 2022-03-31 20:53:05\ntop_img: /img/cover/thread_pool.png\ncover: /img/cover/thread_pool.png\ntags: [Java, 笔记]\n---\n\n## 前言\n疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。\n\n原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。\n\n## 线程池\n使用线程池的好处：\n+ **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗\n+ **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行\n+ **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控\n\n线程池的类关系如图所示：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/ScheduledThreadPoolExecutor.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程池的类关系图\n    </div>\n</center>\n\n### Executor框架接口\nExecutor框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架，目的是提供一种机制，**将“任务提交”与“任务如何运行”分离开来**。\n\nJ.U.C中有三个Executor接口：\n+ **Executor**：一个运行新任务的简单接口；\n+ **ExecutorService**：扩展了`Executor`接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；\n+ **ScheduledExecutorService**：扩展了`ExecutorService`接口。支持`Future`和定期执行任务。\n\n#### Executor接口\nExecutor接口只有一个`execute`方法，用来替代创建或启动线程的方法\n```java\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n\n例如，使用`Thread`来创建并启动线程的代码如下：\n```java\nThread t = new Thread();\nt.start();\n```\n\n而使用`Executor`来启动线程就是：\n```java\nThread t = new Thread();\nexecutor.execute(t);\n```\n\n至于`execute()`方法如何执行代码，则要结合实际的线程池实现考虑\n\n#### ExecutorService接口\n`ExecutorService`接口继承自`Executor`接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成`Future`的方法。增加了`shutDown()`，`shutDownNow()`，`invokeAll()`，`invokeAny()`和`submit()`等方法。如果需要支持即时关闭，也就是`shutDownNow()`方法，则任务需要正确处理中断。\n\n```java\n// 执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括哪些还未开始执行的任务\nvoid shutdown();\n// 执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务\nList<Runnable> shutdownNow();\n// 等待ExecutorService到达终止状态\nboolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n// 提交任务，通过返回的Future跟踪任务的运行状态\n<T> Future<T> submit(Callable<T> task);\n// 执行批量任务\n<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n// 执行批量任务中的任意一个\n<T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n```\n\n在`ExecutorService`关闭后提交的任务将由“拒绝执行处理器(`RejectExecutionHandler`)”来处理，它会抛弃任务，或者使得`execute`方法抛出一个未检查的`RejectedExecutionException`。\n\n#### ScheduledExecutorService接口\n`ScheduledExecutorService`扩展`ExecutorService`接口并增加了`schedule`方法。\n\n```java\n// 创建并执行在给定延迟后启用的一次性操作\npublic ScheduledFuture<?> schedule(Runnable command,\n                                    long delay, TimeUnit unit);\n// 创建并执行在给定延迟后启用的 ScheduledFuture\npublic <V> ScheduledFuture<V> schedule(Callable<V> callable,\n                                        long delay, TimeUnit unit);\n```\n\n调用`schedule`方法可以在指定的延时后执行一个`Runnable`或者`Callable`任务。`ScheduledExecutorService`接口还定义了按照指定时间间隔定期执行任务的`scheduleAtFixedRate()`方法和`scheduleWithFixedDelay()`方法。\n\n### ThreadPoolExecutor\n`ThreadPoolExecutor`继承自`AbstractExecutorService`，也实现了`ExecutorService`接口。`ThreadPoolExecutor`构造方法如下：\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue<Runnable> workQueue,\n                            ThreadFactory threadFactory,\n                            RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n```\n\n构造方法中的字段含义如下：\n+ **corePoolSize**：核心线程数量，当有新任务在`execute()`方法提交时，会执行以下判断：\n    + 如果运行的线程少于`corePoolSize`，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；\n    + 如果线程池中的线程数量大于等于`corePoolSize`且小于`maximumPoolSize`，则只有当`workQueue`满时才创建新的线程去处理任务；\n    + 如果设置的`corePoolSize`和`maximumPoolSize`相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若`workQueue`未满，则将请求放入`workQueue`中，等待有空闲的线程去从`workQueue`中取任务并处理；\n    + 如果运行的线程数量大于等于`maximumPoolSize`，这时如果`workQueue`已经满了，则通过`handler`所指定的策略来处理任务；\n    所以任务提交时，判断的顺序为 `corePoolSize` –> `workQueue` –> `maximumPoolSize`。\n+ **maximumPoolSize**：最大线程数量；\n+ **workQueue**：等待队列，当任务提交时，如果线程池中的线程数量大于等于`corePoolSize`的时候，把该任务封装成一个Worker对象放入等待队列；\n+ **workQueue**：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:\n    + **直接切换**：这种方式常用的队列是`SynchronousQueue`，但现在还没有研究过该队列，这里暂时还没法介绍；\n    + **使用无界队列**：一般使用基于链表的阻塞队列`LinkedBlockingQueue`。如果使用这种方式，那么线程池中能够创建的最大线程数就是`corePoolSize`，而`maximumPoolSize`就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是`RUNNING`状态时，这时一个新的任务提交就会放入等待队列中。\n    + **使用有界队列**：一般使用`ArrayBlockingQueue`。使用该方式可以将线程池的最大线程数量限制为`maximumPoolSize`，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。\n        + 如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。\n        + 如果提交的任务经常发生阻塞，那么可以考虑通过调用`setMaximumPoolSize()` 方法来重新设定线程池的容量。\n        + 如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。\n+ **keepAliveTime**：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于`corePoolSize`的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了`keepAliveTime`；\n+ **threadFactory**：它是`ThreadFactory`类型的变量，用来创建新线程。默认使用`Executors.defaultThreadFactory()`来创建线程。使用默认的`ThreadFactory`来创建线程时，会使新创建的线程具有相同的`NORM_PRIORITY`优先级并且是非守护线程，同时也设置了线程的名称。\n+ **handler**：它是`RejectedExecutionHandler`类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：\n    + AbortPolicy：直接抛出异常，这是默认策略；\n    + CallerRunsPolicy：用调用者所在的线程来执行任务；\n    + DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；\n    + DiscardPolicy：直接丢弃任务；\n\n#### execute方法\n`execute()`方法用来提交任务，执行逻辑如下图：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_pool_execute.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        execute()执行逻辑\n    </div>\n</center>\n\n+ 如果当前运行的线程少于`corePoolSize`，则会创建新的线程来执行新的任务；\n+ 如果运行的线程个数等于或者大于`corePoolSize`，则会将提交的任务存放到阻塞队列`workQueue`中；\n+ 如果当前`workQueue`队列已满的话，则会创建新的线程来执行任务；\n+ 如果线程个数已经超过了`maximumPoolSize`，则会使用饱和策略`RejectedExecutionHandler`来进行处理。\n\n### ScheduledThreadPoolExecutor\n`ScheduledThreadPoolExecutor`继承了`ThreadPoolExecutor`，拥有`execute()`和 `submit()`提交异步任务的基础功能；同时实现了`ScheduledExecutorService`接口，拥有延时执行任务和周期执行任务的功能。\n\n```java\n// 达到给定的延时时间后，执行任务。这里传入的是实现Runnable接口的任务，\n// 因此通过ScheduledFuture.get()获取结果为null\npublic ScheduledFuture<?> schedule(Runnable command,\n                                    long delay, TimeUnit unit);\n// 达到给定的延时时间后，执行任务。这里传入的是实现Callable接口的任务，\n// 因此，返回的是任务的最终计算结果\npublic <V> ScheduledFuture<V> schedule(Callable<V> callable,\n                                        long delay, TimeUnit unit);\n// 是以上一个任务开始的时间计时，period时间过去后，\n// 检测上一个任务是否执行完毕，如果上一个任务执行完毕，\n// 则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                                long initialDelay,\n                                                long period,\n                                                TimeUnit unit);\n// 当达到延时时间initialDelay后，任务开始执行。上一个任务执行结束后到下一次\n// 任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                long initialDelay,\n                                                long delay,\n                                                TimeUnit unit);\n```\n\n`ScheduledThreadPoolExecutor`中为了实现可延时执行任务和周期性执行任务的特性，任务会被转换成`ScheduledFutureTask`类，该类继承了`FutureTask`，并重写了`run`方法。\n\n`ScheduledThreadPoolExecutor`也两个重要的内部类：`DelayedWorkQueue`和`ScheduledFutureTask`。`DelayedWorkQueue`实现了`BlockingQueue`接口，也就是一个阻塞队列；`ScheduledFutureTask`则是继承了`FutureTask`类，也表示该类用于返回异步任务的结果。\n+ `ScheduledFutureTask`最主要的功能是根据当前任务是否具有周期性，对异步任务进行进一步封装。如果不是周期性任务（调用`schedule`方法）则直接通过`run()`执行，若是周期性任务，则需要在每一次执行完后，重设下一次执行的时间，然后将下一次任务继续放入到阻塞队列中。\n+ `DelayedWorkQueue`是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行。\n\n### FutureTask基本操作\n在`Executors`框架体系中，`FutureTask`用来表示可获取结果的异步任务。`FutureTask`实现了`Future`接口，`FutureTask`提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法。通过`get()`方法来获取异步任务的结果，但是会阻塞当前线程直至异步任务执行结束。一旦任务执行结束，任务不能重新启动或取消，除非调用`runAndReset()`方法。\n\n`FutureTask`的3种状态：\n+ **未启动**：`FutureTask.run()`方法还没有被执行之前，`FutureTask`处于未启动状态。当创建一个 `FutureTask`，还没有执行 `FutureTask.run()`方法之前，`FutureTask`处于未启动状态。\n+ **已启动**：`FutureTask.run()`方法被执行的过程中，`FutureTask`处于已启动状态。\n+ **已完成**：`FutureTask.run()`方法执行结束，或者调用`FutureTask.cancel(...)`方法取消任务，或者在执行任务期间抛出异常，这些情况都称之为`FutureTask`的已完成状态。\n\n主要方法如下：\n```java\n// 当 FutureTask 处于未启动或已启动状态时，执行 FutureTask.get()方法将导致调用线程阻塞\n// 如果 FutureTask 处于已完成状态，调用 FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常\nget()\n\n// 与get()相同，但是阻塞时是有时限的等待\nget(long timeout, TimeUnit unit)\n\n// 当 FutureTask 处于未启动状态时，执行 FutureTask.cancel()方法将此任务永远不会执行；\n// 当 FutureTask 处于已启动状态时，执行 FutureTask.cancel(true)方法将以中断线程的方式来阻止任务\n//    继续进行，如果执行 FutureTask.cancel(false)将不会对正在执行任务的线程有任何影响；\n// 当FutureTask处于已完成状态时，执行 FutureTask.cancel(...)方法将返回 false。\ncancel()\n\n// 来自RunnableFuture接口，运行任务\nrun()\n\n// 想执行多次会调用\nrunAndReset()\n```\n\n`FutureTask`除了实现`Future`接口外，还实现了`Runnable`接口。因此，`FutureTask`可以出现在任何替代`Runnable`的地方，也可以被线程直接调用`FutureTask.run()`。\n\n`Future`本身适用于解决多线程执行若干个任务，每个任务只需只需一次的情况，用`Future`可避免不必要的多次执行。\n\n最后放一个线程池的示例代码：\n```java\npublic class FutureRenderer {\n    private final ExecutorService = new ThreadPoolExecutor();\n\n    void renderPage() {\n        final List<ImageInfo> imageInfos = scanForImageInfo(source);\n        Callable<List<ImageData>> task =\n            new Callable<List<ImageData>> () {\n                public List<ImageData> call() {\n                    List<ImageData> result = new ArrayList<ImageData>();\n                    for (ImageInfo imageInfo : imageInfos) {\n                        result.add(imageInfo.downloadImage());\n                    }\n                    return result;\n                }\n            };\n        \n        Future<List<ImageData>> future = executor.submit(task);\n        renderText(source);\n\n        try {\n            List<ImageData> imageData = future.get();\n            for (ImageData data : imageData) {\n                renderImage(data);\n            }\n        } catch (InterruptedException e) {\n            // 重新设置线程的中断状态\n            Thread.currentThread().interrupt();\n            // 由于不需要结果，因此取消任务\n            future.cancel(true);\n        } catch (ExecutionException e) {\n            throw launderThrowable(e.getCause());\n        }\n    }\n}\n```\n`renderPage()`方法负责渲染一个页面，其中页面可分为文字和图片两部分，图片下载时间较慢，因此通过多线程并行的方式加快速度。当然这个程序还能继续做并行，这里仅为了演示，不再深入，详见书本`6.3.3`节。\n\n## 并发工具\n这里主要记录一下书中提到的几种并发工具\n\n### AbstractQueuedSynchronizer(AQS)\nAQS是实现`CountDownLatch`、`Semaphore`等同步工具的基础，它负责管理同步器中的状态。\n\n它管理了一个整数状态信息，可以通过`getState`、`setState`以及`compareAndSetState`等`protected`类型的方法进行操作。这个整数可以表示任何信息，如在`ReentrantLock`中表示所有者线程已经重复获取该锁的次数；`Semaphore`用它来表示剩余的许可数量；`FutureTask`用它来表示任务的状态，等等\n\n\n如下代码给出了AQS中获取操作与释放操作的形式。根据同步器的不同，获取操作可以是一种独占操作（如`ReentrantLock`），也可以是一个非独占操作（如`Semaphore`和`CountDownLatch`）。\n\n一个获取操作包括两部分。首先，同步器判断当前状态是否允许获得操作，如果是，则允许线程执行，否则获取操作将阻塞或失败。\n其次就是更新同步器的状态，获取同步器的某个线程可能会对其他线程能否也获取该同步器造成影响。例如，当获取一个锁后，锁的状态将从“未被持有”变成“已被持有”，而从`Semaphore`中获取一个许可后，将把剩余许可的数量减一。\n```java\nboolean acquire() throws InterruptedException {\n    while (当前状态不允许获取操作) {\n        if (需要阻塞获取请求) {\n            如果当前线程不在队列中，则将其插入队列\n            阻塞当前线程\n        } else {\n            返回失败\n        }\n    }\n    可能更新同步器的状态\n    如果线程位于队列中，则将其移出队列\n    返回成功\n}\n\nvoid release() {\n    更新同步器的状态\n    if (新的状态允许某个被阻塞的线程获取成功) {\n        解除队列中一个或多个线程的阻塞状态\n    }\n}\n```\n\n利用AQS实现闭锁的示例：\n```java\npublic class OneShotLatch {\n    private final Sync sync = new Sync();\n    public void signal() { sync.releaseShared(0); }\n    public void await() throws InterruptedException {\n        sync.acquireSharedInterruptibly(0);\n    }\n\n    private class Sync extends AbstractQueuedSynchronizer {\n        protected int tryAcquireShared(int ignored) {\n            // 如果闭锁是开的(state == 1)，那么这个操作将成功，否则失败\n            return (getState() == 1) ? 1 : -1;\n        }\n\n        protected boolean tryReleaseShared(int ignored) {\n            setState(1);    // 现在打开闭锁\n            return true;    // 现在其他的线程可以获取该闭锁\n        }\n    }\n}\n```\n\n### ReentrantLock\n`ReentrantLock`只支持独占的获取操作，因此它实现了`tryAcquire`、`tryRelease`和`isHeldExclusively`。\n\n`ReentrantLock`将同步状态用于保存锁获取操作的次数，并且还维护一个`owner`变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要放锁的时候，才会修改这个变量。在`tryRelease`中检查`owner`域，从而确保当前线程在执行unlock操作之前已经获取到了锁；在`tryAcquire`中将使用这个域来区分获取操作是重入的还是竞争的。\n\n```java\nprotected boolean tryAcquire(int ignored) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    // 无人持有锁\n    if (c == 0) {\n        // 利用原子更新尝试拿锁\n        if (compareAndSetState(0, 1)) {\n            owner = current;\n            return true;\n        }\n    // 已经有人持有锁，判断是否是自己重入\n    } else if (current == owner) {\n        setState(c + 1);\n        return true;\n    }\n    // 尝试拿锁失败\n    return false;\n}\n```\n\n### CountDownLatch\n倒计时器\n\n在多线程协作完成任务时，通常需要主线程等待其他线程运行完成后继续往下执行。这时通常可以使用`Thread`的`join`方法，也可以使用`CountDownLatch`\n\n先从`CountDownLatch`的构造方法看起\n```java\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n```\n其核心的内部对象就是`sync`，是一个继承了AQS的静态final私有类，它控制着倒计时器的同步逻辑\n\n`CountDownLatch`的其他方法如下\n```java\n// 阻塞等待，直到当前CountDownLatch的计数变为0\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n// 阻塞等待，直到当前CountDownLatch的计数变为0；或者等待时间超时\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n\n// 减小计数，如果计数为0，就释放所有调用await()阻塞的线程\npublic void countDown() {\n    sync.releaseShared(1);\n}\n\n// 返回当前计数\npublic long getCount() {\n    return sync.getCount();\n}\n```\n\n示例代码如下：\n```java\npublic class CountDownLatchDemo {\n    private static CountDownLatch startSignal = new CountDownLatch(1);\n    //用来表示裁判员需要维护的是6个运动员\n    private static CountDownLatch endSignal = new CountDownLatch(6);\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(6);\n        for (int i = 0; i < 6; i++) {\n            executorService.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 运动员等待裁判员响哨！！！\");\n                    // 阻塞，等待主线程中的startSignal.countDown()，然后开始执行\n                    startSignal.await();\n                    System.out.println(Thread.currentThread().getName() + \"正在全力冲刺\");\n                    // 计数--\n                    endSignal.countDown();\n                    System.out.println(Thread.currentThread().getName() + \"  到达终点\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        System.out.println(\"裁判员发号施令啦！！！\");\n        // 计数--，线程池开始同时执行\n        startSignal.countDown();\n        // 阻塞，等待所有线程中的endSignal.countDown()，计数为0后开始执行\n        endSignal.await();\n        System.out.println(\"所有运动员到达终点，比赛结束！\");\n        executorService.shutdown();\n    }\n}\n```\n\n### CyclicBarrier\n循环栅栏\n\n`CyclicBarrier`与`CountDownLatch`功能类似，都有等待计数的功能，但功能比`CountDownLatch`更加强大。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cyclicbarrier_count.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        CyclicBarrier示意图\n    </div>\n</center>\n\n\n`CyclicBarrier`的主要方法如下所示：\n```java\n// 构造方法，指定线程均到达以后，执行barrierAction定义的操作（然后各线程再继续向下执行）\npublic CyclicBarrier(int parties, Runnable barrierAction)\n\n// 等到所有的线程都到达指定的临界点\nawait() throws InterruptedException, BrokenBarrierException\n\n// 与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止\nawait(long timeout, TimeUnit unit) throws InterruptedException,\nBrokenBarrierException, TimeoutException\n\n// 获取当前有多少个线程阻塞等待在临界点上\nint getNumberWaiting()\n\n// 用于查询阻塞等待的线程是否被中断\nboolean isBroken()\n\n// 将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException\nvoid reset()\n```\n\n示例代码：\n```java\npublic class CyclicBarrierDemo {\n    // 指定必须有3个运动员到达才行\n    private static CyclicBarrier barrier = new CyclicBarrier(3, () -> {\n        System.out.println(\"所有运动员入场，裁判员一声令下！！！！！\");\n    });\n\n    public static void main(String[] args) {\n        System.out.println(\"运动员准备进场，全场欢呼............\");\n        ExecutorService service = Executors.newFixedThreadPool(3);\n        for (int i = 0; i <= 3; i++) {\n            service.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + \" 运动员，进场\");\n                    // 等指定数量的线程都到了之后再一起往下执行\n                    barrier.await();\n                    System.out.println(Thread.currentThread().getName() + \"  运动员出发\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }\n}\n```\n\n输出结果：\n```sh\n运动员准备进场，全场欢呼............\npool-1-thread-2 运动员，进场\npool-1-thread-1 运动员，进场\npool-1-thread-3 运动员，进场\n所有运动员入场，裁判员一声令下！！！！！\npool-1-thread-1  运动员出发\npool-1-thread-3  运动员出发\npool-1-thread-2  运动员出发\n```\n\n#### CountDownLatch与CyclicBarrier的比较\n`CountDownLatch`与`CyclicBarrier`都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n+ `CountDownLatch`一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而`CyclicBarrier`一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；\n+ 调用`CountDownLatch`的`countDown`方法后，当前线程并不会阻塞，会继续往下执行；而调用`CyclicBarrier`的`await`方法，会阻塞当前线程，直到`CyclicBarrier`指定的线程全部都到达了指定点的时候，才能继续往下执行；\n+ `CountDownLatch` 方法比较少，操作比较简单，而`CyclicBarrier`提供的方法更多，比如能够通过`getNumberWaiting()`，`isBroken()`这些方法获取当前多个线程的状态，并且`CyclicBarrier`的构造方法可以传入`barrierAction`，指定当所有线程都到达时执行的业务功能；\n+ `CountDownLatch` 是不能复用的，而`CyclicBarrier`是可以复用的。\n\n### Semaphore\n`Semaphore`可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。与`Lock`相似但不同，`Semaphore`支持同时有多个线程获取到资格。\n\n`Semaphore`可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。\n\n`Semaphore`的内部也保存有通过继承AQS实现的私有静态final类，负责实现同步的逻辑\n\n`Semaphore`的主要方法如下：\n```java\n// 获取许可，如果无法获取到，则阻塞等待直至能够获取为止\nvoid acquire() throws InterruptedException\n// 同acquire方法功能基本一样，只不过该方法可以一次获取多个许可\nvoid acquire(int permits) throws InterruptedException\n// 释放许可\nvoid release()\n// 释放指定个数的许可\nvoid release(int permits)\n// 尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false\nboolean tryAcquire()\n// 与tryAcquire方法一致，只不过这里可以指定获取多个许可\nboolean tryAcquire(int permits)\n// 尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false\nboolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n// 与上一个方法一致，只不过这里能够获取多个许可\nboolean tryAcquire(int permits, long timeout, TimeUnit unit)\n// 返回当前可用的许可证个数\nint availablePermits()\n// 返回正在等待获取许可证的线程数\nint getQueueLength()\n// 是否有线程正在等待获取许可证\nboolean hasQueuedThreads()\n// 获取所有正在等待许可的线程集合\nCollection<Thread> getQueuedThreads()\n```\n\n`Semaphore`也支持公平性和非公平性，默认是非公平性，这样吞吐量更高\n\n示例代码：\n```java\npublic class SemaphoreDemo {\n\n    //表示老师只有10支笔\n    private static Semaphore semaphore = new Semaphore(5);\n\n    public static void main(String[] args) {\n        //表示50个学生\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 10; i++) {\n            service.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  同学准备获取笔......\");\n                    // 尝试获取资源，会阻塞\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  同学获取到笔\");\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  填写表格ing.....\");\n                    TimeUnit.SECONDS.sleep(3);\n                    // 释放资源\n                    semaphore.release();\n                    System.out.println(Thread.currentThread().getName() \n                                        + \"  填写完表格，归还了笔！\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        service.shutdown();\n    }\n}\n\n```\n\n### Exchanger\n`Exchanger`是一个用于线程间协作的工具类（模板类）。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据的方法就是`exchange`方法\n\n主要方法如下：\n```java\n// 当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点\n// 将数据交换给另一个线程，同时返回获取的数据\nV exchange(V x) throws InterruptedException\n// 同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间\nV exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutException\n```\n\n示例代码：\n```java\npublic class ExchangerDemo {\n    private static Exchanger<String> exchanger = new Exchanger();\n    public static void main(String[] args) {\n        //代表男生和女生\n        ExecutorService service = Executors.newFixedThreadPool(2);\n        service.execute(() -> {\n            try {\n                //男生对女生说的话\n                String girl = exchanger.exchange(\"我其实暗恋你很久了......\");\n                System.out.println(\"女孩儿说：\" + girl);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        service.execute(() -> {\n            try {\n                System.out.println(\"女生慢慢的从教室你走出来......\");\n                TimeUnit.SECONDS.sleep(3);\n                //男生对女生说的话\n                String boy = exchanger.exchange(\"我也很喜欢你......\");\n                System.out.println(\"男孩儿说：\" + boy);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n}\n```\n\n输出结果：\n```sh\n女生慢慢的从教室你走出来......\n女孩儿说：我也很喜欢你......\n男孩儿说：我其实暗恋你很久了......\n```\n\n## 参考\n由于这部分的内容相对复杂，且需要深入到源码理解，才能比较透彻，因此参考了别人的笔记\n[深入理解Java线程池：ThreadPoolExecutor](http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95)  \n[Github: Java-concurrency](https://github.com/CL0610/Java-concurrency)  \n","slug":"线程池与并发工具","published":1,"updated":"2022-09-21T07:30:46.940Z","_id":"cl1hkg2as0000vctpe4xk5kbr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>使用线程池的好处：</p>\n<ul>\n<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>\n<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>\n<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>\n</ul>\n<p>线程池的类关系如图所示：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/ScheduledThreadPoolExecutor.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程池的类关系图\n    </div>\n</center>\n\n<h3 id=\"Executor框架接口\"><a href=\"#Executor框架接口\" class=\"headerlink\" title=\"Executor框架接口\"></a>Executor框架接口</h3><p>Executor框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架，目的是提供一种机制，<strong>将“任务提交”与“任务如何运行”分离开来</strong>。</p>\n<p>J.U.C中有三个Executor接口：</p>\n<ul>\n<li><strong>Executor</strong>：一个运行新任务的简单接口；</li>\n<li><strong>ExecutorService</strong>：扩展了<code>Executor</code>接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</li>\n<li><strong>ScheduledExecutorService</strong>：扩展了<code>ExecutorService</code>接口。支持<code>Future</code>和定期执行任务。</li>\n</ul>\n<h4 id=\"Executor接口\"><a href=\"#Executor接口\" class=\"headerlink\" title=\"Executor接口\"></a>Executor接口</h4><p>Executor接口只有一个<code>execute</code>方法，用来替代创建或启动线程的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如，使用<code>Thread</code>来创建并启动线程的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread t = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure></p>\n<p>而使用<code>Executor</code>来启动线程就是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread t = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">executor.execute(t);</span><br></pre></td></tr></table></figure></p>\n<p>至于<code>execute()</code>方法如何执行代码，则要结合实际的线程池实现考虑</p>\n<h4 id=\"ExecutorService接口\"><a href=\"#ExecutorService接口\" class=\"headerlink\" title=\"ExecutorService接口\"></a>ExecutorService接口</h4><p><code>ExecutorService</code>接口继承自<code>Executor</code>接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成<code>Future</code>的方法。增加了<code>shutDown()</code>，<code>shutDownNow()</code>，<code>invokeAll()</code>，<code>invokeAny()</code>和<code>submit()</code>等方法。如果需要支持即时关闭，也就是<code>shutDownNow()</code>方法，则任务需要正确处理中断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括哪些还未开始执行的任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 等待ExecutorService到达终止状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"><span class=\"comment\">// 提交任务，通过返回的Future跟踪任务的运行状态</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 执行批量任务</span></span><br><span class=\"line\">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"><span class=\"comment\">// 执行批量任务中的任意一个</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure>\n<p>在<code>ExecutorService</code>关闭后提交的任务将由“拒绝执行处理器(<code>RejectExecutionHandler</code>)”来处理，它会抛弃任务，或者使得<code>execute</code>方法抛出一个未检查的<code>RejectedExecutionException</code>。</p>\n<h4 id=\"ScheduledExecutorService接口\"><a href=\"#ScheduledExecutorService接口\" class=\"headerlink\" title=\"ScheduledExecutorService接口\"></a>ScheduledExecutorService接口</h4><p><code>ScheduledExecutorService</code>扩展<code>ExecutorService</code>接口并增加了<code>schedule</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并执行在给定延迟后启用的一次性操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class=\"line\">                                    <span class=\"keyword\">long</span> delay, TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 创建并执行在给定延迟后启用的 ScheduledFuture</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;V&gt; <span class=\"function\">ScheduledFuture&lt;V&gt; <span class=\"title\">schedule</span><span class=\"params\">(Callable&lt;V&gt; callable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        <span class=\"keyword\">long</span> delay, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>调用<code>schedule</code>方法可以在指定的延时后执行一个<code>Runnable</code>或者<code>Callable</code>任务。<code>ScheduledExecutorService</code>接口还定义了按照指定时间间隔定期执行任务的<code>scheduleAtFixedRate()</code>方法和<code>scheduleWithFixedDelay()</code>方法。</p>\n<h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>继承自<code>AbstractExecutorService</code>，也实现了<code>ExecutorService</code>接口。<code>ThreadPoolExecutor</code>构造方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> :</span><br><span class=\"line\">            AccessController.getContext();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造方法中的字段含义如下：</p>\n<ul>\n<li><strong>corePoolSize</strong>：核心线程数量，当有新任务在<code>execute()</code>方法提交时，会执行以下判断：<ul>\n<li>如果运行的线程少于<code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li>\n<li>如果线程池中的线程数量大于等于<code>corePoolSize</code>且小于<code>maximumPoolSize</code>，则只有当<code>workQueue</code>满时才创建新的线程去处理任务；</li>\n<li>如果设置的<code>corePoolSize</code>和<code>maximumPoolSize</code>相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若<code>workQueue</code>未满，则将请求放入<code>workQueue</code>中，等待有空闲的线程去从<code>workQueue</code>中取任务并处理；</li>\n<li>如果运行的线程数量大于等于<code>maximumPoolSize</code>，这时如果<code>workQueue</code>已经满了，则通过<code>handler</code>所指定的策略来处理任务；<br>所以任务提交时，判断的顺序为 <code>corePoolSize</code> –&gt; <code>workQueue</code> –&gt; <code>maximumPoolSize</code>。</li>\n</ul>\n</li>\n<li><strong>maximumPoolSize</strong>：最大线程数量；</li>\n<li><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于<code>corePoolSize</code>的时候，把该任务封装成一个Worker对象放入等待队列；</li>\n<li><strong>workQueue</strong>：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul>\n<li><strong>直接切换</strong>：这种方式常用的队列是<code>SynchronousQueue</code>，但现在还没有研究过该队列，这里暂时还没法介绍；</li>\n<li><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列<code>LinkedBlockingQueue</code>。如果使用这种方式，那么线程池中能够创建的最大线程数就是<code>corePoolSize</code>，而<code>maximumPoolSize</code>就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是<code>RUNNING</code>状态时，这时一个新的任务提交就会放入等待队列中。</li>\n<li><strong>使用有界队列</strong>：一般使用<code>ArrayBlockingQueue</code>。使用该方式可以将线程池的最大线程数量限制为<code>maximumPoolSize</code>，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。<ul>\n<li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>\n<li>如果提交的任务经常发生阻塞，那么可以考虑通过调用<code>setMaximumPoolSize()</code> 方法来重新设定线程池的容量。</li>\n<li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于<code>corePoolSize</code>的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了<code>keepAliveTime</code>；</li>\n<li><strong>threadFactory</strong>：它是<code>ThreadFactory</code>类型的变量，用来创建新线程。默认使用<code>Executors.defaultThreadFactory()</code>来创建线程。使用默认的<code>ThreadFactory</code>来创建线程时，会使新创建的线程具有相同的<code>NORM_PRIORITY</code>优先级并且是非守护线程，同时也设置了线程的名称。</li>\n<li><strong>handler</strong>：它是<code>RejectedExecutionHandler</code>类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul>\n<li>AbortPolicy：直接抛出异常，这是默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h4><p><code>execute()</code>方法用来提交任务，执行逻辑如下图：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_pool_execute.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        execute()执行逻辑\n    </div>\n</center>\n\n<ul>\n<li>如果当前运行的线程少于<code>corePoolSize</code>，则会创建新的线程来执行新的任务；</li>\n<li>如果运行的线程个数等于或者大于<code>corePoolSize</code>，则会将提交的任务存放到阻塞队列<code>workQueue</code>中；</li>\n<li>如果当前<code>workQueue</code>队列已满的话，则会创建新的线程来执行任务；</li>\n<li>如果线程个数已经超过了<code>maximumPoolSize</code>，则会使用饱和策略<code>RejectedExecutionHandler</code>来进行处理。</li>\n</ul>\n<h3 id=\"ScheduledThreadPoolExecutor\"><a href=\"#ScheduledThreadPoolExecutor\" class=\"headerlink\" title=\"ScheduledThreadPoolExecutor\"></a>ScheduledThreadPoolExecutor</h3><p><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>，拥有<code>execute()</code>和 <code>submit()</code>提交异步任务的基础功能；同时实现了<code>ScheduledExecutorService</code>接口，拥有延时执行任务和周期执行任务的功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 达到给定的延时时间后，执行任务。这里传入的是实现Runnable接口的任务，</span></span><br><span class=\"line\"><span class=\"comment\">// 因此通过ScheduledFuture.get()获取结果为null</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class=\"line\">                                    <span class=\"keyword\">long</span> delay, TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 达到给定的延时时间后，执行任务。这里传入的是实现Callable接口的任务，</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，返回的是任务的最终计算结果</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;V&gt; <span class=\"function\">ScheduledFuture&lt;V&gt; <span class=\"title\">schedule</span><span class=\"params\">(Callable&lt;V&gt; callable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        <span class=\"keyword\">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 是以上一个任务开始的时间计时，period时间过去后，</span></span><br><span class=\"line\"><span class=\"comment\">// 检测上一个任务是否执行完毕，如果上一个任务执行完毕，</span></span><br><span class=\"line\"><span class=\"comment\">// 则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> period,</span><br><span class=\"line\">                                                TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 当达到延时时间initialDelay后，任务开始执行。上一个任务执行结束后到下一次</span></span><br><span class=\"line\"><span class=\"comment\">// 任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> delay,</span><br><span class=\"line\">                                                TimeUnit unit);</span><br></pre></td></tr></table></figure>\n<p><code>ScheduledThreadPoolExecutor</code>中为了实现可延时执行任务和周期性执行任务的特性，任务会被转换成<code>ScheduledFutureTask</code>类，该类继承了<code>FutureTask</code>，并重写了<code>run</code>方法。</p>\n<p><code>ScheduledThreadPoolExecutor</code>也两个重要的内部类：<code>DelayedWorkQueue</code>和<code>ScheduledFutureTask</code>。<code>DelayedWorkQueue</code>实现了<code>BlockingQueue</code>接口，也就是一个阻塞队列；<code>ScheduledFutureTask</code>则是继承了<code>FutureTask</code>类，也表示该类用于返回异步任务的结果。</p>\n<ul>\n<li><code>ScheduledFutureTask</code>最主要的功能是根据当前任务是否具有周期性，对异步任务进行进一步封装。如果不是周期性任务（调用<code>schedule</code>方法）则直接通过<code>run()</code>执行，若是周期性任务，则需要在每一次执行完后，重设下一次执行的时间，然后将下一次任务继续放入到阻塞队列中。</li>\n<li><code>DelayedWorkQueue</code>是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行。</li>\n</ul>\n<h3 id=\"FutureTask基本操作\"><a href=\"#FutureTask基本操作\" class=\"headerlink\" title=\"FutureTask基本操作\"></a>FutureTask基本操作</h3><p>在<code>Executors</code>框架体系中，<code>FutureTask</code>用来表示可获取结果的异步任务。<code>FutureTask</code>实现了<code>Future</code>接口，<code>FutureTask</code>提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法。通过<code>get()</code>方法来获取异步任务的结果，但是会阻塞当前线程直至异步任务执行结束。一旦任务执行结束，任务不能重新启动或取消，除非调用<code>runAndReset()</code>方法。</p>\n<p><code>FutureTask</code>的3种状态：</p>\n<ul>\n<li><strong>未启动</strong>：<code>FutureTask.run()</code>方法还没有被执行之前，<code>FutureTask</code>处于未启动状态。当创建一个 <code>FutureTask</code>，还没有执行 <code>FutureTask.run()</code>方法之前，<code>FutureTask</code>处于未启动状态。</li>\n<li><strong>已启动</strong>：<code>FutureTask.run()</code>方法被执行的过程中，<code>FutureTask</code>处于已启动状态。</li>\n<li><strong>已完成</strong>：<code>FutureTask.run()</code>方法执行结束，或者调用<code>FutureTask.cancel(...)</code>方法取消任务，或者在执行任务期间抛出异常，这些情况都称之为<code>FutureTask</code>的已完成状态。</li>\n</ul>\n<p>主要方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当 FutureTask 处于未启动或已启动状态时，执行 FutureTask.get()方法将导致调用线程阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 FutureTask 处于已完成状态，调用 FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常</span></span><br><span class=\"line\">get()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与get()相同，但是阻塞时是有时限的等待</span></span><br><span class=\"line\">get(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当 FutureTask 处于未启动状态时，执行 FutureTask.cancel()方法将此任务永远不会执行；</span></span><br><span class=\"line\"><span class=\"comment\">// 当 FutureTask 处于已启动状态时，执行 FutureTask.cancel(true)方法将以中断线程的方式来阻止任务</span></span><br><span class=\"line\"><span class=\"comment\">//    继续进行，如果执行 FutureTask.cancel(false)将不会对正在执行任务的线程有任何影响；</span></span><br><span class=\"line\"><span class=\"comment\">// 当FutureTask处于已完成状态时，执行 FutureTask.cancel(...)方法将返回 false。</span></span><br><span class=\"line\">cancel()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 来自RunnableFuture接口，运行任务</span></span><br><span class=\"line\">run()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 想执行多次会调用</span></span><br><span class=\"line\">runAndReset()</span><br></pre></td></tr></table></figure></p>\n<p><code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。因此，<code>FutureTask</code>可以出现在任何替代<code>Runnable</code>的地方，也可以被线程直接调用<code>FutureTask.run()</code>。</p>\n<p><code>Future</code>本身适用于解决多线程执行若干个任务，每个任务只需只需一次的情况，用<code>Future</code>可避免不必要的多次执行。</p>\n<p>最后放一个线程池的示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureRenderer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService = <span class=\"keyword\">new</span> ThreadPoolExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">renderPage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class=\"line\">        Callable&lt;List&lt;ImageData&gt;&gt; task =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Callable&lt;List&lt;ImageData&gt;&gt; () &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ImageData&gt; <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    List&lt;ImageData&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (ImageInfo imageInfo : imageInfos) &#123;</span><br><span class=\"line\">                        result.add(imageInfo.downloadImage());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class=\"line\">        renderText(source);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            List&lt;ImageData&gt; imageData = future.get();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ImageData data : imageData) &#123;</span><br><span class=\"line\">                renderImage(data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 重新设置线程的中断状态</span></span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">            <span class=\"comment\">// 由于不需要结果，因此取消任务</span></span><br><span class=\"line\">            future.cancel(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> launderThrowable(e.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>renderPage()</code>方法负责渲染一个页面，其中页面可分为文字和图片两部分，图片下载时间较慢，因此通过多线程并行的方式加快速度。当然这个程序还能继续做并行，这里仅为了演示，不再深入，详见书本<code>6.3.3</code>节。</p>\n<h2 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h2><p>这里主要记录一下书中提到的几种并发工具</p>\n<h3 id=\"AbstractQueuedSynchronizer-AQS\"><a href=\"#AbstractQueuedSynchronizer-AQS\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer(AQS)\"></a>AbstractQueuedSynchronizer(AQS)</h3><p>AQS是实现<code>CountDownLatch</code>、<code>Semaphore</code>等同步工具的基础，它负责管理同步器中的状态。</p>\n<p>它管理了一个整数状态信息，可以通过<code>getState</code>、<code>setState</code>以及<code>compareAndSetState</code>等<code>protected</code>类型的方法进行操作。这个整数可以表示任何信息，如在<code>ReentrantLock</code>中表示所有者线程已经重复获取该锁的次数；<code>Semaphore</code>用它来表示剩余的许可数量；<code>FutureTask</code>用它来表示任务的状态，等等</p>\n<p>如下代码给出了AQS中获取操作与释放操作的形式。根据同步器的不同，获取操作可以是一种独占操作（如<code>ReentrantLock</code>），也可以是一个非独占操作（如<code>Semaphore</code>和<code>CountDownLatch</code>）。</p>\n<p>一个获取操作包括两部分。首先，同步器判断当前状态是否允许获得操作，如果是，则允许线程执行，否则获取操作将阻塞或失败。<br>其次就是更新同步器的状态，获取同步器的某个线程可能会对其他线程能否也获取该同步器造成影响。例如，当获取一个锁后，锁的状态将从“未被持有”变成“已被持有”，而从<code>Semaphore</code>中获取一个许可后，将把剩余许可的数量减一。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (当前状态不允许获取操作) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (需要阻塞获取请求) &#123;</span><br><span class=\"line\">            如果当前线程不在队列中，则将其插入队列</span><br><span class=\"line\">            阻塞当前线程</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            返回失败</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    可能更新同步器的状态</span><br><span class=\"line\">    如果线程位于队列中，则将其移出队列</span><br><span class=\"line\">    返回成功</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    更新同步器的状态</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (新的状态允许某个被阻塞的线程获取成功) &#123;</span><br><span class=\"line\">        解除队列中一个或多个线程的阻塞状态</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>利用AQS实现闭锁的示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OneShotLatch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123; sync.releaseShared(<span class=\"number\">0</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        sync.acquireSharedInterruptibly(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignored)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果闭锁是开的(state == 1)，那么这个操作将成功，否则失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (getState() == <span class=\"number\">1</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignored)</span> </span>&#123;</span><br><span class=\"line\">            setState(<span class=\"number\">1</span>);    <span class=\"comment\">// 现在打开闭锁</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;    <span class=\"comment\">// 现在其他的线程可以获取该闭锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p><code>ReentrantLock</code>只支持独占的获取操作，因此它实现了<code>tryAcquire</code>、<code>tryRelease</code>和<code>isHeldExclusively</code>。</p>\n<p><code>ReentrantLock</code>将同步状态用于保存锁获取操作的次数，并且还维护一个<code>owner</code>变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要放锁的时候，才会修改这个变量。在<code>tryRelease</code>中检查<code>owner</code>域，从而确保当前线程在执行unlock操作之前已经获取到了锁；在<code>tryAcquire</code>中将使用这个域来区分获取操作是重入的还是竞争的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> ignored)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">// 无人持有锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 利用原子更新尝试拿锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            owner = current;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 已经有人持有锁，判断是否是自己重入</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == owner) &#123;</span><br><span class=\"line\">        setState(c + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试拿锁失败</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h3><p>倒计时器</p>\n<p>在多线程协作完成任务时，通常需要主线程等待其他线程运行完成后继续往下执行。这时通常可以使用<code>Thread</code>的<code>join</code>方法，也可以使用<code>CountDownLatch</code></p>\n<p>先从<code>CountDownLatch</code>的构造方法看起<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"count &lt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sync = <span class=\"keyword\">new</span> Sync(count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其核心的内部对象就是<code>sync</code>，是一个继承了AQS的静态final私有类，它控制着倒计时器的同步逻辑</p>\n<p><code>CountDownLatch</code>的其他方法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阻塞等待，直到当前CountDownLatch的计数变为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阻塞等待，直到当前CountDownLatch的计数变为0；或者等待时间超时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.tryAcquireSharedNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 减小计数，如果计数为0，就释放所有调用await()阻塞的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回当前计数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.getCount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>示例代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CountDownLatch startSignal = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//用来表示裁判员需要维护的是6个运动员</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CountDownLatch endSignal = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" 运动员等待裁判员响哨！！！\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 阻塞，等待主线程中的startSignal.countDown()，然后开始执行</span></span><br><span class=\"line\">                    startSignal.await();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"正在全力冲刺\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 计数--</span></span><br><span class=\"line\">                    endSignal.countDown();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"  到达终点\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"裁判员发号施令啦！！！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 计数--，线程池开始同时执行</span></span><br><span class=\"line\">        startSignal.countDown();</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞，等待所有线程中的endSignal.countDown()，计数为0后开始执行</span></span><br><span class=\"line\">        endSignal.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"所有运动员到达终点，比赛结束！\"</span>);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h3><p>循环栅栏</p>\n<p><code>CyclicBarrier</code>与<code>CountDownLatch</code>功能类似，都有等待计数的功能，但功能比<code>CountDownLatch</code>更加强大。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cyclicbarrier_count.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        CyclicBarrier示意图\n    </div>\n</center>\n\n\n<p><code>CyclicBarrier</code>的主要方法如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法，指定线程均到达以后，执行barrierAction定义的操作（然后各线程再继续向下执行）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CyclicBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> parties, Runnable barrierAction)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 等到所有的线程都到达指定的临界点</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException,</span></span><br><span class=\"line\"><span class=\"function\">BrokenBarrierException, TimeoutException</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 获取当前有多少个线程阻塞等待在临界点上</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNumberWaiting</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 用于查询阻塞等待的线程是否被中断</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isBroken</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure></p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指定必须有3个运动员到达才行</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier barrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">3</span>, () -&gt; &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"所有运动员入场，裁判员一声令下！！！！！\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"运动员准备进场，全场欢呼............\"</span>);</span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            service.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" 运动员，进场\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 等指定数量的线程都到了之后再一起往下执行</span></span><br><span class=\"line\">                    barrier.await();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"  运动员出发\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运动员准备进场，全场欢呼............</span><br><span class=\"line\">pool-1-thread-2 运动员，进场</span><br><span class=\"line\">pool-1-thread-1 运动员，进场</span><br><span class=\"line\">pool-1-thread-3 运动员，进场</span><br><span class=\"line\">所有运动员入场，裁判员一声令下！！！！！</span><br><span class=\"line\">pool-1-thread-1  运动员出发</span><br><span class=\"line\">pool-1-thread-3  运动员出发</span><br><span class=\"line\">pool-1-thread-2  运动员出发</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"CountDownLatch与CyclicBarrier的比较\"><a href=\"#CountDownLatch与CyclicBarrier的比较\" class=\"headerlink\" title=\"CountDownLatch与CyclicBarrier的比较\"></a>CountDownLatch与CyclicBarrier的比较</h4><p><code>CountDownLatch</code>与<code>CyclicBarrier</code>都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>\n<ul>\n<li><code>CountDownLatch</code>一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而<code>CyclicBarrier</code>一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li>\n<li>调用<code>CountDownLatch</code>的<code>countDown</code>方法后，当前线程并不会阻塞，会继续往下执行；而调用<code>CyclicBarrier</code>的<code>await</code>方法，会阻塞当前线程，直到<code>CyclicBarrier</code>指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>\n<li><code>CountDownLatch</code> 方法比较少，操作比较简单，而<code>CyclicBarrier</code>提供的方法更多，比如能够通过<code>getNumberWaiting()</code>，<code>isBroken()</code>这些方法获取当前多个线程的状态，并且<code>CyclicBarrier</code>的构造方法可以传入<code>barrierAction</code>，指定当所有线程都到达时执行的业务功能；</li>\n<li><code>CountDownLatch</code> 是不能复用的，而<code>CyclicBarrier</code>是可以复用的。</li>\n</ul>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><code>Semaphore</code>可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。与<code>Lock</code>相似但不同，<code>Semaphore</code>支持同时有多个线程获取到资格。</p>\n<p><code>Semaphore</code>可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。</p>\n<p><code>Semaphore</code>的内部也保存有通过继承AQS实现的私有静态final类，负责实现同步的逻辑</p>\n<p><code>Semaphore</code>的主要方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取许可，如果无法获取到，则阻塞等待直至能够获取为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 同acquire方法功能基本一样，只不过该方法可以一次获取多个许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 释放许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 释放指定个数的许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 与tryAcquire方法一致，只不过这里可以指定获取多个许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 与上一个方法一致，只不过这里能够获取多个许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 返回当前可用的许可证个数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">availablePermits</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 返回正在等待获取许可证的线程数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getQueueLength</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 是否有线程正在等待获取许可证</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedThreads</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 获取所有正在等待许可的线程集合</span></span></span><br><span class=\"line\"><span class=\"function\">Collection&lt;Thread&gt; <span class=\"title\">getQueuedThreads</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Semaphore</code>也支持公平性和非公平性，默认是非公平性，这样吞吐量更高</p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//表示老师只有10支笔</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//表示50个学生</span></span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            service.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  同学准备获取笔......\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 尝试获取资源，会阻塞</span></span><br><span class=\"line\">                    semaphore.acquire();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  同学获取到笔\"</span>);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  填写表格ing.....\"</span>);</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">                    semaphore.release();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  填写完表格，归还了笔！\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        service.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h3><p><code>Exchanger</code>是一个用于线程间协作的工具类（模板类）。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据的方法就是<code>exchange</code>方法</p>\n<p>主要方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点</span></span><br><span class=\"line\"><span class=\"comment\">// 将数据交换给另一个线程，同时返回获取的数据</span></span><br><span class=\"line\"><span class=\"function\">V <span class=\"title\">exchange</span><span class=\"params\">(V x)</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间</span></span></span><br><span class=\"line\"><span class=\"function\">V <span class=\"title\">exchange</span><span class=\"params\">(V x, <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException, TimeoutException</span></span><br></pre></td></tr></table></figure></p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExchangerDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Exchanger&lt;String&gt; exchanger = <span class=\"keyword\">new</span> Exchanger();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//代表男生和女生</span></span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        service.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//男生对女生说的话</span></span><br><span class=\"line\">                String girl = exchanger.exchange(<span class=\"string\">\"我其实暗恋你很久了......\"</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"女孩儿说：\"</span> + girl);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        service.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"女生慢慢的从教室你走出来......\"</span>);</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">                <span class=\"comment\">//男生对女生说的话</span></span><br><span class=\"line\">                String boy = exchanger.exchange(<span class=\"string\">\"我也很喜欢你......\"</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"男孩儿说：\"</span> + boy);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女生慢慢的从教室你走出来......</span><br><span class=\"line\">女孩儿说：我也很喜欢你......</span><br><span class=\"line\">男孩儿说：我其实暗恋你很久了......</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>由于这部分的内容相对复杂，且需要深入到源码理解，才能比较透彻，因此参考了别人的笔记<br><a href=\"http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">深入理解Java线程池：ThreadPoolExecutor</a><br><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Github: Java-concurrency</a>  </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>疫情期间看完了《Java并发编程实战》一书，看完之后觉得有些囫囵吞枣，没有留下深刻印象，因此写点小小总结，把握一下重点知识，尽量形成认知框架中的一部分。</p>\n<p>原书的内容十分详细，也肯定写得比我好。我这里只做简单的概括，详细的还是去书里看比较好。</p>\n<h2 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h2><p>使用线程池的好处：</p>\n<ul>\n<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>\n<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>\n<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>\n</ul>\n<p>线程池的类关系如图所示：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/ScheduledThreadPoolExecutor.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        线程池的类关系图\n    </div>\n</center>\n\n<h3 id=\"Executor框架接口\"><a href=\"#Executor框架接口\" class=\"headerlink\" title=\"Executor框架接口\"></a>Executor框架接口</h3><p>Executor框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架，目的是提供一种机制，<strong>将“任务提交”与“任务如何运行”分离开来</strong>。</p>\n<p>J.U.C中有三个Executor接口：</p>\n<ul>\n<li><strong>Executor</strong>：一个运行新任务的简单接口；</li>\n<li><strong>ExecutorService</strong>：扩展了<code>Executor</code>接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</li>\n<li><strong>ScheduledExecutorService</strong>：扩展了<code>ExecutorService</code>接口。支持<code>Future</code>和定期执行任务。</li>\n</ul>\n<h4 id=\"Executor接口\"><a href=\"#Executor接口\" class=\"headerlink\" title=\"Executor接口\"></a>Executor接口</h4><p>Executor接口只有一个<code>execute</code>方法，用来替代创建或启动线程的方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如，使用<code>Thread</code>来创建并启动线程的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread t = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure></p>\n<p>而使用<code>Executor</code>来启动线程就是：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread t = <span class=\"keyword\">new</span> Thread();</span><br><span class=\"line\">executor.execute(t);</span><br></pre></td></tr></table></figure></p>\n<p>至于<code>execute()</code>方法如何执行代码，则要结合实际的线程池实现考虑</p>\n<h4 id=\"ExecutorService接口\"><a href=\"#ExecutorService接口\" class=\"headerlink\" title=\"ExecutorService接口\"></a>ExecutorService接口</h4><p><code>ExecutorService</code>接口继承自<code>Executor</code>接口，提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成<code>Future</code>的方法。增加了<code>shutDown()</code>，<code>shutDownNow()</code>，<code>invokeAll()</code>，<code>invokeAny()</code>和<code>submit()</code>等方法。如果需要支持即时关闭，也就是<code>shutDownNow()</code>方法，则任务需要正确处理中断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括哪些还未开始执行的任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务</span></span><br><span class=\"line\"><span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 等待ExecutorService到达终止状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"><span class=\"comment\">// 提交任务，通过返回的Future跟踪任务的运行状态</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 执行批量任务</span></span><br><span class=\"line\">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"><span class=\"comment\">// 执行批量任务中的任意一个</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure>\n<p>在<code>ExecutorService</code>关闭后提交的任务将由“拒绝执行处理器(<code>RejectExecutionHandler</code>)”来处理，它会抛弃任务，或者使得<code>execute</code>方法抛出一个未检查的<code>RejectedExecutionException</code>。</p>\n<h4 id=\"ScheduledExecutorService接口\"><a href=\"#ScheduledExecutorService接口\" class=\"headerlink\" title=\"ScheduledExecutorService接口\"></a>ScheduledExecutorService接口</h4><p><code>ScheduledExecutorService</code>扩展<code>ExecutorService</code>接口并增加了<code>schedule</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并执行在给定延迟后启用的一次性操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class=\"line\">                                    <span class=\"keyword\">long</span> delay, TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 创建并执行在给定延迟后启用的 ScheduledFuture</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;V&gt; <span class=\"function\">ScheduledFuture&lt;V&gt; <span class=\"title\">schedule</span><span class=\"params\">(Callable&lt;V&gt; callable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        <span class=\"keyword\">long</span> delay, TimeUnit unit)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>调用<code>schedule</code>方法可以在指定的延时后执行一个<code>Runnable</code>或者<code>Callable</code>任务。<code>ScheduledExecutorService</code>接口还定义了按照指定时间间隔定期执行任务的<code>scheduleAtFixedRate()</code>方法和<code>scheduleWithFixedDelay()</code>方法。</p>\n<h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>继承自<code>AbstractExecutorService</code>，也实现了<code>ExecutorService</code>接口。<code>ThreadPoolExecutor</code>构造方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> :</span><br><span class=\"line\">            AccessController.getContext();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>构造方法中的字段含义如下：</p>\n<ul>\n<li><strong>corePoolSize</strong>：核心线程数量，当有新任务在<code>execute()</code>方法提交时，会执行以下判断：<ul>\n<li>如果运行的线程少于<code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的；</li>\n<li>如果线程池中的线程数量大于等于<code>corePoolSize</code>且小于<code>maximumPoolSize</code>，则只有当<code>workQueue</code>满时才创建新的线程去处理任务；</li>\n<li>如果设置的<code>corePoolSize</code>和<code>maximumPoolSize</code>相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若<code>workQueue</code>未满，则将请求放入<code>workQueue</code>中，等待有空闲的线程去从<code>workQueue</code>中取任务并处理；</li>\n<li>如果运行的线程数量大于等于<code>maximumPoolSize</code>，这时如果<code>workQueue</code>已经满了，则通过<code>handler</code>所指定的策略来处理任务；<br>所以任务提交时，判断的顺序为 <code>corePoolSize</code> –&gt; <code>workQueue</code> –&gt; <code>maximumPoolSize</code>。</li>\n</ul>\n</li>\n<li><strong>maximumPoolSize</strong>：最大线程数量；</li>\n<li><strong>workQueue</strong>：等待队列，当任务提交时，如果线程池中的线程数量大于等于<code>corePoolSize</code>的时候，把该任务封装成一个Worker对象放入等待队列；</li>\n<li><strong>workQueue</strong>：保存等待执行的任务的阻塞队列，当提交一个新的任务到线程池以后, 线程池会根据当前线程池中正在运行着的线程的数量来决定对该任务的处理方式，主要有以下几种处理方式:<ul>\n<li><strong>直接切换</strong>：这种方式常用的队列是<code>SynchronousQueue</code>，但现在还没有研究过该队列，这里暂时还没法介绍；</li>\n<li><strong>使用无界队列</strong>：一般使用基于链表的阻塞队列<code>LinkedBlockingQueue</code>。如果使用这种方式，那么线程池中能够创建的最大线程数就是<code>corePoolSize</code>，而<code>maximumPoolSize</code>就不会起作用了（后面也会说到）。当线程池中所有的核心线程都是<code>RUNNING</code>状态时，这时一个新的任务提交就会放入等待队列中。</li>\n<li><strong>使用有界队列</strong>：一般使用<code>ArrayBlockingQueue</code>。使用该方式可以将线程池的最大线程数量限制为<code>maximumPoolSize</code>，这样能够降低资源的消耗，但同时这种方式也使得线程池对线程的调度变得更困难，因为线程池和队列的容量都是有限的值，所以要想使线程池处理任务的吞吐率达到一个相对合理的范围，又想使线程调度相对简单，并且还要尽可能的降低线程池对资源的消耗，就需要合理的设置这两个数量。<ul>\n<li>如果要想降低系统资源的消耗（包括CPU的使用率，操作系统资源的消耗，上下文环境切换的开销等）, 可以设置较大的队列容量和较小的线程池容量, 但这样也会降低线程处理任务的吞吐量。</li>\n<li>如果提交的任务经常发生阻塞，那么可以考虑通过调用<code>setMaximumPoolSize()</code> 方法来重新设定线程池的容量。</li>\n<li>如果队列的容量设置的较小，通常需要将线程池的容量设置大一点，这样CPU的使用率会相对的高一些。但如果线程池的容量设置的过大，则在提交的任务数量太多的情况下，并发量会增加，那么线程之间的调度就是一个要考虑的问题，因为这样反而有可能降低处理任务的吞吐量。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong>：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于<code>corePoolSize</code>的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了<code>keepAliveTime</code>；</li>\n<li><strong>threadFactory</strong>：它是<code>ThreadFactory</code>类型的变量，用来创建新线程。默认使用<code>Executors.defaultThreadFactory()</code>来创建线程。使用默认的<code>ThreadFactory</code>来创建线程时，会使新创建的线程具有相同的<code>NORM_PRIORITY</code>优先级并且是非守护线程，同时也设置了线程的名称。</li>\n<li><strong>handler</strong>：它是<code>RejectedExecutionHandler</code>类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略：<ul>\n<li>AbortPolicy：直接抛出异常，这是默认策略；</li>\n<li>CallerRunsPolicy：用调用者所在的线程来执行任务；</li>\n<li>DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li>DiscardPolicy：直接丢弃任务；</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h4><p><code>execute()</code>方法用来提交任务，执行逻辑如下图：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/thread_pool_execute.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        execute()执行逻辑\n    </div>\n</center>\n\n<ul>\n<li>如果当前运行的线程少于<code>corePoolSize</code>，则会创建新的线程来执行新的任务；</li>\n<li>如果运行的线程个数等于或者大于<code>corePoolSize</code>，则会将提交的任务存放到阻塞队列<code>workQueue</code>中；</li>\n<li>如果当前<code>workQueue</code>队列已满的话，则会创建新的线程来执行任务；</li>\n<li>如果线程个数已经超过了<code>maximumPoolSize</code>，则会使用饱和策略<code>RejectedExecutionHandler</code>来进行处理。</li>\n</ul>\n<h3 id=\"ScheduledThreadPoolExecutor\"><a href=\"#ScheduledThreadPoolExecutor\" class=\"headerlink\" title=\"ScheduledThreadPoolExecutor\"></a>ScheduledThreadPoolExecutor</h3><p><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>，拥有<code>execute()</code>和 <code>submit()</code>提交异步任务的基础功能；同时实现了<code>ScheduledExecutorService</code>接口，拥有延时执行任务和周期执行任务的功能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 达到给定的延时时间后，执行任务。这里传入的是实现Runnable接口的任务，</span></span><br><span class=\"line\"><span class=\"comment\">// 因此通过ScheduledFuture.get()获取结果为null</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class=\"line\">                                    <span class=\"keyword\">long</span> delay, TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 达到给定的延时时间后，执行任务。这里传入的是实现Callable接口的任务，</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，返回的是任务的最终计算结果</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;V&gt; <span class=\"function\">ScheduledFuture&lt;V&gt; <span class=\"title\">schedule</span><span class=\"params\">(Callable&lt;V&gt; callable,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        <span class=\"keyword\">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 是以上一个任务开始的时间计时，period时间过去后，</span></span><br><span class=\"line\"><span class=\"comment\">// 检测上一个任务是否执行完毕，如果上一个任务执行完毕，</span></span><br><span class=\"line\"><span class=\"comment\">// 则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> period,</span><br><span class=\"line\">                                                TimeUnit unit);</span><br><span class=\"line\"><span class=\"comment\">// 当达到延时时间initialDelay后，任务开始执行。上一个任务执行结束后到下一次</span></span><br><span class=\"line\"><span class=\"comment\">// 任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">                                                <span class=\"keyword\">long</span> delay,</span><br><span class=\"line\">                                                TimeUnit unit);</span><br></pre></td></tr></table></figure>\n<p><code>ScheduledThreadPoolExecutor</code>中为了实现可延时执行任务和周期性执行任务的特性，任务会被转换成<code>ScheduledFutureTask</code>类，该类继承了<code>FutureTask</code>，并重写了<code>run</code>方法。</p>\n<p><code>ScheduledThreadPoolExecutor</code>也两个重要的内部类：<code>DelayedWorkQueue</code>和<code>ScheduledFutureTask</code>。<code>DelayedWorkQueue</code>实现了<code>BlockingQueue</code>接口，也就是一个阻塞队列；<code>ScheduledFutureTask</code>则是继承了<code>FutureTask</code>类，也表示该类用于返回异步任务的结果。</p>\n<ul>\n<li><code>ScheduledFutureTask</code>最主要的功能是根据当前任务是否具有周期性，对异步任务进行进一步封装。如果不是周期性任务（调用<code>schedule</code>方法）则直接通过<code>run()</code>执行，若是周期性任务，则需要在每一次执行完后，重设下一次执行的时间，然后将下一次任务继续放入到阻塞队列中。</li>\n<li><code>DelayedWorkQueue</code>是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行。</li>\n</ul>\n<h3 id=\"FutureTask基本操作\"><a href=\"#FutureTask基本操作\" class=\"headerlink\" title=\"FutureTask基本操作\"></a>FutureTask基本操作</h3><p>在<code>Executors</code>框架体系中，<code>FutureTask</code>用来表示可获取结果的异步任务。<code>FutureTask</code>实现了<code>Future</code>接口，<code>FutureTask</code>提供了启动和取消异步任务，查询异步任务是否计算结束以及获取最终的异步任务的结果的一些常用的方法。通过<code>get()</code>方法来获取异步任务的结果，但是会阻塞当前线程直至异步任务执行结束。一旦任务执行结束，任务不能重新启动或取消，除非调用<code>runAndReset()</code>方法。</p>\n<p><code>FutureTask</code>的3种状态：</p>\n<ul>\n<li><strong>未启动</strong>：<code>FutureTask.run()</code>方法还没有被执行之前，<code>FutureTask</code>处于未启动状态。当创建一个 <code>FutureTask</code>，还没有执行 <code>FutureTask.run()</code>方法之前，<code>FutureTask</code>处于未启动状态。</li>\n<li><strong>已启动</strong>：<code>FutureTask.run()</code>方法被执行的过程中，<code>FutureTask</code>处于已启动状态。</li>\n<li><strong>已完成</strong>：<code>FutureTask.run()</code>方法执行结束，或者调用<code>FutureTask.cancel(...)</code>方法取消任务，或者在执行任务期间抛出异常，这些情况都称之为<code>FutureTask</code>的已完成状态。</li>\n</ul>\n<p>主要方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当 FutureTask 处于未启动或已启动状态时，执行 FutureTask.get()方法将导致调用线程阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 FutureTask 处于已完成状态，调用 FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常</span></span><br><span class=\"line\">get()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与get()相同，但是阻塞时是有时限的等待</span></span><br><span class=\"line\">get(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当 FutureTask 处于未启动状态时，执行 FutureTask.cancel()方法将此任务永远不会执行；</span></span><br><span class=\"line\"><span class=\"comment\">// 当 FutureTask 处于已启动状态时，执行 FutureTask.cancel(true)方法将以中断线程的方式来阻止任务</span></span><br><span class=\"line\"><span class=\"comment\">//    继续进行，如果执行 FutureTask.cancel(false)将不会对正在执行任务的线程有任何影响；</span></span><br><span class=\"line\"><span class=\"comment\">// 当FutureTask处于已完成状态时，执行 FutureTask.cancel(...)方法将返回 false。</span></span><br><span class=\"line\">cancel()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 来自RunnableFuture接口，运行任务</span></span><br><span class=\"line\">run()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 想执行多次会调用</span></span><br><span class=\"line\">runAndReset()</span><br></pre></td></tr></table></figure></p>\n<p><code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。因此，<code>FutureTask</code>可以出现在任何替代<code>Runnable</code>的地方，也可以被线程直接调用<code>FutureTask.run()</code>。</p>\n<p><code>Future</code>本身适用于解决多线程执行若干个任务，每个任务只需只需一次的情况，用<code>Future</code>可避免不必要的多次执行。</p>\n<p>最后放一个线程池的示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureRenderer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExecutorService = <span class=\"keyword\">new</span> ThreadPoolExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">renderPage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class=\"line\">        Callable&lt;List&lt;ImageData&gt;&gt; task =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Callable&lt;List&lt;ImageData&gt;&gt; () &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> List&lt;ImageData&gt; <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    List&lt;ImageData&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (ImageInfo imageInfo : imageInfos) &#123;</span><br><span class=\"line\">                        result.add(imageInfo.downloadImage());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);</span><br><span class=\"line\">        renderText(source);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            List&lt;ImageData&gt; imageData = future.get();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ImageData data : imageData) &#123;</span><br><span class=\"line\">                renderImage(data);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 重新设置线程的中断状态</span></span><br><span class=\"line\">            Thread.currentThread().interrupt();</span><br><span class=\"line\">            <span class=\"comment\">// 由于不需要结果，因此取消任务</span></span><br><span class=\"line\">            future.cancel(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> launderThrowable(e.getCause());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>renderPage()</code>方法负责渲染一个页面，其中页面可分为文字和图片两部分，图片下载时间较慢，因此通过多线程并行的方式加快速度。当然这个程序还能继续做并行，这里仅为了演示，不再深入，详见书本<code>6.3.3</code>节。</p>\n<h2 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h2><p>这里主要记录一下书中提到的几种并发工具</p>\n<h3 id=\"AbstractQueuedSynchronizer-AQS\"><a href=\"#AbstractQueuedSynchronizer-AQS\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer(AQS)\"></a>AbstractQueuedSynchronizer(AQS)</h3><p>AQS是实现<code>CountDownLatch</code>、<code>Semaphore</code>等同步工具的基础，它负责管理同步器中的状态。</p>\n<p>它管理了一个整数状态信息，可以通过<code>getState</code>、<code>setState</code>以及<code>compareAndSetState</code>等<code>protected</code>类型的方法进行操作。这个整数可以表示任何信息，如在<code>ReentrantLock</code>中表示所有者线程已经重复获取该锁的次数；<code>Semaphore</code>用它来表示剩余的许可数量；<code>FutureTask</code>用它来表示任务的状态，等等</p>\n<p>如下代码给出了AQS中获取操作与释放操作的形式。根据同步器的不同，获取操作可以是一种独占操作（如<code>ReentrantLock</code>），也可以是一个非独占操作（如<code>Semaphore</code>和<code>CountDownLatch</code>）。</p>\n<p>一个获取操作包括两部分。首先，同步器判断当前状态是否允许获得操作，如果是，则允许线程执行，否则获取操作将阻塞或失败。<br>其次就是更新同步器的状态，获取同步器的某个线程可能会对其他线程能否也获取该同步器造成影响。例如，当获取一个锁后，锁的状态将从“未被持有”变成“已被持有”，而从<code>Semaphore</code>中获取一个许可后，将把剩余许可的数量减一。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (当前状态不允许获取操作) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (需要阻塞获取请求) &#123;</span><br><span class=\"line\">            如果当前线程不在队列中，则将其插入队列</span><br><span class=\"line\">            阻塞当前线程</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            返回失败</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    可能更新同步器的状态</span><br><span class=\"line\">    如果线程位于队列中，则将其移出队列</span><br><span class=\"line\">    返回成功</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    更新同步器的状态</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (新的状态允许某个被阻塞的线程获取成功) &#123;</span><br><span class=\"line\">        解除队列中一个或多个线程的阻塞状态</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>利用AQS实现闭锁的示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OneShotLatch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123; sync.releaseShared(<span class=\"number\">0</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        sync.acquireSharedInterruptibly(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignored)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果闭锁是开的(state == 1)，那么这个操作将成功，否则失败</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (getState() == <span class=\"number\">1</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignored)</span> </span>&#123;</span><br><span class=\"line\">            setState(<span class=\"number\">1</span>);    <span class=\"comment\">// 现在打开闭锁</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;    <span class=\"comment\">// 现在其他的线程可以获取该闭锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p><code>ReentrantLock</code>只支持独占的获取操作，因此它实现了<code>tryAcquire</code>、<code>tryRelease</code>和<code>isHeldExclusively</code>。</p>\n<p><code>ReentrantLock</code>将同步状态用于保存锁获取操作的次数，并且还维护一个<code>owner</code>变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要放锁的时候，才会修改这个变量。在<code>tryRelease</code>中检查<code>owner</code>域，从而确保当前线程在执行unlock操作之前已经获取到了锁；在<code>tryAcquire</code>中将使用这个域来区分获取操作是重入的还是竞争的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> ignored)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">// 无人持有锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 利用原子更新尝试拿锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            owner = current;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 已经有人持有锁，判断是否是自己重入</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == owner) &#123;</span><br><span class=\"line\">        setState(c + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 尝试拿锁失败</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h3><p>倒计时器</p>\n<p>在多线程协作完成任务时，通常需要主线程等待其他线程运行完成后继续往下执行。这时通常可以使用<code>Thread</code>的<code>join</code>方法，也可以使用<code>CountDownLatch</code></p>\n<p>先从<code>CountDownLatch</code>的构造方法看起<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"count &lt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sync = <span class=\"keyword\">new</span> Sync(count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其核心的内部对象就是<code>sync</code>，是一个继承了AQS的静态final私有类，它控制着倒计时器的同步逻辑</p>\n<p><code>CountDownLatch</code>的其他方法如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 阻塞等待，直到当前CountDownLatch的计数变为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 阻塞等待，直到当前CountDownLatch的计数变为0；或者等待时间超时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.tryAcquireSharedNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 减小计数，如果计数为0，就释放所有调用await()阻塞的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回当前计数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.getCount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>示例代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CountDownLatch startSignal = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//用来表示裁判员需要维护的是6个运动员</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CountDownLatch endSignal = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">6</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(<span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" 运动员等待裁判员响哨！！！\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 阻塞，等待主线程中的startSignal.countDown()，然后开始执行</span></span><br><span class=\"line\">                    startSignal.await();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"正在全力冲刺\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 计数--</span></span><br><span class=\"line\">                    endSignal.countDown();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"  到达终点\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"裁判员发号施令啦！！！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 计数--，线程池开始同时执行</span></span><br><span class=\"line\">        startSignal.countDown();</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞，等待所有线程中的endSignal.countDown()，计数为0后开始执行</span></span><br><span class=\"line\">        endSignal.await();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"所有运动员到达终点，比赛结束！\"</span>);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h3><p>循环栅栏</p>\n<p><code>CyclicBarrier</code>与<code>CountDownLatch</code>功能类似，都有等待计数的功能，但功能比<code>CountDownLatch</code>更加强大。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/java/cyclicbarrier_count.jpg\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        CyclicBarrier示意图\n    </div>\n</center>\n\n\n<p><code>CyclicBarrier</code>的主要方法如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法，指定线程均到达以后，执行barrierAction定义的操作（然后各线程再继续向下执行）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CyclicBarrier</span><span class=\"params\">(<span class=\"keyword\">int</span> parties, Runnable barrierAction)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 等到所有的线程都到达指定的临界点</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException,</span></span><br><span class=\"line\"><span class=\"function\">BrokenBarrierException, TimeoutException</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 获取当前有多少个线程阻塞等待在临界点上</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getNumberWaiting</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 用于查询阻塞等待的线程是否被中断</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isBroken</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure></p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指定必须有3个运动员到达才行</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier barrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">3</span>, () -&gt; &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"所有运动员入场，裁判员一声令下！！！！！\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"运动员准备进场，全场欢呼............\"</span>);</span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">            service.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" 运动员，进场\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 等指定数量的线程都到了之后再一起往下执行</span></span><br><span class=\"line\">                    barrier.await();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"  运动员出发\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">运动员准备进场，全场欢呼............</span><br><span class=\"line\">pool-1-thread-2 运动员，进场</span><br><span class=\"line\">pool-1-thread-1 运动员，进场</span><br><span class=\"line\">pool-1-thread-3 运动员，进场</span><br><span class=\"line\">所有运动员入场，裁判员一声令下！！！！！</span><br><span class=\"line\">pool-1-thread-1  运动员出发</span><br><span class=\"line\">pool-1-thread-3  运动员出发</span><br><span class=\"line\">pool-1-thread-2  运动员出发</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"CountDownLatch与CyclicBarrier的比较\"><a href=\"#CountDownLatch与CyclicBarrier的比较\" class=\"headerlink\" title=\"CountDownLatch与CyclicBarrier的比较\"></a>CountDownLatch与CyclicBarrier的比较</h4><p><code>CountDownLatch</code>与<code>CyclicBarrier</code>都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：</p>\n<ul>\n<li><code>CountDownLatch</code>一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而<code>CyclicBarrier</code>一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li>\n<li>调用<code>CountDownLatch</code>的<code>countDown</code>方法后，当前线程并不会阻塞，会继续往下执行；而调用<code>CyclicBarrier</code>的<code>await</code>方法，会阻塞当前线程，直到<code>CyclicBarrier</code>指定的线程全部都到达了指定点的时候，才能继续往下执行；</li>\n<li><code>CountDownLatch</code> 方法比较少，操作比较简单，而<code>CyclicBarrier</code>提供的方法更多，比如能够通过<code>getNumberWaiting()</code>，<code>isBroken()</code>这些方法获取当前多个线程的状态，并且<code>CyclicBarrier</code>的构造方法可以传入<code>barrierAction</code>，指定当所有线程都到达时执行的业务功能；</li>\n<li><code>CountDownLatch</code> 是不能复用的，而<code>CyclicBarrier</code>是可以复用的。</li>\n</ul>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p><code>Semaphore</code>可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。与<code>Lock</code>相似但不同，<code>Semaphore</code>支持同时有多个线程获取到资格。</p>\n<p><code>Semaphore</code>可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。</p>\n<p><code>Semaphore</code>的内部也保存有通过继承AQS实现的私有静态final类，负责实现同步的逻辑</p>\n<p><code>Semaphore</code>的主要方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取许可，如果无法获取到，则阻塞等待直至能够获取为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 同acquire方法功能基本一样，只不过该方法可以一次获取多个许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 释放许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 释放指定个数的许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 与tryAcquire方法一致，只不过这里可以指定获取多个许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 与上一个方法一致，只不过这里能够获取多个许可</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 返回当前可用的许可证个数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">availablePermits</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 返回正在等待获取许可证的线程数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getQueueLength</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 是否有线程正在等待获取许可证</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedThreads</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 获取所有正在等待许可的线程集合</span></span></span><br><span class=\"line\"><span class=\"function\">Collection&lt;Thread&gt; <span class=\"title\">getQueuedThreads</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure></p>\n<p><code>Semaphore</code>也支持公平性和非公平性，默认是非公平性，这样吞吐量更高</p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//表示老师只有10支笔</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Semaphore semaphore = <span class=\"keyword\">new</span> Semaphore(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//表示50个学生</span></span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            service.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  同学准备获取笔......\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 尝试获取资源，会阻塞</span></span><br><span class=\"line\">                    semaphore.acquire();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  同学获取到笔\"</span>);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  填写表格ing.....\"</span>);</span><br><span class=\"line\">                    TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">                    semaphore.release();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() </span><br><span class=\"line\">                                        + <span class=\"string\">\"  填写完表格，归还了笔！\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        service.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h3><p><code>Exchanger</code>是一个用于线程间协作的工具类（模板类）。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。交换数据的方法就是<code>exchange</code>方法</p>\n<p>主要方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点</span></span><br><span class=\"line\"><span class=\"comment\">// 将数据交换给另一个线程，同时返回获取的数据</span></span><br><span class=\"line\"><span class=\"function\">V <span class=\"title\">exchange</span><span class=\"params\">(V x)</span> <span class=\"keyword\">throws</span> InterruptedException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间</span></span></span><br><span class=\"line\"><span class=\"function\">V <span class=\"title\">exchange</span><span class=\"params\">(V x, <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException, TimeoutException</span></span><br></pre></td></tr></table></figure></p>\n<p>示例代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExchangerDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Exchanger&lt;String&gt; exchanger = <span class=\"keyword\">new</span> Exchanger();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//代表男生和女生</span></span><br><span class=\"line\">        ExecutorService service = Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        service.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//男生对女生说的话</span></span><br><span class=\"line\">                String girl = exchanger.exchange(<span class=\"string\">\"我其实暗恋你很久了......\"</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"女孩儿说：\"</span> + girl);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        service.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"女生慢慢的从教室你走出来......\"</span>);</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">                <span class=\"comment\">//男生对女生说的话</span></span><br><span class=\"line\">                String boy = exchanger.exchange(<span class=\"string\">\"我也很喜欢你......\"</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"男孩儿说：\"</span> + boy);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出结果：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">女生慢慢的从教室你走出来......</span><br><span class=\"line\">女孩儿说：我也很喜欢你......</span><br><span class=\"line\">男孩儿说：我其实暗恋你很久了......</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>由于这部分的内容相对复杂，且需要深入到源码理解，才能比较透彻，因此参考了别人的笔记<br><a href=\"http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">深入理解Java线程池：ThreadPoolExecutor</a><br><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Github: Java-concurrency</a>  </p>\n"},{"title":"MyBatis","date":"2022-09-21T07:42:50.000Z","top_img":"/img/cover/mybatis.jpeg","cover":"/img/cover/mybatis.jpeg","_content":"\n# MyBatis 源码阅读\n与 ORM 框架不同，MyBatis通过将Java方法与数据库SQL语句关联起来，从另一个角度实现了Java服务对数据库的操作\n\n## 核心功能\n+ **将包含`if`等标签的复杂数据库操作语句解析为纯粹的 SQL 语句**\n+ **将数据库操作节点和映射接口中的抽象方法进行绑定，在抽象方法被调用时执行数据库操作**\n+ **将输入参数对象转化为数据库操作语句中的参数**\n+ **将数据库操作语句的返回结果转化为对象**\n\n## 文件组成\n### 全局配置文件\nMyBatis 的配置文件为一个 XML 文件，通常被命名为 `mybatis-config.xml` ，该 XML文件的根节点为 `configuration` ，根节点内可以包含的一级节点及其含义如下所示\n\n+ **properties**: 属性信息，相当于 MyBatis 的全局变量\n+ **settings**: 设置信息，通过它对 MyBatis 的功能进行调整\n+ **typeAliases**: 类型别名，在这里可以为类型设置一些简短的名字\n+ **typeHandlers**: 类型处理器，在这里可以为不同的类型设置相应的处理器\n+ **objectFactory**: 对象工厂，在这里可以指定 MyBatis 创建新对象时使用的工厂\n+ **objectWrapperFactory**: 对象包装器工厂，在这里可以指定 MyBatis 使用的对象包装器工厂\n+ **reflectorFactory**: 反射器工厂，在这里可以设置 MyBatis 的反射器工厂\n+ **plugins**: 插件，在这里可以为 MyBatis 配置插件，从而修改或扩展 MyBatis 的行为 \n+ **environments**: 环境，这里可以配置 MyBatis 运行的环境信息，如数据源信息等\n+ **databaseIdProvider**: 数据库编号，在这里可以为不同的数据库配置不同的编号，这样可以对不同类型的数据库设置不同的数据库操作语句\n+ **mappers**: 映射文件，在这里可以配置映射文件或映射接口文件的地址\n\n> **注意**：配置文件中的一级节点是有顺序要求的，这些节点必须按照上面列举 的顺序出现。在使用中可以根据实际需要选择相应的节点依次写入配置文件。\n\n示例：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n        <package name=\"com.github.yeecode.mybatisdemo\"/>\n    </typeAliases>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n                <dataSource type=\"POOLED\">\n                    <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                    <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/yeecode?serverTimezone=UTC\"/>\n                    <property name=\"username\" value=\"root\"/>\n                    <property name=\"password\" value=\"yeecode\"/>\n                </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"com/github/yeecode/mybatisdemo/UserMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n### 映射文件\n映射文件也是一个 XML 文件，用来完成Java方法与SQL语句的映射、Java对象与SQL参数的映射、SQL查询结果与Java对象的映射等\n\n映射文件的根节点为 `mapper` ，在 `mapper` 节点下可以包含的节点及其含义如下所示\n\n+ **cache**: 缓存，通过它可以对当前命名空间进行缓存配置\n+ **cache-ref**: 缓存引用，通过它可以引用其他命名空间的缓存作为当前命名空间的缓存\n+ **resultMap**: 结果映射，通过它来配置如何将 SQL 查询结果映射为对象\n+ **parameterMap**: 参数映射，通过它来配置如何将参数对象映射为 SQL参数。该节点已废弃，建议直接使用内联参数\n+ **sql**: SQL语句片段，通过它来设置可以被复用的语句片段\n+ **insert**: 插入语句\n+ **update**: 更新语句\n+ **delete**: 删除语句\n+ **select**: 查询语句\n\n示例：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper   PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.github.yeecode.mybatisdemo.UserMapper\">\n    <!-- 数据库操作节点 -->\n    <select id=\"queryUserBySchoolName\" resultType=\"com.github.yeecode.mybatisdemo.User\">\n        <!-- 数据库操作语句 -->\n        SELECT * FROM `user`\n        <if test=\"schoolName != null\">\n            WHERE schoolName = #{schoolName}\n        </if>\n    </select>\n</mapper>\n```\n\n### 映射接口文件\n映射接口文件是一个Java接口文件，并且该接口不需要实现类。通常情况下，每个映射接口文件都有一个同名的映射文件与之相对应。\n\n在映射接口文件中可以定义一些抽象方法，这些抽象方法可以分为两类：\n\n+ 第一类抽象方法与对应的**映射文件**中的数据库操作节点相对应\n+ 第二类抽象方法通过**注解声明**自身的数据库操作语句\n\n> **注意**：当整个接口文件中均为注解类抽象方法时，则该映射接口文件可以没有对应的映射文件\n\n示例：\n```java\npublic interface UserMapper {\n    // 该抽象方法对应着映射文件中的数据库操作节点\n    List<User> queryUserBySchoolName(User user);\n\n    // 该抽象方法通过注解声明自身的数据库操作语句\n    @Select(\"SELECT * FROM `user` WHERE `id`=#{id}\")\n    User queryUserById(Integer id);\n}\n```\n\n## 工作过程\n项目运行中， MyBatis 操作大致分为两个阶段：\n\n+ MyBatis初始化阶段：MyBatis启动时运行一次，完成MyBatis运行环境的**配置工作**\n+ 数据读写阶段：由数据读写操作触发，完成增删改查请求\n\n### 初始化阶段\nMyBatis的初始化在整个项目启动时开始执行，主要完成**配置文件的解析**、**数据库的连接**等操作\n\n#### 配置信息读取\n读取配置文件`mybatis-config.xml`得到`InputStream`，通过调用`SqlSessionFactoryBuilder`类的`build()`方法，生成`SqlSessionFactory`对象。\n\n演示用户代码如下：\n```java\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n\n其中`SqlSessionFactoryBuilder`类的`build()`核心方法如下，方法内创建`XMLConfigBuilder`类并调用`parse()`方法解析`mybatis-config.xml`得到`configuration`对象，也就是记录MyBatis全部配置信息的全局配置对象\n```java\npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n        return build(parser.parse());\n    } catch (Exception e) {\n        throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n        ErrorContext.instance().reset();\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n}\n\n// 上面方法中实际创建 SqlSessionFactory 实例的方法\npublic SqlSessionFactory build(Configuration config) {\n    return new DefaultSqlSessionFactory(config);\n}\n```\n\n`XMLConfigBuilder`类的`parse()`方法如下，解析过程固定，因此前文强调必须按顺序写\n```java\npublic Configuration parse() {\n    if (parsed) {\n        throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n    }\n    parsed = true;\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n}\n\n// 核心解析方法\nprivate void parseConfiguration(XNode root) {\n    try {\n        //issue #117 read properties first\n        propertiesElement(root.evalNode(\"properties\"));\n        Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n        loadCustomVfs(settings);\n        loadCustomLogImpl(settings);\n        typeAliasesElement(root.evalNode(\"typeAliases\"));\n        pluginElement(root.evalNode(\"plugins\"));\n        objectFactoryElement(root.evalNode(\"objectFactory\"));\n        objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n        reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n        settingsElement(settings);\n        // read it after objectFactory and objectWrapperFactory issue #631\n        environmentsElement(root.evalNode(\"environments\"));\n        databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n        typeHandlerElement(root.evalNode(\"typeHandlers\"));\n        mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n        throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n}\n```\n\n`DefaultSqlSessionFactory`类是`SqlSessionFactory`接口的默认实现类，其中保存了`configuration`对象\n```java\npublic class DefaultSqlSessionFactory implements SqlSessionFactory {\n\n    private final Configuration configuration;\n\n    public DefaultSqlSessionFactory(Configuration configuration) {\n        this.configuration = configuration;\n    }\n    // 核心方法之一，创建SqlSession对象\n    @Override\n    public SqlSession openSession() {\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);\n    }\n\n    ...\n}\n```\n\n> `SqlSessionFactory`对象是生产`SqlSession`对象的工厂，`SqlSession`对象是数据读写阶段的操作接口，详见下文\n\n### 数据读写阶段\n后续分析各个包的作用过程中，请**牢牢记住本节的内容，把握主线，串联细节，融合贯通**\n\n#### 获取SqlSession对象\n演示用户代码如下：\n```java\nSqlSession session = sqlSessionFactory.openSession()\n```\n\n`DefaultSqlSessionFactory`类中`openSession()`的具体实现如下：\n```java\n// 核心方法之一，创建SqlSession对象\n@Override\npublic SqlSession openSession() {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);\n}\n\nprivate SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level,\n                                            boolean autoCommit) {\n    Transaction tx = null;\n    try {\n        // 找出要使用的指定环境\n        final Environment environment = configuration.getEnvironment();\n        // 从环境中获取事务工厂\n        final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n        // 从事务工厂中生产事务\n        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n        // 创建执行器\n        final Executor executor = configuration.newExecutor(tx, execType);\n        // 创建DefaultSqlSession对象\n        return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n        closeTransaction(tx); // may have fetched a connection so lets call close()\n        throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n        ErrorContext.instance().reset();\n    }\n}\n```\n\n`DefaultSqlSession`类是`SqlSession`接口的实现类，它提供了查询、增加、更新、删除、提交、回滚等大量的方法\n\n\n> **注意**: 数据读写阶段是在进行数据读写时触发的，但并不是每次读写都会触发\n> “SqlSession session=sqlSessionFactory.openSession()”操作\n> 因为该操作得到的 DefaultSqlSession 对象可以供多次数据库读写操作复用\n\n#### 映射接口文件与映射文件的绑定\n演示代码如下，通过调用`DefaultSqlSession`类的`getMapper(Class<T>)`方法获取`UserMapper`对象\n```java\n// 找到接口对应的实现\nUserMapper userMapper = session.getMapper(UserMapper.class);\n```\n\n`DefaultSqlSession`类的`getMapper(Class<T>)`方法经过`configuration`对象转交，最终到`MapperRegistry`类中的`getMapper(Class<T>, SqlSession)`方法\n\n`MapperRegistry`类记录了配置文件中所有的映射文件路径，给定java类名后，`getMapper(Class<T>, SqlSession)`方法通过映射接口信息从所有已经解析的映射文件中找到对应的映射文件，然后根据该映射文件组建并返回接口的一个实现对象（代理对象）\n\n```java\npublic <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n    // 找出指定映射接口的代理工厂\n    final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);\n    if (mapperProxyFactory == null) {\n        throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n    }\n    try {\n        // 通过mapperProxyFactory给出对应代理器的实例\n        return mapperProxyFactory.newInstance(sqlSession);\n    } catch (Exception e) {\n        throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n    }\n}\n```\n\n#### 映射接口的代理\n上文说到，`MapperRegistry`类的`getMapper`方法返回的是一个代理对象，其创建者实际上是`MapperProxyFactory`类，对应代码如下：\n```java\n// getMapper调用的\npublic T newInstance(SqlSession sqlSession) {\n    final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n}\n\nprotected T newInstance(MapperProxy<T> mapperProxy) {\n    // 三个参数分别是：\n    // 创建代理对象的类加载器、要代理的接口、代理类的处理器（即具体的实现）。\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n}\n```\n\n代理对象本身为`MapperProxy`类，其实现了`InvocationHandler`接口，重载了`invoke()`函数，因此当出现`*Mapper`类中的方法被调用时，会通过该函数完成调用\n```java\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    try {\n        if (Object.class.equals(method.getDeclaringClass())) { // 继承自Object的方法\n            // 直接执行原有方法\n            return method.invoke(this, args);\n        } else if (method.isDefault()) { // 默认方法\n            // 执行默认方法\n            return invokeDefaultMethod(proxy, method, args);\n        }\n    } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n    }\n    // 找对对应的MapperMethod对象\n    final MapperMethod mapperMethod = cachedMapperMethod(method);\n    //** 调用MapperMethod中的execute方法\n    return mapperMethod.execute(sqlSession, args);\n}\n```\n\n这里的核心是`mapperMethod.execute(sqlSession, args)`，MyBatis将映射接口与`MapperProxy`对应，将映射接口中的抽象方法与`MapperMethod`对应，`MapperMethod`类中的`execute()`方法则根据语句类型重新调用`SqlSession`对象中的增删改查方法\n```java\npublic Object execute(SqlSession sqlSession, Object[] args) {\n    Object result;\n    switch (command.getType()) { // 根据SQL语句类型，执行不同操作\n        case INSERT: { // 如果是插入语句\n            ...\n            break;\n        }\n        case UPDATE: { // 如果是更新语句\n            ...\n            break;\n        }\n        case DELETE: { // 如果是删除语句MappedStatement\n            ...\n            break;\n        }\n        case SELECT: // 如果是查询语句\n            ...\n            break;\n        case FLUSH: // 清空缓存语句\n            ...\n            break;\n        default: // 未知语句类型，抛出异常\n            throw new BindingException(\"Unknown execution method for: \" + command.getName());\n    }\n    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n        // 查询结果为null,但返回类型为基本类型。因此返回变量无法接收查询结果，抛出异常。\n        throw new BindingException(\"Mapper method '\" + command.getName()\n            + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n    }\n    return result;\n}\n```\n\n到这里，MyBatis已经完成了**为映射接口注入实现**的过程，对映射接口中抽象方法的调用转变为了`SqlSesion`类的方法调用\n\n#### SQL 语句的查找\n`MapperMethod`类中的`execute()`方法中根据实际操作类型不同将控制权交给`SqlSession`类的不同方法\n\n以`selectList()`方法为例，具体过程都是先构建`MappedStatement`对象，然后交由`Executor`对象执行\n```java\n@Override\npublic <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n    try {\n        // 获取查询语句\n        MappedStatement ms = configuration.getMappedStatement(statement);\n        // 交由执行器进行查询\n        return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n    } catch (Exception e) {\n        throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n        ErrorContext.instance().reset();\n    }\n}\n```\n\n#### 查询结果缓存\n`Executor`是一个接口，有`BaseExecutor`类和`CachingExecutor`类两种实现，`CachingExecutor`类表示查询过程使用缓存，即可以将之前的查询结果缓存，避免一直访问数据库\n\n因此示例实际执行的代码是`CachingExecutor`类中的`query()`方法\n```java\npublic <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameterObject);\n    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);\n    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n}\n```\n\n`BoundSql`是经过层层转化后去除掉`if`、`where`等标签的 SQL 语句，而`CacheKey`是为该次查询操作计算出来的缓存键\n\n接下来，MyBatis查看当前的查询操作是否命中缓存，命中则从缓存中获取数据结果；否则通过`delegate`调用`query()`方法\n```java\n@Override\npublic <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n    throws SQLException {\n    // 获取MappedStatement对应的缓存，可能的结果有：该命名空间的缓存、共享的其它命名空间的缓存、无缓存\n    Cache cache = ms.getCache();\n    // 如果映射文件未设置<cache>或<cache-ref>则，此处cache变量为null\n    if (cache != null) { // 存在缓存\n        // 根据要求判断语句执行前是否要清除二级缓存，如果需要，清除二级缓存\n        flushCacheIfRequired(ms);\n        if (ms.isUseCache() && resultHandler == null) { // 该语句使用缓存且没有输出结果处理器\n            // 二级缓存不支持含有输出参数的CALLABLE语句，故在这里进行判断\n            ensureNoOutParams(ms, boundSql);\n            // 从缓存中读取结果\n            @SuppressWarnings(\"unchecked\")\n            List<E> list = (List<E>) tcm.getObject(cache, key);\n            if (list == null) { // 缓存中没有结果\n                // 交给被包装的执行器执行\n                list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n                // 缓存被包装执行器返回的结果\n                tcm.putObject(cache, key, list); // issue #578 and #116\n            }\n            return list;\n        }\n    }\n    // 交由被包装的实际执行器执行\n    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n}\n```\n\n#### 数据库查询\n整个流程的关键步骤如下：\n+ 在进行数据库查询前，**先查询缓存**；如果确实需要查询数据库，则数据库查询之后的结果也放入缓存中\n+ SQL语句的执行经过了层层转化，依次经过了`MappedStatement`对象、`Statement`对象和`PreparedStatement`对象，最后才得以执行\n+ 最终数据库查询得到的结果交给`ResultHandler`对象处理\n\n`delegate`调用的`query()`方法实际流向`BaseExecutor`类中的`query()`方法，其中核心方法为`queryFromDatabase()`方法\n\n`queryFromDatabase()`方法代码如下：\n```java\nprivate <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, \n    ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    List<E> list;\n    // 向缓存中增加占位符，表示正在查询\n    localCache.putObject(key, EXECUTION_PLACEHOLDER);\n    try {\n        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n    } finally {\n        // 删除占位符\n        localCache.removeObject(key);\n    }\n    // 将查询结果写入缓存\n    localCache.putObject(key, list);\n    if (ms.getStatementType() == StatementType.CALLABLE) {\n        localOutputParameterCache.putObject(key, parameter);\n    }\n    return list;\n}\n```\n\nMyBatis先在缓存中放置一个占位符，然后调用`doQuery()`方法实际执行查询操作，最后，又把缓存中的占位符替换成真正的查询结果\n\n`doQuery()`方法是`BaseExecutor`类中的抽象方法，实际运行代码如下：\n```java\npublic <E> List<E> doQuery(MappedStatement ms, Object parameterObject, RowBounds rowBounds,\n                        ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n        flushStatements();\n        Configuration configuration = ms.getConfiguration();\n        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, \n                                        rowBounds, resultHandler, boundSql);\n        Connection connection = getConnection(ms.getStatementLog());\n        stmt = handler.prepare(connection, transaction.getTimeout());\n        handler.parameterize(stmt);\n        return handler.query(stmt, resultHandler);\n    } finally {\n        closeStatement(stmt);\n    }\n}\n```\n\n`handler.query(stmt，resultHandler)`调用的是`StatementHandler`接口的抽象方法，实际调用了`PreparedStatementHandler`类的代码，如下所示：\n```java\npublic <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {\n    PreparedStatement ps = (PreparedStatement) statement;\n    // 执行真正的查询，查询完成后，结果就在ps中了\n    ps.execute();\n    // 由resultSetHandler继续处理结果\n    return resultSetHandler.handleResultSets(ps);\n}\n```\n\n查询完成之后的结果放在`PreparedStatement`对象中，交由`ResultSetHandler`对象处理\n\n#### 处理结果集\n查询得到的结果并没有直接返回，而是交给`ResultSetHandler`对象处理\n\n`ResultSetHandler`是结果集处理器接口，实现类是`DefaultResultSetHandler`，因此实际处理结果的是实现类中的`handleResultSets`方法\n\n`handleResultSets`方法将查询出来的结果被遍历后放入了列表`multipleResults`中并返回，`multipleResults`中存储的就是这次查询期望的结果`List＜User＞`\n\n`handleResultSets`方法整个调用链很长，具体如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/mybatis/handleresultsets.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        handleResultSets方法调用链\n    </div>\n</center>\n\n重点关注的是图中粗线边框标注的三个方法：\n+ **createResultObject**`(ResultSetWrapper, ResultMap, List<Class<?>>, List<Object>, String)`方法: 该方法创建了输出结果对象。在示例中，为`User`对象\n+ **applyAutomaticMappings**方法: 在自动属性映射功能开启的情况下，该方法将数据记录的值赋给输出结果对象\n+ **applyPropertyMappings**方法: 该方法按照用户的映射设置，给输出结果对象的属性赋值\n\n\n经过以上过程，MyBatis将数据库输出的记录转化为了对象列表。之后，以上方法逐级返回。\n\n最后，装载着对象列表的 `multipleResults` 被返回给`List<User> userList`变量，我们便拿到了查询结果\n```java\nList<User> userList = userMapper.queryUserBySchoolName(userParam);\n```\n\n## 项目包结构\n<center>\n    <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/mybatis/packages.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n        MyBatis 项目包结构\n    </div>\n</center>\n\n## 参考\n《MyBatis源码详解——通用源码阅读指导书》","source":"_posts/MyBatis.md","raw":"---\ntitle: MyBatis\ndate: 2022-09-21 15:42:50\ntop_img: /img/cover/mybatis.jpeg\ncover: /img/cover/mybatis.jpeg\ntags: [MyBatis, 笔记]\n---\n\n# MyBatis 源码阅读\n与 ORM 框架不同，MyBatis通过将Java方法与数据库SQL语句关联起来，从另一个角度实现了Java服务对数据库的操作\n\n## 核心功能\n+ **将包含`if`等标签的复杂数据库操作语句解析为纯粹的 SQL 语句**\n+ **将数据库操作节点和映射接口中的抽象方法进行绑定，在抽象方法被调用时执行数据库操作**\n+ **将输入参数对象转化为数据库操作语句中的参数**\n+ **将数据库操作语句的返回结果转化为对象**\n\n## 文件组成\n### 全局配置文件\nMyBatis 的配置文件为一个 XML 文件，通常被命名为 `mybatis-config.xml` ，该 XML文件的根节点为 `configuration` ，根节点内可以包含的一级节点及其含义如下所示\n\n+ **properties**: 属性信息，相当于 MyBatis 的全局变量\n+ **settings**: 设置信息，通过它对 MyBatis 的功能进行调整\n+ **typeAliases**: 类型别名，在这里可以为类型设置一些简短的名字\n+ **typeHandlers**: 类型处理器，在这里可以为不同的类型设置相应的处理器\n+ **objectFactory**: 对象工厂，在这里可以指定 MyBatis 创建新对象时使用的工厂\n+ **objectWrapperFactory**: 对象包装器工厂，在这里可以指定 MyBatis 使用的对象包装器工厂\n+ **reflectorFactory**: 反射器工厂，在这里可以设置 MyBatis 的反射器工厂\n+ **plugins**: 插件，在这里可以为 MyBatis 配置插件，从而修改或扩展 MyBatis 的行为 \n+ **environments**: 环境，这里可以配置 MyBatis 运行的环境信息，如数据源信息等\n+ **databaseIdProvider**: 数据库编号，在这里可以为不同的数据库配置不同的编号，这样可以对不同类型的数据库设置不同的数据库操作语句\n+ **mappers**: 映射文件，在这里可以配置映射文件或映射接口文件的地址\n\n> **注意**：配置文件中的一级节点是有顺序要求的，这些节点必须按照上面列举 的顺序出现。在使用中可以根据实际需要选择相应的节点依次写入配置文件。\n\n示例：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n    <typeAliases>\n        <package name=\"com.github.yeecode.mybatisdemo\"/>\n    </typeAliases>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"/>\n                <dataSource type=\"POOLED\">\n                    <property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n                    <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/yeecode?serverTimezone=UTC\"/>\n                    <property name=\"username\" value=\"root\"/>\n                    <property name=\"password\" value=\"yeecode\"/>\n                </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"com/github/yeecode/mybatisdemo/UserMapper.xml\"/>\n    </mappers>\n</configuration>\n```\n\n### 映射文件\n映射文件也是一个 XML 文件，用来完成Java方法与SQL语句的映射、Java对象与SQL参数的映射、SQL查询结果与Java对象的映射等\n\n映射文件的根节点为 `mapper` ，在 `mapper` 节点下可以包含的节点及其含义如下所示\n\n+ **cache**: 缓存，通过它可以对当前命名空间进行缓存配置\n+ **cache-ref**: 缓存引用，通过它可以引用其他命名空间的缓存作为当前命名空间的缓存\n+ **resultMap**: 结果映射，通过它来配置如何将 SQL 查询结果映射为对象\n+ **parameterMap**: 参数映射，通过它来配置如何将参数对象映射为 SQL参数。该节点已废弃，建议直接使用内联参数\n+ **sql**: SQL语句片段，通过它来设置可以被复用的语句片段\n+ **insert**: 插入语句\n+ **update**: 更新语句\n+ **delete**: 删除语句\n+ **select**: 查询语句\n\n示例：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper   PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.github.yeecode.mybatisdemo.UserMapper\">\n    <!-- 数据库操作节点 -->\n    <select id=\"queryUserBySchoolName\" resultType=\"com.github.yeecode.mybatisdemo.User\">\n        <!-- 数据库操作语句 -->\n        SELECT * FROM `user`\n        <if test=\"schoolName != null\">\n            WHERE schoolName = #{schoolName}\n        </if>\n    </select>\n</mapper>\n```\n\n### 映射接口文件\n映射接口文件是一个Java接口文件，并且该接口不需要实现类。通常情况下，每个映射接口文件都有一个同名的映射文件与之相对应。\n\n在映射接口文件中可以定义一些抽象方法，这些抽象方法可以分为两类：\n\n+ 第一类抽象方法与对应的**映射文件**中的数据库操作节点相对应\n+ 第二类抽象方法通过**注解声明**自身的数据库操作语句\n\n> **注意**：当整个接口文件中均为注解类抽象方法时，则该映射接口文件可以没有对应的映射文件\n\n示例：\n```java\npublic interface UserMapper {\n    // 该抽象方法对应着映射文件中的数据库操作节点\n    List<User> queryUserBySchoolName(User user);\n\n    // 该抽象方法通过注解声明自身的数据库操作语句\n    @Select(\"SELECT * FROM `user` WHERE `id`=#{id}\")\n    User queryUserById(Integer id);\n}\n```\n\n## 工作过程\n项目运行中， MyBatis 操作大致分为两个阶段：\n\n+ MyBatis初始化阶段：MyBatis启动时运行一次，完成MyBatis运行环境的**配置工作**\n+ 数据读写阶段：由数据读写操作触发，完成增删改查请求\n\n### 初始化阶段\nMyBatis的初始化在整个项目启动时开始执行，主要完成**配置文件的解析**、**数据库的连接**等操作\n\n#### 配置信息读取\n读取配置文件`mybatis-config.xml`得到`InputStream`，通过调用`SqlSessionFactoryBuilder`类的`build()`方法，生成`SqlSessionFactory`对象。\n\n演示用户代码如下：\n```java\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n```\n\n其中`SqlSessionFactoryBuilder`类的`build()`核心方法如下，方法内创建`XMLConfigBuilder`类并调用`parse()`方法解析`mybatis-config.xml`得到`configuration`对象，也就是记录MyBatis全部配置信息的全局配置对象\n```java\npublic SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n        XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n        return build(parser.parse());\n    } catch (Exception e) {\n        throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n        ErrorContext.instance().reset();\n        try {\n            inputStream.close();\n        } catch (IOException e) {\n        }\n    }\n}\n\n// 上面方法中实际创建 SqlSessionFactory 实例的方法\npublic SqlSessionFactory build(Configuration config) {\n    return new DefaultSqlSessionFactory(config);\n}\n```\n\n`XMLConfigBuilder`类的`parse()`方法如下，解析过程固定，因此前文强调必须按顺序写\n```java\npublic Configuration parse() {\n    if (parsed) {\n        throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n    }\n    parsed = true;\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n}\n\n// 核心解析方法\nprivate void parseConfiguration(XNode root) {\n    try {\n        //issue #117 read properties first\n        propertiesElement(root.evalNode(\"properties\"));\n        Properties settings = settingsAsProperties(root.evalNode(\"settings\"));\n        loadCustomVfs(settings);\n        loadCustomLogImpl(settings);\n        typeAliasesElement(root.evalNode(\"typeAliases\"));\n        pluginElement(root.evalNode(\"plugins\"));\n        objectFactoryElement(root.evalNode(\"objectFactory\"));\n        objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n        reflectorFactoryElement(root.evalNode(\"reflectorFactory\"));\n        settingsElement(settings);\n        // read it after objectFactory and objectWrapperFactory issue #631\n        environmentsElement(root.evalNode(\"environments\"));\n        databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n        typeHandlerElement(root.evalNode(\"typeHandlers\"));\n        mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n        throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n}\n```\n\n`DefaultSqlSessionFactory`类是`SqlSessionFactory`接口的默认实现类，其中保存了`configuration`对象\n```java\npublic class DefaultSqlSessionFactory implements SqlSessionFactory {\n\n    private final Configuration configuration;\n\n    public DefaultSqlSessionFactory(Configuration configuration) {\n        this.configuration = configuration;\n    }\n    // 核心方法之一，创建SqlSession对象\n    @Override\n    public SqlSession openSession() {\n        return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);\n    }\n\n    ...\n}\n```\n\n> `SqlSessionFactory`对象是生产`SqlSession`对象的工厂，`SqlSession`对象是数据读写阶段的操作接口，详见下文\n\n### 数据读写阶段\n后续分析各个包的作用过程中，请**牢牢记住本节的内容，把握主线，串联细节，融合贯通**\n\n#### 获取SqlSession对象\n演示用户代码如下：\n```java\nSqlSession session = sqlSessionFactory.openSession()\n```\n\n`DefaultSqlSessionFactory`类中`openSession()`的具体实现如下：\n```java\n// 核心方法之一，创建SqlSession对象\n@Override\npublic SqlSession openSession() {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);\n}\n\nprivate SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level,\n                                            boolean autoCommit) {\n    Transaction tx = null;\n    try {\n        // 找出要使用的指定环境\n        final Environment environment = configuration.getEnvironment();\n        // 从环境中获取事务工厂\n        final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n        // 从事务工厂中生产事务\n        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n        // 创建执行器\n        final Executor executor = configuration.newExecutor(tx, execType);\n        // 创建DefaultSqlSession对象\n        return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n        closeTransaction(tx); // may have fetched a connection so lets call close()\n        throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n        ErrorContext.instance().reset();\n    }\n}\n```\n\n`DefaultSqlSession`类是`SqlSession`接口的实现类，它提供了查询、增加、更新、删除、提交、回滚等大量的方法\n\n\n> **注意**: 数据读写阶段是在进行数据读写时触发的，但并不是每次读写都会触发\n> “SqlSession session=sqlSessionFactory.openSession()”操作\n> 因为该操作得到的 DefaultSqlSession 对象可以供多次数据库读写操作复用\n\n#### 映射接口文件与映射文件的绑定\n演示代码如下，通过调用`DefaultSqlSession`类的`getMapper(Class<T>)`方法获取`UserMapper`对象\n```java\n// 找到接口对应的实现\nUserMapper userMapper = session.getMapper(UserMapper.class);\n```\n\n`DefaultSqlSession`类的`getMapper(Class<T>)`方法经过`configuration`对象转交，最终到`MapperRegistry`类中的`getMapper(Class<T>, SqlSession)`方法\n\n`MapperRegistry`类记录了配置文件中所有的映射文件路径，给定java类名后，`getMapper(Class<T>, SqlSession)`方法通过映射接口信息从所有已经解析的映射文件中找到对应的映射文件，然后根据该映射文件组建并返回接口的一个实现对象（代理对象）\n\n```java\npublic <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n    // 找出指定映射接口的代理工厂\n    final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);\n    if (mapperProxyFactory == null) {\n        throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n    }\n    try {\n        // 通过mapperProxyFactory给出对应代理器的实例\n        return mapperProxyFactory.newInstance(sqlSession);\n    } catch (Exception e) {\n        throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n    }\n}\n```\n\n#### 映射接口的代理\n上文说到，`MapperRegistry`类的`getMapper`方法返回的是一个代理对象，其创建者实际上是`MapperProxyFactory`类，对应代码如下：\n```java\n// getMapper调用的\npublic T newInstance(SqlSession sqlSession) {\n    final MapperProxy<T> mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n}\n\nprotected T newInstance(MapperProxy<T> mapperProxy) {\n    // 三个参数分别是：\n    // 创建代理对象的类加载器、要代理的接口、代理类的处理器（即具体的实现）。\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n}\n```\n\n代理对象本身为`MapperProxy`类，其实现了`InvocationHandler`接口，重载了`invoke()`函数，因此当出现`*Mapper`类中的方法被调用时，会通过该函数完成调用\n```java\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    try {\n        if (Object.class.equals(method.getDeclaringClass())) { // 继承自Object的方法\n            // 直接执行原有方法\n            return method.invoke(this, args);\n        } else if (method.isDefault()) { // 默认方法\n            // 执行默认方法\n            return invokeDefaultMethod(proxy, method, args);\n        }\n    } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n    }\n    // 找对对应的MapperMethod对象\n    final MapperMethod mapperMethod = cachedMapperMethod(method);\n    //** 调用MapperMethod中的execute方法\n    return mapperMethod.execute(sqlSession, args);\n}\n```\n\n这里的核心是`mapperMethod.execute(sqlSession, args)`，MyBatis将映射接口与`MapperProxy`对应，将映射接口中的抽象方法与`MapperMethod`对应，`MapperMethod`类中的`execute()`方法则根据语句类型重新调用`SqlSession`对象中的增删改查方法\n```java\npublic Object execute(SqlSession sqlSession, Object[] args) {\n    Object result;\n    switch (command.getType()) { // 根据SQL语句类型，执行不同操作\n        case INSERT: { // 如果是插入语句\n            ...\n            break;\n        }\n        case UPDATE: { // 如果是更新语句\n            ...\n            break;\n        }\n        case DELETE: { // 如果是删除语句MappedStatement\n            ...\n            break;\n        }\n        case SELECT: // 如果是查询语句\n            ...\n            break;\n        case FLUSH: // 清空缓存语句\n            ...\n            break;\n        default: // 未知语句类型，抛出异常\n            throw new BindingException(\"Unknown execution method for: \" + command.getName());\n    }\n    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n        // 查询结果为null,但返回类型为基本类型。因此返回变量无法接收查询结果，抛出异常。\n        throw new BindingException(\"Mapper method '\" + command.getName()\n            + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n    }\n    return result;\n}\n```\n\n到这里，MyBatis已经完成了**为映射接口注入实现**的过程，对映射接口中抽象方法的调用转变为了`SqlSesion`类的方法调用\n\n#### SQL 语句的查找\n`MapperMethod`类中的`execute()`方法中根据实际操作类型不同将控制权交给`SqlSession`类的不同方法\n\n以`selectList()`方法为例，具体过程都是先构建`MappedStatement`对象，然后交由`Executor`对象执行\n```java\n@Override\npublic <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n    try {\n        // 获取查询语句\n        MappedStatement ms = configuration.getMappedStatement(statement);\n        // 交由执行器进行查询\n        return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n    } catch (Exception e) {\n        throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n        ErrorContext.instance().reset();\n    }\n}\n```\n\n#### 查询结果缓存\n`Executor`是一个接口，有`BaseExecutor`类和`CachingExecutor`类两种实现，`CachingExecutor`类表示查询过程使用缓存，即可以将之前的查询结果缓存，避免一直访问数据库\n\n因此示例实际执行的代码是`CachingExecutor`类中的`query()`方法\n```java\npublic <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameterObject);\n    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);\n    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n}\n```\n\n`BoundSql`是经过层层转化后去除掉`if`、`where`等标签的 SQL 语句，而`CacheKey`是为该次查询操作计算出来的缓存键\n\n接下来，MyBatis查看当前的查询操作是否命中缓存，命中则从缓存中获取数据结果；否则通过`delegate`调用`query()`方法\n```java\n@Override\npublic <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n    throws SQLException {\n    // 获取MappedStatement对应的缓存，可能的结果有：该命名空间的缓存、共享的其它命名空间的缓存、无缓存\n    Cache cache = ms.getCache();\n    // 如果映射文件未设置<cache>或<cache-ref>则，此处cache变量为null\n    if (cache != null) { // 存在缓存\n        // 根据要求判断语句执行前是否要清除二级缓存，如果需要，清除二级缓存\n        flushCacheIfRequired(ms);\n        if (ms.isUseCache() && resultHandler == null) { // 该语句使用缓存且没有输出结果处理器\n            // 二级缓存不支持含有输出参数的CALLABLE语句，故在这里进行判断\n            ensureNoOutParams(ms, boundSql);\n            // 从缓存中读取结果\n            @SuppressWarnings(\"unchecked\")\n            List<E> list = (List<E>) tcm.getObject(cache, key);\n            if (list == null) { // 缓存中没有结果\n                // 交给被包装的执行器执行\n                list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n                // 缓存被包装执行器返回的结果\n                tcm.putObject(cache, key, list); // issue #578 and #116\n            }\n            return list;\n        }\n    }\n    // 交由被包装的实际执行器执行\n    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n}\n```\n\n#### 数据库查询\n整个流程的关键步骤如下：\n+ 在进行数据库查询前，**先查询缓存**；如果确实需要查询数据库，则数据库查询之后的结果也放入缓存中\n+ SQL语句的执行经过了层层转化，依次经过了`MappedStatement`对象、`Statement`对象和`PreparedStatement`对象，最后才得以执行\n+ 最终数据库查询得到的结果交给`ResultHandler`对象处理\n\n`delegate`调用的`query()`方法实际流向`BaseExecutor`类中的`query()`方法，其中核心方法为`queryFromDatabase()`方法\n\n`queryFromDatabase()`方法代码如下：\n```java\nprivate <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, \n    ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    List<E> list;\n    // 向缓存中增加占位符，表示正在查询\n    localCache.putObject(key, EXECUTION_PLACEHOLDER);\n    try {\n        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n    } finally {\n        // 删除占位符\n        localCache.removeObject(key);\n    }\n    // 将查询结果写入缓存\n    localCache.putObject(key, list);\n    if (ms.getStatementType() == StatementType.CALLABLE) {\n        localOutputParameterCache.putObject(key, parameter);\n    }\n    return list;\n}\n```\n\nMyBatis先在缓存中放置一个占位符，然后调用`doQuery()`方法实际执行查询操作，最后，又把缓存中的占位符替换成真正的查询结果\n\n`doQuery()`方法是`BaseExecutor`类中的抽象方法，实际运行代码如下：\n```java\npublic <E> List<E> doQuery(MappedStatement ms, Object parameterObject, RowBounds rowBounds,\n                        ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n        flushStatements();\n        Configuration configuration = ms.getConfiguration();\n        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, \n                                        rowBounds, resultHandler, boundSql);\n        Connection connection = getConnection(ms.getStatementLog());\n        stmt = handler.prepare(connection, transaction.getTimeout());\n        handler.parameterize(stmt);\n        return handler.query(stmt, resultHandler);\n    } finally {\n        closeStatement(stmt);\n    }\n}\n```\n\n`handler.query(stmt，resultHandler)`调用的是`StatementHandler`接口的抽象方法，实际调用了`PreparedStatementHandler`类的代码，如下所示：\n```java\npublic <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {\n    PreparedStatement ps = (PreparedStatement) statement;\n    // 执行真正的查询，查询完成后，结果就在ps中了\n    ps.execute();\n    // 由resultSetHandler继续处理结果\n    return resultSetHandler.handleResultSets(ps);\n}\n```\n\n查询完成之后的结果放在`PreparedStatement`对象中，交由`ResultSetHandler`对象处理\n\n#### 处理结果集\n查询得到的结果并没有直接返回，而是交给`ResultSetHandler`对象处理\n\n`ResultSetHandler`是结果集处理器接口，实现类是`DefaultResultSetHandler`，因此实际处理结果的是实现类中的`handleResultSets`方法\n\n`handleResultSets`方法将查询出来的结果被遍历后放入了列表`multipleResults`中并返回，`multipleResults`中存储的就是这次查询期望的结果`List＜User＞`\n\n`handleResultSets`方法整个调用链很长，具体如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/mybatis/handleresultsets.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        handleResultSets方法调用链\n    </div>\n</center>\n\n重点关注的是图中粗线边框标注的三个方法：\n+ **createResultObject**`(ResultSetWrapper, ResultMap, List<Class<?>>, List<Object>, String)`方法: 该方法创建了输出结果对象。在示例中，为`User`对象\n+ **applyAutomaticMappings**方法: 在自动属性映射功能开启的情况下，该方法将数据记录的值赋给输出结果对象\n+ **applyPropertyMappings**方法: 该方法按照用户的映射设置，给输出结果对象的属性赋值\n\n\n经过以上过程，MyBatis将数据库输出的记录转化为了对象列表。之后，以上方法逐级返回。\n\n最后，装载着对象列表的 `multipleResults` 被返回给`List<User> userList`变量，我们便拿到了查询结果\n```java\nList<User> userList = userMapper.queryUserBySchoolName(userParam);\n```\n\n## 项目包结构\n<center>\n    <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/mybatis/packages.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n        MyBatis 项目包结构\n    </div>\n</center>\n\n## 参考\n《MyBatis源码详解——通用源码阅读指导书》","slug":"MyBatis","published":1,"updated":"2022-09-21T11:02:02.454Z","_id":"cl8bil9gg00006wvr56i8fbxw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"MyBatis-源码阅读\"><a href=\"#MyBatis-源码阅读\" class=\"headerlink\" title=\"MyBatis 源码阅读\"></a>MyBatis 源码阅读</h1><p>与 ORM 框架不同，MyBatis通过将Java方法与数据库SQL语句关联起来，从另一个角度实现了Java服务对数据库的操作</p>\n<h2 id=\"核心功能\"><a href=\"#核心功能\" class=\"headerlink\" title=\"核心功能\"></a>核心功能</h2><ul>\n<li><strong>将包含<code>if</code>等标签的复杂数据库操作语句解析为纯粹的 SQL 语句</strong></li>\n<li><strong>将数据库操作节点和映射接口中的抽象方法进行绑定，在抽象方法被调用时执行数据库操作</strong></li>\n<li><strong>将输入参数对象转化为数据库操作语句中的参数</strong></li>\n<li><strong>将数据库操作语句的返回结果转化为对象</strong></li>\n</ul>\n<h2 id=\"文件组成\"><a href=\"#文件组成\" class=\"headerlink\" title=\"文件组成\"></a>文件组成</h2><h3 id=\"全局配置文件\"><a href=\"#全局配置文件\" class=\"headerlink\" title=\"全局配置文件\"></a>全局配置文件</h3><p>MyBatis 的配置文件为一个 XML 文件，通常被命名为 <code>mybatis-config.xml</code> ，该 XML文件的根节点为 <code>configuration</code> ，根节点内可以包含的一级节点及其含义如下所示</p>\n<ul>\n<li><strong>properties</strong>: 属性信息，相当于 MyBatis 的全局变量</li>\n<li><strong>settings</strong>: 设置信息，通过它对 MyBatis 的功能进行调整</li>\n<li><strong>typeAliases</strong>: 类型别名，在这里可以为类型设置一些简短的名字</li>\n<li><strong>typeHandlers</strong>: 类型处理器，在这里可以为不同的类型设置相应的处理器</li>\n<li><strong>objectFactory</strong>: 对象工厂，在这里可以指定 MyBatis 创建新对象时使用的工厂</li>\n<li><strong>objectWrapperFactory</strong>: 对象包装器工厂，在这里可以指定 MyBatis 使用的对象包装器工厂</li>\n<li><strong>reflectorFactory</strong>: 反射器工厂，在这里可以设置 MyBatis 的反射器工厂</li>\n<li><strong>plugins</strong>: 插件，在这里可以为 MyBatis 配置插件，从而修改或扩展 MyBatis 的行为 </li>\n<li><strong>environments</strong>: 环境，这里可以配置 MyBatis 运行的环境信息，如数据源信息等</li>\n<li><strong>databaseIdProvider</strong>: 数据库编号，在这里可以为不同的数据库配置不同的编号，这样可以对不同类型的数据库设置不同的数据库操作语句</li>\n<li><strong>mappers</strong>: 映射文件，在这里可以配置映射文件或映射接口文件的地址</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：配置文件中的一级节点是有顺序要求的，这些节点必须按照上面列举 的顺序出现。在使用中可以根据实际需要选择相应的节点依次写入配置文件。</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">configuration</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"com.github.yeecode.mybatisdemo\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://127.0.0.1:3306/yeecode?serverTimezone=UTC\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"yeecode\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"com/github/yeecode/mybatisdemo/UserMapper.xml\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"映射文件\"><a href=\"#映射文件\" class=\"headerlink\" title=\"映射文件\"></a>映射文件</h3><p>映射文件也是一个 XML 文件，用来完成Java方法与SQL语句的映射、Java对象与SQL参数的映射、SQL查询结果与Java对象的映射等</p>\n<p>映射文件的根节点为 <code>mapper</code> ，在 <code>mapper</code> 节点下可以包含的节点及其含义如下所示</p>\n<ul>\n<li><strong>cache</strong>: 缓存，通过它可以对当前命名空间进行缓存配置</li>\n<li><strong>cache-ref</strong>: 缓存引用，通过它可以引用其他命名空间的缓存作为当前命名空间的缓存</li>\n<li><strong>resultMap</strong>: 结果映射，通过它来配置如何将 SQL 查询结果映射为对象</li>\n<li><strong>parameterMap</strong>: 参数映射，通过它来配置如何将参数对象映射为 SQL参数。该节点已废弃，建议直接使用内联参数</li>\n<li><strong>sql</strong>: SQL语句片段，通过它来设置可以被复用的语句片段</li>\n<li><strong>insert</strong>: 插入语句</li>\n<li><strong>update</strong>: 更新语句</li>\n<li><strong>delete</strong>: 删除语句</li>\n<li><strong>select</strong>: 查询语句</li>\n</ul>\n<p>示例：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">mapper</span>   <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span> <span class=\"meta-string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.github.yeecode.mybatisdemo.UserMapper\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 数据库操作节点 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"queryUserBySchoolName\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.github.yeecode.mybatisdemo.User\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 数据库操作语句 --&gt;</span></span><br><span class=\"line\">        SELECT * FROM `user`</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"schoolName != null\"</span>&gt;</span></span><br><span class=\"line\">            WHERE schoolName = #&#123;schoolName&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"映射接口文件\"><a href=\"#映射接口文件\" class=\"headerlink\" title=\"映射接口文件\"></a>映射接口文件</h3><p>映射接口文件是一个Java接口文件，并且该接口不需要实现类。通常情况下，每个映射接口文件都有一个同名的映射文件与之相对应。</p>\n<p>在映射接口文件中可以定义一些抽象方法，这些抽象方法可以分为两类：</p>\n<ul>\n<li>第一类抽象方法与对应的<strong>映射文件</strong>中的数据库操作节点相对应</li>\n<li>第二类抽象方法通过<strong>注解声明</strong>自身的数据库操作语句</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：当整个接口文件中均为注解类抽象方法时，则该映射接口文件可以没有对应的映射文件</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该抽象方法对应着映射文件中的数据库操作节点</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;User&gt; <span class=\"title\">queryUserBySchoolName</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该抽象方法通过注解声明自身的数据库操作语句</span></span><br><span class=\"line\">    <span class=\"meta\">@Select</span>(<span class=\"string\">\"SELECT * FROM `user` WHERE `id`=#&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\">User <span class=\"title\">queryUserById</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h2><p>项目运行中， MyBatis 操作大致分为两个阶段：</p>\n<ul>\n<li>MyBatis初始化阶段：MyBatis启动时运行一次，完成MyBatis运行环境的<strong>配置工作</strong></li>\n<li>数据读写阶段：由数据读写操作触发，完成增删改查请求</li>\n</ul>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>MyBatis的初始化在整个项目启动时开始执行，主要完成<strong>配置文件的解析</strong>、<strong>数据库的连接</strong>等操作</p>\n<h4 id=\"配置信息读取\"><a href=\"#配置信息读取\" class=\"headerlink\" title=\"配置信息读取\"></a>配置信息读取</h4><p>读取配置文件<code>mybatis-config.xml</code>得到<code>InputStream</code>，通过调用<code>SqlSessionFactoryBuilder</code>类的<code>build()</code>方法，生成<code>SqlSessionFactory</code>对象。</p>\n<p>演示用户代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSessionFactory sqlSessionFactory = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>SqlSessionFactoryBuilder</code>类的<code>build()</code>核心方法如下，方法内创建<code>XMLConfigBuilder</code>类并调用<code>parse()</code>方法解析<code>mybatis-config.xml</code>得到<code>configuration</code>对象，也就是记录MyBatis全部配置信息的全局配置对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        XMLConfigBuilder parser = <span class=\"keyword\">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> build(parser.parse());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error building SqlSession.\"</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            inputStream.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面方法中实际创建 SqlSessionFactory 实例的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(Configuration config)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultSqlSessionFactory(config);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>XMLConfigBuilder</code>类的<code>parse()</code>方法如下，解析过程固定，因此前文强调必须按顺序写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Configuration <span class=\"title\">parse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Each XMLConfigBuilder can only be used once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parsed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    parseConfiguration(parser.evalNode(<span class=\"string\">\"/configuration\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> configuration;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 核心解析方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">parseConfiguration</span><span class=\"params\">(XNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//issue #117 read properties first</span></span><br><span class=\"line\">        propertiesElement(root.evalNode(<span class=\"string\">\"properties\"</span>));</span><br><span class=\"line\">        Properties settings = settingsAsProperties(root.evalNode(<span class=\"string\">\"settings\"</span>));</span><br><span class=\"line\">        loadCustomVfs(settings);</span><br><span class=\"line\">        loadCustomLogImpl(settings);</span><br><span class=\"line\">        typeAliasesElement(root.evalNode(<span class=\"string\">\"typeAliases\"</span>));</span><br><span class=\"line\">        pluginElement(root.evalNode(<span class=\"string\">\"plugins\"</span>));</span><br><span class=\"line\">        objectFactoryElement(root.evalNode(<span class=\"string\">\"objectFactory\"</span>));</span><br><span class=\"line\">        objectWrapperFactoryElement(root.evalNode(<span class=\"string\">\"objectWrapperFactory\"</span>));</span><br><span class=\"line\">        reflectorFactoryElement(root.evalNode(<span class=\"string\">\"reflectorFactory\"</span>));</span><br><span class=\"line\">        settingsElement(settings);</span><br><span class=\"line\">        <span class=\"comment\">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class=\"line\">        environmentsElement(root.evalNode(<span class=\"string\">\"environments\"</span>));</span><br><span class=\"line\">        databaseIdProviderElement(root.evalNode(<span class=\"string\">\"databaseIdProvider\"</span>));</span><br><span class=\"line\">        typeHandlerElement(root.evalNode(<span class=\"string\">\"typeHandlers\"</span>));</span><br><span class=\"line\">        mapperElement(root.evalNode(<span class=\"string\">\"mappers\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Error parsing SQL Mapper Configuration. Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSessionFactory</code>类是<code>SqlSessionFactory</code>接口的默认实现类，其中保存了<code>configuration</code>对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultSqlSessionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">SqlSessionFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Configuration configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultSqlSessionFactory</span><span class=\"params\">(Configuration configuration)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configuration = configuration;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 核心方法之一，创建SqlSession对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSession <span class=\"title\">openSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>SqlSessionFactory</code>对象是生产<code>SqlSession</code>对象的工厂，<code>SqlSession</code>对象是数据读写阶段的操作接口，详见下文</p>\n</blockquote>\n<h3 id=\"数据读写阶段\"><a href=\"#数据读写阶段\" class=\"headerlink\" title=\"数据读写阶段\"></a>数据读写阶段</h3><p>后续分析各个包的作用过程中，请<strong>牢牢记住本节的内容，把握主线，串联细节，融合贯通</strong></p>\n<h4 id=\"获取SqlSession对象\"><a href=\"#获取SqlSession对象\" class=\"headerlink\" title=\"获取SqlSession对象\"></a>获取SqlSession对象</h4><p>演示用户代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession()</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSessionFactory</code>类中<code>openSession()</code>的具体实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 核心方法之一，创建SqlSession对象</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSession <span class=\"title\">openSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SqlSession <span class=\"title\">openSessionFromDataSource</span><span class=\"params\">(ExecutorType execType, TransactionIsolationLevel level,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            <span class=\"keyword\">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class=\"line\">    Transaction tx = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找出要使用的指定环境</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Environment environment = configuration.getEnvironment();</span><br><span class=\"line\">        <span class=\"comment\">// 从环境中获取事务工厂</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class=\"line\">        <span class=\"comment\">// 从事务工厂中生产事务</span></span><br><span class=\"line\">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class=\"line\">        <span class=\"comment\">// 创建执行器</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class=\"line\">        <span class=\"comment\">// 创建DefaultSqlSession对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        closeTransaction(tx); <span class=\"comment\">// may have fetched a connection so lets call close()</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error opening session.  Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSession</code>类是<code>SqlSession</code>接口的实现类，它提供了查询、增加、更新、删除、提交、回滚等大量的方法</p>\n<blockquote>\n<p><strong>注意</strong>: 数据读写阶段是在进行数据读写时触发的，但并不是每次读写都会触发<br>“SqlSession session=sqlSessionFactory.openSession()”操作<br>因为该操作得到的 DefaultSqlSession 对象可以供多次数据库读写操作复用</p>\n</blockquote>\n<h4 id=\"映射接口文件与映射文件的绑定\"><a href=\"#映射接口文件与映射文件的绑定\" class=\"headerlink\" title=\"映射接口文件与映射文件的绑定\"></a>映射接口文件与映射文件的绑定</h4><p>演示代码如下，通过调用<code>DefaultSqlSession</code>类的<code>getMapper(Class&lt;T&gt;)</code>方法获取<code>UserMapper</code>对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到接口对应的实现</span></span><br><span class=\"line\">UserMapper userMapper = session.getMapper(UserMapper<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSession</code>类的<code>getMapper(Class&lt;T&gt;)</code>方法经过<code>configuration</code>对象转交，最终到<code>MapperRegistry</code>类中的<code>getMapper(Class&lt;T&gt;, SqlSession)</code>方法</p>\n<p><code>MapperRegistry</code>类记录了配置文件中所有的映射文件路径，给定java类名后，<code>getMapper(Class&lt;T&gt;, SqlSession)</code>方法通过映射接口信息从所有已经解析的映射文件中找到对应的映射文件，然后根据该映射文件组建并返回接口的一个实现对象（代理对象）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getMapper</span><span class=\"params\">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找出指定映射接口的代理工厂</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mapperProxyFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Type \"</span> + type + <span class=\"string\">\" is not known to the MapperRegistry.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过mapperProxyFactory给出对应代理器的实例</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Error getting mapper instance. Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射接口的代理\"><a href=\"#映射接口的代理\" class=\"headerlink\" title=\"映射接口的代理\"></a>映射接口的代理</h4><p>上文说到，<code>MapperRegistry</code>类的<code>getMapper</code>方法返回的是一个代理对象，其创建者实际上是<code>MapperProxyFactory</code>类，对应代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// getMapper调用的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">newInstance</span><span class=\"params\">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class=\"keyword\">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newInstance(mapperProxy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">newInstance</span><span class=\"params\">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 三个参数分别是：</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象的类加载器、要代理的接口、代理类的处理器（即具体的实现）。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class=\"keyword\">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代理对象本身为<code>MapperProxy</code>类，其实现了<code>InvocationHandler</code>接口，重载了<code>invoke()</code>函数，因此当出现<code>*Mapper</code>类中的方法被调用时，会通过该函数完成调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Object<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">equals</span>(<span class=\"title\">method</span>.<span class=\"title\">getDeclaringClass</span>())) </span>&#123; <span class=\"comment\">// 继承自Object的方法</span></span><br><span class=\"line\">            <span class=\"comment\">// 直接执行原有方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.isDefault()) &#123; <span class=\"comment\">// 默认方法</span></span><br><span class=\"line\">            <span class=\"comment\">// 执行默认方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 找对对应的MapperMethod对象</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class=\"line\">    <span class=\"comment\">//** 调用MapperMethod中的execute方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的核心是<code>mapperMethod.execute(sqlSession, args)</code>，MyBatis将映射接口与<code>MapperProxy</code>对应，将映射接口中的抽象方法与<code>MapperMethod</code>对应，<code>MapperMethod</code>类中的<code>execute()</code>方法则根据语句类型重新调用<code>SqlSession</code>对象中的增删改查方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">execute</span><span class=\"params\">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    Object result;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (command.getType()) &#123; <span class=\"comment\">// 根据SQL语句类型，执行不同操作</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> INSERT: &#123; <span class=\"comment\">// 如果是插入语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> UPDATE: &#123; <span class=\"comment\">// 如果是更新语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> DELETE: &#123; <span class=\"comment\">// 如果是删除语句MappedStatement</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SELECT: <span class=\"comment\">// 如果是查询语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FLUSH: <span class=\"comment\">// 清空缓存语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">// 未知语句类型，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Unknown execution method for: \"</span> + command.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 查询结果为null,但返回类型为基本类型。因此返回变量无法接收查询结果，抛出异常。</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Mapper method '\"</span> + command.getName()</span><br><span class=\"line\">            + <span class=\"string\">\" attempted to return null from a method with a primitive return type (\"</span> + method.getReturnType() + <span class=\"string\">\").\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>到这里，MyBatis已经完成了<strong>为映射接口注入实现</strong>的过程，对映射接口中抽象方法的调用转变为了<code>SqlSesion</code>类的方法调用</p>\n<h4 id=\"SQL-语句的查找\"><a href=\"#SQL-语句的查找\" class=\"headerlink\" title=\"SQL 语句的查找\"></a>SQL 语句的查找</h4><p><code>MapperMethod</code>类中的<code>execute()</code>方法中根据实际操作类型不同将控制权交给<code>SqlSession</code>类的不同方法</p>\n<p>以<code>selectList()</code>方法为例，具体过程都是先构建<code>MappedStatement</code>对象，然后交由<code>Executor</code>对象执行<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">selectList</span><span class=\"params\">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取查询语句</span></span><br><span class=\"line\">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class=\"line\">        <span class=\"comment\">// 交由执行器进行查询</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error querying database.  Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询结果缓存\"><a href=\"#查询结果缓存\" class=\"headerlink\" title=\"查询结果缓存\"></a>查询结果缓存</h4><p><code>Executor</code>是一个接口，有<code>BaseExecutor</code>类和<code>CachingExecutor</code>类两种实现，<code>CachingExecutor</code>类表示查询过程使用缓存，即可以将之前的查询结果缓存，避免一直访问数据库</p>\n<p>因此示例实际执行的代码是<code>CachingExecutor</code>类中的<code>query()</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">query</span><span class=\"params\">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class=\"line\">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>BoundSql</code>是经过层层转化后去除掉<code>if</code>、<code>where</code>等标签的 SQL 语句，而<code>CacheKey</code>是为该次查询操作计算出来的缓存键</p>\n<p>接下来，MyBatis查看当前的查询操作是否命中缓存，命中则从缓存中获取数据结果；否则通过<code>delegate</code>调用<code>query()</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">query</span><span class=\"params\">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取MappedStatement对应的缓存，可能的结果有：该命名空间的缓存、共享的其它命名空间的缓存、无缓存</span></span><br><span class=\"line\">    Cache cache = ms.getCache();</span><br><span class=\"line\">    <span class=\"comment\">// 如果映射文件未设置&lt;cache&gt;或&lt;cache-ref&gt;则，此处cache变量为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 存在缓存</span></span><br><span class=\"line\">        <span class=\"comment\">// 根据要求判断语句执行前是否要清除二级缓存，如果需要，清除二级缓存</span></span><br><span class=\"line\">        flushCacheIfRequired(ms);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 该语句使用缓存且没有输出结果处理器</span></span><br><span class=\"line\">            <span class=\"comment\">// 二级缓存不支持含有输出参数的CALLABLE语句，故在这里进行判断</span></span><br><span class=\"line\">            ensureNoOutParams(ms, boundSql);</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中读取结果</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 缓存中没有结果</span></span><br><span class=\"line\">                <span class=\"comment\">// 交给被包装的执行器执行</span></span><br><span class=\"line\">                list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class=\"line\">                <span class=\"comment\">// 缓存被包装执行器返回的结果</span></span><br><span class=\"line\">                tcm.putObject(cache, key, list); <span class=\"comment\">// issue #578 and #116</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 交由被包装的实际执行器执行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数据库查询\"><a href=\"#数据库查询\" class=\"headerlink\" title=\"数据库查询\"></a>数据库查询</h4><p>整个流程的关键步骤如下：</p>\n<ul>\n<li>在进行数据库查询前，<strong>先查询缓存</strong>；如果确实需要查询数据库，则数据库查询之后的结果也放入缓存中</li>\n<li>SQL语句的执行经过了层层转化，依次经过了<code>MappedStatement</code>对象、<code>Statement</code>对象和<code>PreparedStatement</code>对象，最后才得以执行</li>\n<li>最终数据库查询得到的结果交给<code>ResultHandler</code>对象处理</li>\n</ul>\n<p><code>delegate</code>调用的<code>query()</code>方法实际流向<code>BaseExecutor</code>类中的<code>query()</code>方法，其中核心方法为<code>queryFromDatabase()</code>方法</p>\n<p><code>queryFromDatabase()</code>方法代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">queryFromDatabase</span><span class=\"params\">(MappedStatement ms, Object parameter, RowBounds rowBounds, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    List&lt;E&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">// 向缓存中增加占位符，表示正在查询</span></span><br><span class=\"line\">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除占位符</span></span><br><span class=\"line\">        localCache.removeObject(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将查询结果写入缓存</span></span><br><span class=\"line\">    localCache.putObject(key, list);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class=\"line\">        localOutputParameterCache.putObject(key, parameter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>MyBatis先在缓存中放置一个占位符，然后调用<code>doQuery()</code>方法实际执行查询操作，最后，又把缓存中的占位符替换成真正的查询结果</p>\n<p><code>doQuery()</code>方法是<code>BaseExecutor</code>类中的抽象方法，实际运行代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">doQuery</span><span class=\"params\">(MappedStatement ms, Object parameterObject, RowBounds rowBounds,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        ResultHandler resultHandler, BoundSql boundSql)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    Statement stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        flushStatements();</span><br><span class=\"line\">        Configuration configuration = ms.getConfiguration();</span><br><span class=\"line\">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, </span><br><span class=\"line\">                                        rowBounds, resultHandler, boundSql);</span><br><span class=\"line\">        Connection connection = getConnection(ms.getStatementLog());</span><br><span class=\"line\">        stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class=\"line\">        handler.parameterize(stmt);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handler.query(stmt, resultHandler);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        closeStatement(stmt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>handler.query(stmt，resultHandler)</code>调用的是<code>StatementHandler</code>接口的抽象方法，实际调用了<code>PreparedStatementHandler</code>类的代码，如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">query</span><span class=\"params\">(Statement statement, ResultHandler resultHandler)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class=\"line\">    <span class=\"comment\">// 执行真正的查询，查询完成后，结果就在ps中了</span></span><br><span class=\"line\">    ps.execute();</span><br><span class=\"line\">    <span class=\"comment\">// 由resultSetHandler继续处理结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>查询完成之后的结果放在<code>PreparedStatement</code>对象中，交由<code>ResultSetHandler</code>对象处理</p>\n<h4 id=\"处理结果集\"><a href=\"#处理结果集\" class=\"headerlink\" title=\"处理结果集\"></a>处理结果集</h4><p>查询得到的结果并没有直接返回，而是交给<code>ResultSetHandler</code>对象处理</p>\n<p><code>ResultSetHandler</code>是结果集处理器接口，实现类是<code>DefaultResultSetHandler</code>，因此实际处理结果的是实现类中的<code>handleResultSets</code>方法</p>\n<p><code>handleResultSets</code>方法将查询出来的结果被遍历后放入了列表<code>multipleResults</code>中并返回，<code>multipleResults</code>中存储的就是这次查询期望的结果<code>List＜User＞</code></p>\n<p><code>handleResultSets</code>方法整个调用链很长，具体如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/mybatis/handleresultsets.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        handleResultSets方法调用链\n    </div>\n</center>\n\n<p>重点关注的是图中粗线边框标注的三个方法：</p>\n<ul>\n<li><strong>createResultObject</strong><code>(ResultSetWrapper, ResultMap, List&lt;Class&lt;?&gt;&gt;, List&lt;Object&gt;, String)</code>方法: 该方法创建了输出结果对象。在示例中，为<code>User</code>对象</li>\n<li><strong>applyAutomaticMappings</strong>方法: 在自动属性映射功能开启的情况下，该方法将数据记录的值赋给输出结果对象</li>\n<li><strong>applyPropertyMappings</strong>方法: 该方法按照用户的映射设置，给输出结果对象的属性赋值</li>\n</ul>\n<p>经过以上过程，MyBatis将数据库输出的记录转化为了对象列表。之后，以上方法逐级返回。</p>\n<p>最后，装载着对象列表的 <code>multipleResults</code> 被返回给<code>List&lt;User&gt; userList</code>变量，我们便拿到了查询结果<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = userMapper.queryUserBySchoolName(userParam);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"项目包结构\"><a href=\"#项目包结构\" class=\"headerlink\" title=\"项目包结构\"></a>项目包结构</h2><center>\n    <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/mybatis/packages.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n        MyBatis 项目包结构\n    </div>\n</center>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《MyBatis源码详解——通用源码阅读指导书》</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MyBatis-源码阅读\"><a href=\"#MyBatis-源码阅读\" class=\"headerlink\" title=\"MyBatis 源码阅读\"></a>MyBatis 源码阅读</h1><p>与 ORM 框架不同，MyBatis通过将Java方法与数据库SQL语句关联起来，从另一个角度实现了Java服务对数据库的操作</p>\n<h2 id=\"核心功能\"><a href=\"#核心功能\" class=\"headerlink\" title=\"核心功能\"></a>核心功能</h2><ul>\n<li><strong>将包含<code>if</code>等标签的复杂数据库操作语句解析为纯粹的 SQL 语句</strong></li>\n<li><strong>将数据库操作节点和映射接口中的抽象方法进行绑定，在抽象方法被调用时执行数据库操作</strong></li>\n<li><strong>将输入参数对象转化为数据库操作语句中的参数</strong></li>\n<li><strong>将数据库操作语句的返回结果转化为对象</strong></li>\n</ul>\n<h2 id=\"文件组成\"><a href=\"#文件组成\" class=\"headerlink\" title=\"文件组成\"></a>文件组成</h2><h3 id=\"全局配置文件\"><a href=\"#全局配置文件\" class=\"headerlink\" title=\"全局配置文件\"></a>全局配置文件</h3><p>MyBatis 的配置文件为一个 XML 文件，通常被命名为 <code>mybatis-config.xml</code> ，该 XML文件的根节点为 <code>configuration</code> ，根节点内可以包含的一级节点及其含义如下所示</p>\n<ul>\n<li><strong>properties</strong>: 属性信息，相当于 MyBatis 的全局变量</li>\n<li><strong>settings</strong>: 设置信息，通过它对 MyBatis 的功能进行调整</li>\n<li><strong>typeAliases</strong>: 类型别名，在这里可以为类型设置一些简短的名字</li>\n<li><strong>typeHandlers</strong>: 类型处理器，在这里可以为不同的类型设置相应的处理器</li>\n<li><strong>objectFactory</strong>: 对象工厂，在这里可以指定 MyBatis 创建新对象时使用的工厂</li>\n<li><strong>objectWrapperFactory</strong>: 对象包装器工厂，在这里可以指定 MyBatis 使用的对象包装器工厂</li>\n<li><strong>reflectorFactory</strong>: 反射器工厂，在这里可以设置 MyBatis 的反射器工厂</li>\n<li><strong>plugins</strong>: 插件，在这里可以为 MyBatis 配置插件，从而修改或扩展 MyBatis 的行为 </li>\n<li><strong>environments</strong>: 环境，这里可以配置 MyBatis 运行的环境信息，如数据源信息等</li>\n<li><strong>databaseIdProvider</strong>: 数据库编号，在这里可以为不同的数据库配置不同的编号，这样可以对不同类型的数据库设置不同的数据库操作语句</li>\n<li><strong>mappers</strong>: 映射文件，在这里可以配置映射文件或映射接口文件的地址</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：配置文件中的一级节点是有顺序要求的，这些节点必须按照上面列举 的顺序出现。在使用中可以根据实际需要选择相应的节点依次写入配置文件。</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">configuration</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">\"-//mybatis.org//DTD Config 3.0//EN\"</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-string\">\"http://mybatis.org/dtd/mybatis-3-config.dtd\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">name</span>=<span class=\"string\">\"com.github.yeecode.mybatisdemo\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"development\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://127.0.0.1:3306/yeecode?serverTimezone=UTC\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>/&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"yeecode\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"com/github/yeecode/mybatisdemo/UserMapper.xml\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"映射文件\"><a href=\"#映射文件\" class=\"headerlink\" title=\"映射文件\"></a>映射文件</h3><p>映射文件也是一个 XML 文件，用来完成Java方法与SQL语句的映射、Java对象与SQL参数的映射、SQL查询结果与Java对象的映射等</p>\n<p>映射文件的根节点为 <code>mapper</code> ，在 <code>mapper</code> 节点下可以包含的节点及其含义如下所示</p>\n<ul>\n<li><strong>cache</strong>: 缓存，通过它可以对当前命名空间进行缓存配置</li>\n<li><strong>cache-ref</strong>: 缓存引用，通过它可以引用其他命名空间的缓存作为当前命名空间的缓存</li>\n<li><strong>resultMap</strong>: 结果映射，通过它来配置如何将 SQL 查询结果映射为对象</li>\n<li><strong>parameterMap</strong>: 参数映射，通过它来配置如何将参数对象映射为 SQL参数。该节点已废弃，建议直接使用内联参数</li>\n<li><strong>sql</strong>: SQL语句片段，通过它来设置可以被复用的语句片段</li>\n<li><strong>insert</strong>: 插入语句</li>\n<li><strong>update</strong>: 更新语句</li>\n<li><strong>delete</strong>: 删除语句</li>\n<li><strong>select</strong>: 查询语句</li>\n</ul>\n<p>示例：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">mapper</span>   <span class=\"meta-keyword\">PUBLIC</span> <span class=\"meta-string\">\"-//mybatis.org//DTD Mapper 3.0//EN\"</span> <span class=\"meta-string\">\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.github.yeecode.mybatisdemo.UserMapper\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 数据库操作节点 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"queryUserBySchoolName\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.github.yeecode.mybatisdemo.User\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 数据库操作语句 --&gt;</span></span><br><span class=\"line\">        SELECT * FROM `user`</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"schoolName != null\"</span>&gt;</span></span><br><span class=\"line\">            WHERE schoolName = #&#123;schoolName&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"映射接口文件\"><a href=\"#映射接口文件\" class=\"headerlink\" title=\"映射接口文件\"></a>映射接口文件</h3><p>映射接口文件是一个Java接口文件，并且该接口不需要实现类。通常情况下，每个映射接口文件都有一个同名的映射文件与之相对应。</p>\n<p>在映射接口文件中可以定义一些抽象方法，这些抽象方法可以分为两类：</p>\n<ul>\n<li>第一类抽象方法与对应的<strong>映射文件</strong>中的数据库操作节点相对应</li>\n<li>第二类抽象方法通过<strong>注解声明</strong>自身的数据库操作语句</li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：当整个接口文件中均为注解类抽象方法时，则该映射接口文件可以没有对应的映射文件</p>\n</blockquote>\n<p>示例：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserMapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 该抽象方法对应着映射文件中的数据库操作节点</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;User&gt; <span class=\"title\">queryUserBySchoolName</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 该抽象方法通过注解声明自身的数据库操作语句</span></span><br><span class=\"line\">    <span class=\"meta\">@Select</span>(<span class=\"string\">\"SELECT * FROM `user` WHERE `id`=#&#123;id&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\">User <span class=\"title\">queryUserById</span><span class=\"params\">(Integer id)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h2><p>项目运行中， MyBatis 操作大致分为两个阶段：</p>\n<ul>\n<li>MyBatis初始化阶段：MyBatis启动时运行一次，完成MyBatis运行环境的<strong>配置工作</strong></li>\n<li>数据读写阶段：由数据读写操作触发，完成增删改查请求</li>\n</ul>\n<h3 id=\"初始化阶段\"><a href=\"#初始化阶段\" class=\"headerlink\" title=\"初始化阶段\"></a>初始化阶段</h3><p>MyBatis的初始化在整个项目启动时开始执行，主要完成<strong>配置文件的解析</strong>、<strong>数据库的连接</strong>等操作</p>\n<h4 id=\"配置信息读取\"><a href=\"#配置信息读取\" class=\"headerlink\" title=\"配置信息读取\"></a>配置信息读取</h4><p>读取配置文件<code>mybatis-config.xml</code>得到<code>InputStream</code>，通过调用<code>SqlSessionFactoryBuilder</code>类的<code>build()</code>方法，生成<code>SqlSessionFactory</code>对象。</p>\n<p>演示用户代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSessionFactory sqlSessionFactory = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>SqlSessionFactoryBuilder</code>类的<code>build()</code>核心方法如下，方法内创建<code>XMLConfigBuilder</code>类并调用<code>parse()</code>方法解析<code>mybatis-config.xml</code>得到<code>configuration</code>对象，也就是记录MyBatis全部配置信息的全局配置对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        XMLConfigBuilder parser = <span class=\"keyword\">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> build(parser.parse());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error building SqlSession.\"</span>, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            inputStream.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面方法中实际创建 SqlSessionFactory 实例的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSessionFactory <span class=\"title\">build</span><span class=\"params\">(Configuration config)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultSqlSessionFactory(config);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>XMLConfigBuilder</code>类的<code>parse()</code>方法如下，解析过程固定，因此前文强调必须按顺序写<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Configuration <span class=\"title\">parse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parsed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Each XMLConfigBuilder can only be used once.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parsed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    parseConfiguration(parser.evalNode(<span class=\"string\">\"/configuration\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> configuration;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 核心解析方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">parseConfiguration</span><span class=\"params\">(XNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//issue #117 read properties first</span></span><br><span class=\"line\">        propertiesElement(root.evalNode(<span class=\"string\">\"properties\"</span>));</span><br><span class=\"line\">        Properties settings = settingsAsProperties(root.evalNode(<span class=\"string\">\"settings\"</span>));</span><br><span class=\"line\">        loadCustomVfs(settings);</span><br><span class=\"line\">        loadCustomLogImpl(settings);</span><br><span class=\"line\">        typeAliasesElement(root.evalNode(<span class=\"string\">\"typeAliases\"</span>));</span><br><span class=\"line\">        pluginElement(root.evalNode(<span class=\"string\">\"plugins\"</span>));</span><br><span class=\"line\">        objectFactoryElement(root.evalNode(<span class=\"string\">\"objectFactory\"</span>));</span><br><span class=\"line\">        objectWrapperFactoryElement(root.evalNode(<span class=\"string\">\"objectWrapperFactory\"</span>));</span><br><span class=\"line\">        reflectorFactoryElement(root.evalNode(<span class=\"string\">\"reflectorFactory\"</span>));</span><br><span class=\"line\">        settingsElement(settings);</span><br><span class=\"line\">        <span class=\"comment\">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class=\"line\">        environmentsElement(root.evalNode(<span class=\"string\">\"environments\"</span>));</span><br><span class=\"line\">        databaseIdProviderElement(root.evalNode(<span class=\"string\">\"databaseIdProvider\"</span>));</span><br><span class=\"line\">        typeHandlerElement(root.evalNode(<span class=\"string\">\"typeHandlers\"</span>));</span><br><span class=\"line\">        mapperElement(root.evalNode(<span class=\"string\">\"mappers\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BuilderException(<span class=\"string\">\"Error parsing SQL Mapper Configuration. Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSessionFactory</code>类是<code>SqlSessionFactory</code>接口的默认实现类，其中保存了<code>configuration</code>对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultSqlSessionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">SqlSessionFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Configuration configuration;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultSqlSessionFactory</span><span class=\"params\">(Configuration configuration)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configuration = configuration;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 核心方法之一，创建SqlSession对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SqlSession <span class=\"title\">openSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>SqlSessionFactory</code>对象是生产<code>SqlSession</code>对象的工厂，<code>SqlSession</code>对象是数据读写阶段的操作接口，详见下文</p>\n</blockquote>\n<h3 id=\"数据读写阶段\"><a href=\"#数据读写阶段\" class=\"headerlink\" title=\"数据读写阶段\"></a>数据读写阶段</h3><p>后续分析各个包的作用过程中，请<strong>牢牢记住本节的内容，把握主线，串联细节，融合贯通</strong></p>\n<h4 id=\"获取SqlSession对象\"><a href=\"#获取SqlSession对象\" class=\"headerlink\" title=\"获取SqlSession对象\"></a>获取SqlSession对象</h4><p>演示用户代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SqlSession session = sqlSessionFactory.openSession()</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSessionFactory</code>类中<code>openSession()</code>的具体实现如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 核心方法之一，创建SqlSession对象</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SqlSession <span class=\"title\">openSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> SqlSession <span class=\"title\">openSessionFromDataSource</span><span class=\"params\">(ExecutorType execType, TransactionIsolationLevel level,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            <span class=\"keyword\">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class=\"line\">    Transaction tx = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找出要使用的指定环境</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Environment environment = configuration.getEnvironment();</span><br><span class=\"line\">        <span class=\"comment\">// 从环境中获取事务工厂</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class=\"line\">        <span class=\"comment\">// 从事务工厂中生产事务</span></span><br><span class=\"line\">        tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class=\"line\">        <span class=\"comment\">// 创建执行器</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class=\"line\">        <span class=\"comment\">// 创建DefaultSqlSession对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        closeTransaction(tx); <span class=\"comment\">// may have fetched a connection so lets call close()</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error opening session.  Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSession</code>类是<code>SqlSession</code>接口的实现类，它提供了查询、增加、更新、删除、提交、回滚等大量的方法</p>\n<blockquote>\n<p><strong>注意</strong>: 数据读写阶段是在进行数据读写时触发的，但并不是每次读写都会触发<br>“SqlSession session=sqlSessionFactory.openSession()”操作<br>因为该操作得到的 DefaultSqlSession 对象可以供多次数据库读写操作复用</p>\n</blockquote>\n<h4 id=\"映射接口文件与映射文件的绑定\"><a href=\"#映射接口文件与映射文件的绑定\" class=\"headerlink\" title=\"映射接口文件与映射文件的绑定\"></a>映射接口文件与映射文件的绑定</h4><p>演示代码如下，通过调用<code>DefaultSqlSession</code>类的<code>getMapper(Class&lt;T&gt;)</code>方法获取<code>UserMapper</code>对象<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找到接口对应的实现</span></span><br><span class=\"line\">UserMapper userMapper = session.getMapper(UserMapper<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br></pre></td></tr></table></figure></p>\n<p><code>DefaultSqlSession</code>类的<code>getMapper(Class&lt;T&gt;)</code>方法经过<code>configuration</code>对象转交，最终到<code>MapperRegistry</code>类中的<code>getMapper(Class&lt;T&gt;, SqlSession)</code>方法</p>\n<p><code>MapperRegistry</code>类记录了配置文件中所有的映射文件路径，给定java类名后，<code>getMapper(Class&lt;T&gt;, SqlSession)</code>方法通过映射接口信息从所有已经解析的映射文件中找到对应的映射文件，然后根据该映射文件组建并返回接口的一个实现对象（代理对象）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getMapper</span><span class=\"params\">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 找出指定映射接口的代理工厂</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mapperProxyFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Type \"</span> + type + <span class=\"string\">\" is not known to the MapperRegistry.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过mapperProxyFactory给出对应代理器的实例</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Error getting mapper instance. Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"映射接口的代理\"><a href=\"#映射接口的代理\" class=\"headerlink\" title=\"映射接口的代理\"></a>映射接口的代理</h4><p>上文说到，<code>MapperRegistry</code>类的<code>getMapper</code>方法返回的是一个代理对象，其创建者实际上是<code>MapperProxyFactory</code>类，对应代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// getMapper调用的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">newInstance</span><span class=\"params\">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class=\"keyword\">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newInstance(mapperProxy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">newInstance</span><span class=\"params\">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 三个参数分别是：</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理对象的类加载器、要代理的接口、代理类的处理器（即具体的实现）。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class=\"keyword\">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代理对象本身为<code>MapperProxy</code>类，其实现了<code>InvocationHandler</code>接口，重载了<code>invoke()</code>函数，因此当出现<code>*Mapper</code>类中的方法被调用时，会通过该函数完成调用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Object<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">equals</span>(<span class=\"title\">method</span>.<span class=\"title\">getDeclaringClass</span>())) </span>&#123; <span class=\"comment\">// 继承自Object的方法</span></span><br><span class=\"line\">            <span class=\"comment\">// 直接执行原有方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.isDefault()) &#123; <span class=\"comment\">// 默认方法</span></span><br><span class=\"line\">            <span class=\"comment\">// 执行默认方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 找对对应的MapperMethod对象</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class=\"line\">    <span class=\"comment\">//** 调用MapperMethod中的execute方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的核心是<code>mapperMethod.execute(sqlSession, args)</code>，MyBatis将映射接口与<code>MapperProxy</code>对应，将映射接口中的抽象方法与<code>MapperMethod</code>对应，<code>MapperMethod</code>类中的<code>execute()</code>方法则根据语句类型重新调用<code>SqlSession</code>对象中的增删改查方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">execute</span><span class=\"params\">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    Object result;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (command.getType()) &#123; <span class=\"comment\">// 根据SQL语句类型，执行不同操作</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> INSERT: &#123; <span class=\"comment\">// 如果是插入语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> UPDATE: &#123; <span class=\"comment\">// 如果是更新语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> DELETE: &#123; <span class=\"comment\">// 如果是删除语句MappedStatement</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SELECT: <span class=\"comment\">// 如果是查询语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> FLUSH: <span class=\"comment\">// 清空缓存语句</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"comment\">// 未知语句类型，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Unknown execution method for: \"</span> + command.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 查询结果为null,但返回类型为基本类型。因此返回变量无法接收查询结果，抛出异常。</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BindingException(<span class=\"string\">\"Mapper method '\"</span> + command.getName()</span><br><span class=\"line\">            + <span class=\"string\">\" attempted to return null from a method with a primitive return type (\"</span> + method.getReturnType() + <span class=\"string\">\").\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>到这里，MyBatis已经完成了<strong>为映射接口注入实现</strong>的过程，对映射接口中抽象方法的调用转变为了<code>SqlSesion</code>类的方法调用</p>\n<h4 id=\"SQL-语句的查找\"><a href=\"#SQL-语句的查找\" class=\"headerlink\" title=\"SQL 语句的查找\"></a>SQL 语句的查找</h4><p><code>MapperMethod</code>类中的<code>execute()</code>方法中根据实际操作类型不同将控制权交给<code>SqlSession</code>类的不同方法</p>\n<p>以<code>selectList()</code>方法为例，具体过程都是先构建<code>MappedStatement</code>对象，然后交由<code>Executor</code>对象执行<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">selectList</span><span class=\"params\">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取查询语句</span></span><br><span class=\"line\">        MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class=\"line\">        <span class=\"comment\">// 交由执行器进行查询</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ExceptionFactory.wrapException(<span class=\"string\">\"Error querying database.  Cause: \"</span> + e, e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ErrorContext.instance().reset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查询结果缓存\"><a href=\"#查询结果缓存\" class=\"headerlink\" title=\"查询结果缓存\"></a>查询结果缓存</h4><p><code>Executor</code>是一个接口，有<code>BaseExecutor</code>类和<code>CachingExecutor</code>类两种实现，<code>CachingExecutor</code>类表示查询过程使用缓存，即可以将之前的查询结果缓存，避免一直访问数据库</p>\n<p>因此示例实际执行的代码是<code>CachingExecutor</code>类中的<code>query()</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">query</span><span class=\"params\">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class=\"line\">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>BoundSql</code>是经过层层转化后去除掉<code>if</code>、<code>where</code>等标签的 SQL 语句，而<code>CacheKey</code>是为该次查询操作计算出来的缓存键</p>\n<p>接下来，MyBatis查看当前的查询操作是否命中缓存，命中则从缓存中获取数据结果；否则通过<code>delegate</code>调用<code>query()</code>方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">query</span><span class=\"params\">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取MappedStatement对应的缓存，可能的结果有：该命名空间的缓存、共享的其它命名空间的缓存、无缓存</span></span><br><span class=\"line\">    Cache cache = ms.getCache();</span><br><span class=\"line\">    <span class=\"comment\">// 如果映射文件未设置&lt;cache&gt;或&lt;cache-ref&gt;则，此处cache变量为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 存在缓存</span></span><br><span class=\"line\">        <span class=\"comment\">// 根据要求判断语句执行前是否要清除二级缓存，如果需要，清除二级缓存</span></span><br><span class=\"line\">        flushCacheIfRequired(ms);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 该语句使用缓存且没有输出结果处理器</span></span><br><span class=\"line\">            <span class=\"comment\">// 二级缓存不支持含有输出参数的CALLABLE语句，故在这里进行判断</span></span><br><span class=\"line\">            ensureNoOutParams(ms, boundSql);</span><br><span class=\"line\">            <span class=\"comment\">// 从缓存中读取结果</span></span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// 缓存中没有结果</span></span><br><span class=\"line\">                <span class=\"comment\">// 交给被包装的执行器执行</span></span><br><span class=\"line\">                list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class=\"line\">                <span class=\"comment\">// 缓存被包装执行器返回的结果</span></span><br><span class=\"line\">                tcm.putObject(cache, key, list); <span class=\"comment\">// issue #578 and #116</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 交由被包装的实际执行器执行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数据库查询\"><a href=\"#数据库查询\" class=\"headerlink\" title=\"数据库查询\"></a>数据库查询</h4><p>整个流程的关键步骤如下：</p>\n<ul>\n<li>在进行数据库查询前，<strong>先查询缓存</strong>；如果确实需要查询数据库，则数据库查询之后的结果也放入缓存中</li>\n<li>SQL语句的执行经过了层层转化，依次经过了<code>MappedStatement</code>对象、<code>Statement</code>对象和<code>PreparedStatement</code>对象，最后才得以执行</li>\n<li>最终数据库查询得到的结果交给<code>ResultHandler</code>对象处理</li>\n</ul>\n<p><code>delegate</code>调用的<code>query()</code>方法实际流向<code>BaseExecutor</code>类中的<code>query()</code>方法，其中核心方法为<code>queryFromDatabase()</code>方法</p>\n<p><code>queryFromDatabase()</code>方法代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">queryFromDatabase</span><span class=\"params\">(MappedStatement ms, Object parameter, RowBounds rowBounds, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    List&lt;E&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">// 向缓存中增加占位符，表示正在查询</span></span><br><span class=\"line\">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除占位符</span></span><br><span class=\"line\">        localCache.removeObject(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将查询结果写入缓存</span></span><br><span class=\"line\">    localCache.putObject(key, list);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class=\"line\">        localOutputParameterCache.putObject(key, parameter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>MyBatis先在缓存中放置一个占位符，然后调用<code>doQuery()</code>方法实际执行查询操作，最后，又把缓存中的占位符替换成真正的查询结果</p>\n<p><code>doQuery()</code>方法是<code>BaseExecutor</code>类中的抽象方法，实际运行代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">doQuery</span><span class=\"params\">(MappedStatement ms, Object parameterObject, RowBounds rowBounds,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                        ResultHandler resultHandler, BoundSql boundSql)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    Statement stmt = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        flushStatements();</span><br><span class=\"line\">        Configuration configuration = ms.getConfiguration();</span><br><span class=\"line\">        StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, </span><br><span class=\"line\">                                        rowBounds, resultHandler, boundSql);</span><br><span class=\"line\">        Connection connection = getConnection(ms.getStatementLog());</span><br><span class=\"line\">        stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class=\"line\">        handler.parameterize(stmt);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handler.query(stmt, resultHandler);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        closeStatement(stmt);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>handler.query(stmt，resultHandler)</code>调用的是<code>StatementHandler</code>接口的抽象方法，实际调用了<code>PreparedStatementHandler</code>类的代码，如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;E&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">query</span><span class=\"params\">(Statement statement, ResultHandler resultHandler)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class=\"line\">    <span class=\"comment\">// 执行真正的查询，查询完成后，结果就在ps中了</span></span><br><span class=\"line\">    ps.execute();</span><br><span class=\"line\">    <span class=\"comment\">// 由resultSetHandler继续处理结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>查询完成之后的结果放在<code>PreparedStatement</code>对象中，交由<code>ResultSetHandler</code>对象处理</p>\n<h4 id=\"处理结果集\"><a href=\"#处理结果集\" class=\"headerlink\" title=\"处理结果集\"></a>处理结果集</h4><p>查询得到的结果并没有直接返回，而是交给<code>ResultSetHandler</code>对象处理</p>\n<p><code>ResultSetHandler</code>是结果集处理器接口，实现类是<code>DefaultResultSetHandler</code>，因此实际处理结果的是实现类中的<code>handleResultSets</code>方法</p>\n<p><code>handleResultSets</code>方法将查询出来的结果被遍历后放入了列表<code>multipleResults</code>中并返回，<code>multipleResults</code>中存储的就是这次查询期望的结果<code>List＜User＞</code></p>\n<p><code>handleResultSets</code>方法整个调用链很长，具体如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/mybatis/handleresultsets.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        handleResultSets方法调用链\n    </div>\n</center>\n\n<p>重点关注的是图中粗线边框标注的三个方法：</p>\n<ul>\n<li><strong>createResultObject</strong><code>(ResultSetWrapper, ResultMap, List&lt;Class&lt;?&gt;&gt;, List&lt;Object&gt;, String)</code>方法: 该方法创建了输出结果对象。在示例中，为<code>User</code>对象</li>\n<li><strong>applyAutomaticMappings</strong>方法: 在自动属性映射功能开启的情况下，该方法将数据记录的值赋给输出结果对象</li>\n<li><strong>applyPropertyMappings</strong>方法: 该方法按照用户的映射设置，给输出结果对象的属性赋值</li>\n</ul>\n<p>经过以上过程，MyBatis将数据库输出的记录转化为了对象列表。之后，以上方法逐级返回。</p>\n<p>最后，装载着对象列表的 <code>multipleResults</code> 被返回给<code>List&lt;User&gt; userList</code>变量，我们便拿到了查询结果<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = userMapper.queryUserBySchoolName(userParam);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"项目包结构\"><a href=\"#项目包结构\" class=\"headerlink\" title=\"项目包结构\"></a>项目包结构</h2><center>\n    <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/mybatis/packages.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n        MyBatis 项目包结构\n    </div>\n</center>\n\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《MyBatis源码详解——通用源码阅读指导书》</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckk6y1e2x00003a6w2zzn7o85","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e3r00073a6w4lpyat19"},{"post_id":"ckk6y1e3s00093a6w36me16r3","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e3v000c3a6w1becbjpw"},{"post_id":"ckk6y1e3500013a6wag7x5ncv","tag_id":"ckk6y1e3q00063a6we1504yqv","_id":"ckk6y1e3x000e3a6w9gu5gv5r"},{"post_id":"ckk6y1e3500013a6wag7x5ncv","tag_id":"ckk6y1e3t000a3a6wga0mh52l","_id":"ckk6y1e3x000f3a6w0zwj527y"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e41000j3a6wdl7y5hn8"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e41000k3a6wdv74e449"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e42000m3a6wdlgr2mc6"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e43000o3a6w4fc5bat8"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e43000p3a6w160dazad"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e44000r3a6w5xmldt4k"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e45000t3a6w5jotgfev"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e45000u3a6w52wx72g5"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e46000w3a6wflum7fbf"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e44000s3a6wh1s69ajs","_id":"ckk6y1e46000x3a6whuyo9sxi"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e47000y3a6w5by9222p"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e47000z3a6wf5ra7n5o"},{"post_id":"ckko43nia0000n26w9yf5eza0","tag_id":"ckk6y1e44000s3a6wh1s69ajs","_id":"ckko43niu0001n26wg0zgfylk"},{"post_id":"ckko43nia0000n26w9yf5eza0","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckko43niv0002n26wekwcb22c"},{"post_id":"ckko43nia0000n26w9yf5eza0","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckko43niv0003n26w26nc5kbi"},{"post_id":"ckkca6rbr0000w46wa4iverw0","tag_id":"ckk6y1e44000s3a6wh1s69ajs","_id":"ckko48d3o0000236whcwzb0mu"},{"post_id":"ckkca6rbr0000w46wa4iverw0","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckko48d3p0001236w4oyy8d5o"},{"post_id":"ckkca6rbr0000w46wa4iverw0","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckko48d3p0002236w4q1l3q1j"},{"post_id":"ckpt846kw0000lktp12jydz58","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckpt846l60002lktpb5y5ddc1"},{"post_id":"ckpt846l30001lktpdq4gcbnh","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckpt846lg0004lktp6ni9hzbm"},{"post_id":"ckpt846l30001lktpdq4gcbnh","tag_id":"ckpt846l70003lktp3dba6ju2","_id":"ckpt846lh0005lktp3mthes9u"},{"post_id":"ckpt847ja0006lktp8b1lg95x","tag_id":"ckpt847jg0007lktp8qfgcu8g","_id":"ckpt847jn0008lktpf323dgdm"},{"post_id":"ckpt847ja0006lktp8b1lg95x","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckpt847jq0009lktpgl3f49xz"},{"post_id":"ckpttxbzk0000gstpbdhr2wxl","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckpttxbzz0002gstpf1rn6bl1"},{"post_id":"ckpttxbzv0001gstp2r0tfy0k","tag_id":"ckpttxbzz0003gstp6j7p3zmf","_id":"ckptxn5hg0000s8tp12gvck6j"},{"post_id":"cl18v3i6h00004otp6fitb1qj","tag_id":"cl18v3i6t00014otp64mk1ake","_id":"cl18v3i7400024otp6jyecxbm"},{"post_id":"cl18v3i6h00004otp6fitb1qj","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"cl18v3i7400034otpeh3uhbmi"},{"post_id":"cl1aejytb0000g0tp84ergwts","tag_id":"cl18v3i6t00014otp64mk1ake","_id":"cl1aejyti0001g0tp3wmr1kdp"},{"post_id":"cl1aejytb0000g0tp84ergwts","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"cl1aejyti0002g0tpexmqaohj"},{"post_id":"cl1bv8yw00000aktpa2p28h64","tag_id":"cl18v3i6t00014otp64mk1ake","_id":"cl1bv8ywq0001aktphldaaedx"},{"post_id":"cl1bv8yw00000aktpa2p28h64","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"cl1bv8ywq0002aktp9i7v9kcn"},{"post_id":"cl1cbxlx3000034tp35kf9ylm","tag_id":"cl18v3i6t00014otp64mk1ake","_id":"cl1cbxlxk000134tp0k4k2nu5"},{"post_id":"cl1cbxlx3000034tp35kf9ylm","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"cl1cbxlxk000234tp2kaganmi"},{"post_id":"cl1d78r540000l4tpdu6nh90a","tag_id":"cl18v3i6t00014otp64mk1ake","_id":"cl1d78r5l0001l4tpgc3bezim"},{"post_id":"cl1d78r540000l4tpdu6nh90a","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"cl1d78r5l0002l4tp01z67s07"},{"post_id":"cl1hkg2as0000vctpe4xk5kbr","tag_id":"cl18v3i6t00014otp64mk1ake","_id":"cl1hm2vj4000czgtp5qrh3hy1"},{"post_id":"cl1hkg2as0000vctpe4xk5kbr","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"cl1hm2vj4000dzgtp6rqh12en"},{"post_id":"cl8bil9gg00006wvr56i8fbxw","tag_id":"cl8bbjzy1000174vrhpynh897","_id":"cl8bil9gl00016wvr3ldtb5uc"},{"post_id":"cl8bil9gg00006wvr56i8fbxw","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"cl8bimndx0000akvr6tfv6yue"}],"Tag":[{"name":"笔记","_id":"ckk6y1e3l00023a6w6b6x1r3h"},{"name":"config","_id":"ckk6y1e3q00063a6we1504yqv"},{"name":"教程","_id":"ckk6y1e3t000a3a6wga0mh52l"},{"name":"c++","_id":"ckk6y1e3v000d3a6wcpcp2rv3"},{"name":"intern","_id":"ckk6y1e3x000g3a6w6iz3hyjm"},{"name":"Database","_id":"ckk6y1e44000s3a6wh1s69ajs"},{"name":"makefile","_id":"ckpt846l70003lktp3dba6ju2"},{"name":"Spring","_id":"ckpt847jg0007lktp8qfgcu8g"},{"name":"设计模式","_id":"ckpttxbzz0003gstp6j7p3zmf"},{"name":"Java","_id":"cl18v3i6t00014otp64mk1ake"},{"name":"MyBatis","_id":"cl8bbjzy1000174vrhpynh897"}]}}