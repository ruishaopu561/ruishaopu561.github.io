{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Butterfly/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1611198006684},{"_id":"themes/Butterfly/README.md","hash":"8e4d01331f9a820ec30fca075c6956859772530e","modified":1611198006684},{"_id":"themes/Butterfly/README_CN.md","hash":"4fd3e96f5c18f721118c175c807e19ae874a7793","modified":1611198006684},{"_id":"themes/Butterfly/_config.yml","hash":"2814fb85d7d7cdd7f26134fc95d5dec0fff4a75b","modified":1611416439475},{"_id":"themes/Butterfly/package.json","hash":"43a92e039fe98e01259dc84ee4066b5d5efb8e7f","modified":1611198006740},{"_id":"source/_posts/GAMES101-学习笔记.md","hash":"58086fd150891d398954b2455a1784ea601ae8ec","modified":1611198006680},{"_id":"source/_posts/Hexo-Github.md","hash":"12d25cf807f8fd8289b160a1be69251b5fdc38fe","modified":1611198006680},{"_id":"source/_posts/c++基础-1.md","hash":"570ebf38b848a7a7b6dae7e8255301f14b15f093","modified":1612244752440},{"_id":"source/_posts/c++基础-2.md","hash":"548d17454e3e6c14a3de912128a0fcf69c26f5e1","modified":1611238985496},{"_id":"source/_posts/c++基础-3.md","hash":"03d1746742b06e6416bbf54e2f3c16a0cbce457e","modified":1611238992120},{"_id":"source/_posts/hello-world.md","hash":"951d6d2b455faae8e17dd454bf658de7f91ccc15","modified":1611198006684},{"_id":"source/_posts/unity-shader学习记录.md","hash":"0ee009ec9da7d70421629f66734a923704eab2b0","modified":1611198006684},{"_id":"source/_posts/数据库基础-1.md","hash":"8c0c1e3107ef353a159d2bbedc37f2a20352d877","modified":1612277463962},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE.md","hash":"bc427d7f13fec05cfd2dcc10953cbb2a96bc31be","modified":1611198006684},{"_id":"themes/Butterfly/.github/stale.yml","hash":"cd5a929ce25a6293a9f449e7b80dfe4307326797","modified":1611198006684},{"_id":"themes/Butterfly/languages/default.yml","hash":"8cc398208ebd0326d0bdac09cf96b8aeeed78fcc","modified":1611198006684},{"_id":"themes/Butterfly/languages/en.yml","hash":"8cc398208ebd0326d0bdac09cf96b8aeeed78fcc","modified":1611198006684},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"848871887cc5ea38c50292df7f7c9d9dbb07b5ca","modified":1611198006684},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"6dc0abceee6a1c4b47d3ecdae81667ffb4a09f88","modified":1611198006684},{"_id":"themes/Butterfly/layout/404.pug","hash":"3ade9903e1e0dedfb11b46d7161f2100defba31e","modified":1611198006700},{"_id":"themes/Butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1611198006700},{"_id":"themes/Butterfly/layout/category.pug","hash":"d014234c26d2c07caaea6703f7b48cb69c51907d","modified":1611198006700},{"_id":"themes/Butterfly/layout/flink.pug","hash":"f922cafc12857cff327d6621ea5517976e85c229","modified":1611198006700},{"_id":"themes/Butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1611198006740},{"_id":"themes/Butterfly/layout/page.pug","hash":"130ab657a6acfe149dbc59e481dc05d4d7d926a3","modified":1611198006740},{"_id":"themes/Butterfly/layout/post.pug","hash":"2e34fd65d36508faec9fd015d6cdb108d4c29b58","modified":1611198006740},{"_id":"themes/Butterfly/layout/tag.pug","hash":"3bb2a700c6d709d2757d55d357eed1fca5644e24","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"5265bfbd6514fde10b42f5f5482776450e2bd582","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"855c5d7e427730178c2f6e4f3e816d7fbee40198","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"901122c065cb08589a52911773d9baf01c599faa","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"055747cdb64b27ac707402481e79c82ce946b0d3","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"385a186f0e77900db685b97d40bb4d26fa48a4d5","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"9ba725c0f9661a156f82dee35a422fdd4639a5ce","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"b41c97424c588209c0d24817f5120b50933135fd","modified":1611198006712},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1611198006740},{"_id":"themes/Butterfly/scripts/events/replace_config.js","hash":"537e556e76760ce2103f359d5a424c6e2b9a0710","modified":1611198006740},{"_id":"themes/Butterfly/scripts/filters/post_lazyload.js","hash":"4c7f4562183f28acb359b7e826eb0a198086e3f0","modified":1611198006740},{"_id":"themes/Butterfly/scripts/filters/random_cover.js","hash":"0b4775aaa955b75f03648fc1957fb88a6d440803","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/aside_archives.js","hash":"87c63d5b46fdc13724d5d213cdfde608af6a5bb3","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/aside_categories.js","hash":"21c89a1502e9964cb48d32ab0476427cc41b010d","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/page.js","hash":"729a9f40c5bf603036f6e9443db93b1704cf17d9","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/related_post.js","hash":"7ebe4dc2b42094a5b55799c0af5c28d6ab97d25f","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/gallery.js","hash":"2fad0a9e6645613631aad36dc3473fe8e032809b","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/hide.js","hash":"8c70135d5367b9a589ec92be66841488e9acdd29","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/mermaid.js","hash":"53eaff19d8da32e04e2c871300ea495356d633cd","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/note.js","hash":"c739846637c48b4779df2f62effb78e15100fd9f","modified":1611198006740},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1611198006744},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1611198006744},{"_id":"themes/Butterfly/source/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611198006744},{"_id":"themes/Butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1611198006744},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611198006744},{"_id":"themes/Butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1611198006744},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1611198006744},{"_id":"themes/Butterfly/source/css/index.styl","hash":"96eb343f77fc891ff5adedb1f4a3fb34ab4ee20f","modified":1611198006744},{"_id":"themes/Butterfly/source/css/var.styl","hash":"907b5ee1d5cb44ebb90493b068c00bef068ef748","modified":1611198006744},{"_id":"themes/Butterfly/source/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1611198006744},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1611198006744},{"_id":"themes/Butterfly/source/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1611198006748},{"_id":"themes/Butterfly/layout/includes/comments/disqus.pug","hash":"821d968122bab8ce1ce04dc553b731eaf8e0d181","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/disqusjs.pug","hash":"050085054a68942e8833c6a4033fb437b6b01e52","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/facebook_comments.pug","hash":"7b7bb7d2b39b639cc8e1edf1274148460796662e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/gitalk.pug","hash":"e98f5c199a76ad939a29a46c0dcbf7e85ec60ed2","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/index.pug","hash":"f9556b40b00d5a566c64904afa833aa2e0d9449d","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/laibili.pug","hash":"00022f763085b6852bc172b0ba91b0eacb403389","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/utterances.pug","hash":"9427cb07bcfe2bc7198755eeebf60f9fe430a342","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/valine.pug","hash":"4f6e49639896bc8a4d4fe2257502f98ab63f6a7d","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"6ba5794cffb47cfd2727e388b7cd7370c43e3559","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"8ec0609f14c284c3e6120940d7c4d7f1f201cd67","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/comment.pug","hash":"7de136bdce45afa81341b13e61b7a3926e15f03b","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"dd7cd1b3b20873044e0c0ed1280001a0e06ea358","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"2c7a5a097a2f815ba43a4e99c810405da3b9eebc","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/darkmode.pug","hash":"dcc8c01e1b0f8a4960ed873f49fb0f18d9912d21","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/dns_prefetch.pug","hash":"d2f81fadc68532cd27db8895c1834cdefb7e577e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"ff4ceda534cdd711cfa2cb9e95e36258988674e1","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"47a10164395d8200c8d962df68a01e7deee4053b","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"be1ff710e4381fc684243313dcadf0140d7469de","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"f5c8ec73c797ff3455e732fa7c92c856692f3ce5","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/subtitle.pug","hash":"bbdb2280a74cd7b573b8e03e1c2b44c37571ad22","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/header.pug","hash":"0b50e70efa91519e3ba7fa7a55e9603f33a8e6eb","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"e612fe17bbd8cb39772e9dac54df3fcd1da99ba6","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"addeb5765ab0635c665dcca99f7918561131ae09","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"9c50171335c65533af09a1c11648860b59be3299","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0d684f897fcdfe1e98300851b7fd955a30b68dd9","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/loading/loading-js.pug","hash":"3cf431a4f04997b55873f7099c1402155b19cc95","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/index.pug","hash":"ec97f284626b67208370b5084e5c5822844fa30a","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/katex.pug","hash":"73356f1068c7426597e268d6c4aefa2b0ac3a1d9","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/mathjax.pug","hash":"6ccfaa776fc913ccf8b34825d918ab2b4d457434","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/mermaid.pug","hash":"db848ff451d4c58670af415882ca6bb2e0da971b","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"53cd1b89dc4bc45c315a2f54bfce9d6c3a695f27","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mixins/post-ui.pug","hash":"40108322ce7f5b5ac52765ca39901fa2c00348d6","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/index.pug","hash":"d12fab033fb32b55abbc9be9b04cc6ab6465b98e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"b7f1b9ff32ea868965e5dbb533c0117ce195663f","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"8efc0b7886bdb5959e173b5e11f5ffb8d1c5230e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"6612174871d833981f1a4a4ec67bc0fbd6913fd8","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/search/local-search.pug","hash":"a45b5453e35479e58cd44b6bd2af0e08789890af","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/share/addtoany.pug","hash":"bbf5b70460b17c4fecb9ee6880aa71cdb2d807a8","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/share/index.pug","hash":"c341aaa00113681b22f945f5004e6b22c8a0ca69","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/share/share-js.pug","hash":"828a04c6e8e3a56c3c7f3c9bb1ecf4f99ed842fe","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"b4acf48c98ba2a6a5a5fb5387a0fd610bdfd55ef","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"3f7de99f4307ac9bfd89e669aaa7c2ae54d5224a","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"2e940de1a6261fd378e16e4cd3362a9d69c12f50","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"edf9658dbb95c964e4c6d60bd71d1dc7ebfbb0ac","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"8274404ec2f83f1ba6439d42e8a4e29e932067ac","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"56d27e39fa050a4d311d92b572ce291d7618026a","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"9fe3e264236835cfb6a91f54ee96bb3a79e36539","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"07eebb9d024feba44a2c66e04aef19151df8991c","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"c0309c49a92c1176f008ad322f86a8a19031b41e","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"6caff3cb958ccb0da7d88b51d87e22d27fcd9625","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"15fb3730f829e237c102a70ab9781178471fd786","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"d9d19c2f5dbe671815b6048ff40b876e02d0fd7b","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"4a61f436cd9a44a3bb4259549b05adf72cd941d7","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"efceb8105830544cef5e4afad3243326b3118fc1","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"964d16c30f307ec354b47375aa5f00f0417c7bf0","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"aeadbc2b3a057ab11f409b584d8c39c1d72ed0e7","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/category.styl","hash":"7267043e52a9e620adfa860bdb3e4de400ff2596","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/flink.styl","hash":"0631c50cdccd29ca41fbac3423b2fd91a9be49b8","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"d8709e29efcfa0a7356384026dfbaac8861d3baa","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"a23ff8c52bfc581a741158c75f3d4923c4cdf810","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/loadding.styl","hash":"144ef01b03ae34d3ede4b9aa18f4c8cd3d6651ea","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/mobile-sidebar.styl","hash":"5492d68c1c9bb85898d41b357f695d6fb17ec646","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/page.styl","hash":"970bd971b06411be85146c97ca30884ff3847910","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"d6f0b7d9dc10761c15a5a2b84cc63e914a10d339","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"e20057cc5a065078cb57821a63595ef9a0c36648","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"1103f2cead8ab1aa9945c20c7d608bb4b829d2cd","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"92b615795f02eff2a018edb425f923968c9e9814","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"9a44881bd4c2aea0b0774809d91d58e4067496ed","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"33da3da65715ce1a85b8ecab92e0eab6ce620a58","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"0fcfeef99c0bef8d48be9180b6fed5aace55acba","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"fa20ccacd51b0c87f4a9ae107bb20b629d5953ab","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"919f0a869203a03ca783dd3fc9df1aeb229de2c2","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"641ef2bc7af135c17fd90f3f974e78ebbaf1ac13","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"e31b475cbac2af8d3401fba6382d34968c8063ef","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"da791f46239eabbbf28eb30b9e441f1ac2a8ced1","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_tags/gallery.styl","hash":"d6af5c4f1966b5b575427c117712c173e23657ad","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_tags/hide.styl","hash":"a1de1df9f3cff44bcee7822107ec1e51d9a1b0b1","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_tags/note.styl","hash":"1ec06d5ac4148798babd2475a5d10f0d3a1b5870","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1611198006744},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1611198006744},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1611198006744},{"_id":"public/2021/01/21/数据库基础-1/index.html","hash":"9f60571362399acfc6e1dc91355bcf3cda83967e","modified":1612277468575},{"_id":"public/2021/01/20/c++基础-3/index.html","hash":"8d81e888ff5099923feb0ff84b95d22fffb468cd","modified":1612277004959},{"_id":"public/2021/01/20/c++基础-2/index.html","hash":"ab7d0a845edd5729d9cbcb2db9c526fcd3a1a606","modified":1612277004959},{"_id":"public/2021/01/20/c++基础-1/index.html","hash":"d125167e027a86bb5cad4b0517f5830d4a8b599a","modified":1612277004959},{"_id":"public/2020/06/19/GAMES101-学习笔记/index.html","hash":"39bf1d7b3d96d0c05f5560a8547631cfeae74806","modified":1612277004959},{"_id":"public/2020/06/16/unity-shader学习记录/index.html","hash":"b5b83e9ba9858465f78d8e517e7a4fcd2cf0ea04","modified":1612277004959},{"_id":"public/2020/06/12/Hexo-Github/index.html","hash":"f2f7c6e21a8d920b8ab438bbd6b1b2a31435ae69","modified":1612277004959},{"_id":"public/2020/06/12/hello-world/index.html","hash":"e01cfc7f983ae1443240435db95d500b4427d3b2","modified":1612277004959},{"_id":"public/archives/index.html","hash":"0adc9b3158233b7bf9799a0636d5d26b77fbe403","modified":1612277468575},{"_id":"public/archives/2020/index.html","hash":"5116a6ef9b08fc31bbe2a3cc493fa2aeb1c8eb28","modified":1612277468575},{"_id":"public/archives/2020/06/index.html","hash":"8ac9c5741399cafee11be5558a8c64fbcaecfb66","modified":1612277468575},{"_id":"public/archives/2021/index.html","hash":"d9f4fbc6024eca18dd79e0c1297960f85bfe322b","modified":1612277468575},{"_id":"public/archives/2021/01/index.html","hash":"45b321d74b3db66dadbd5b76332cb9cb67cca9ea","modified":1612277468575},{"_id":"public/index.html","hash":"be4a361b3345c3e947627bff7c9122e900101107","modified":1612277468575},{"_id":"public/tags/笔记/index.html","hash":"c9b5b988d499c279bb84c144a292b1199a5ade16","modified":1612277468575},{"_id":"public/tags/config/index.html","hash":"b93abdd914b8bee89b319bba413be62f90410ec9","modified":1612277468575},{"_id":"public/tags/教程/index.html","hash":"445f87684e0a4543890ca8a0e180b9c422517245","modified":1612277468575},{"_id":"public/tags/c/index.html","hash":"a07c102579ffd0aeb857d6b78dc6041f097d10e3","modified":1612277468575},{"_id":"public/tags/intern/index.html","hash":"cde29c8be53586e41ed697eeb11f94469ede3929","modified":1612277468575},{"_id":"public/tags/Database/index.html","hash":"801dd4f8179c4b07af74d513c2ed43507c1beda0","modified":1612277468575},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1611238894689},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1611238894689},{"_id":"public/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611238894689},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1611238894689},{"_id":"public/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611238894689},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1611238894689},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1611238894689},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1611238894689},{"_id":"public/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1611238894689},{"_id":"public/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1611238894689},{"_id":"public/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1611238894689},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1611238894689},{"_id":"public/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1611238894689},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1611238894689},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1611238894689},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1611238894689},{"_id":"public/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1611238894689},{"_id":"public/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1611238894689},{"_id":"public/css/index.css","hash":"817ba8be5bdd463183cbd107504640ecb21ca02d","modified":1611238894689},{"_id":"public/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1611238894689},{"_id":"public/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1611238894689},{"_id":"themes/Butterfly/layout/_layout.swig","hash":"e69985f2fad6d9d9292e54fa5a6adb19c8d84d45","modified":1611414457424},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.eslintrc","hash":"9274e9ce5a031fc936330eb0aa35653b03e5c1bc","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.gitignore","hash":"082286dac7149a87a9b5073a562bb0661a6a78df","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.travis.yml","hash":"0f3c18d294110f9a27aeff0ebe7023bb07ad52f8","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/README.md","hash":"055903e391b19d4eceaf220f57e3a5ac6764e389","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/package.json","hash":"0da94ab339e666fb97fa9d0344603704f1045a51","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.github/ISSUE_TEMPLATE.md","hash":"24938de1141e8f26b6a2241f232b3e25129ac2e2","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/demo/demo.js","hash":"91511c265365b2d0b3e5fec44eed699ae5e35476","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/demo/index.html","hash":"05f752644aeb1a1d82ab113f76328eff0599f324","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/music.js","hash":"9fcf661ba67c3f932b9eb13261ab1e93a259b93c","modified":1611414312660},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/CNAME","hash":"5b5021c61cf084dc192c225d2532dba17d765d5a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/README.md","hash":"57fa2f31c725b96a287152b05c9e69ee185eef6a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/config.js","hash":"03ea6f8a9ee71aacca6ca30360951526f97e39de","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/ecosystem.md","hash":"9d51d4e6e6290d15cbf8c3444559a7c808f7e8dd","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/index.html","hash":"97fdf9b2508a04722b1544808ef5cbae7a02ef67","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/support.md","hash":"41424289691882abf0f61e51d4455059034a12d1","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/dev.config.js","hash":"f4c5ca8858374d7d457d4d20994b1e3c7151c19b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/postcss.config.js","hash":"b319d7a602418969bc434d16ae1476f781b1e758","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/prod.config.js","hash":"4e5e59d35c811165766664e5c75e7514e9628048","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/README.md","hash":"9d9945caa066db6235549c7c04577a0236bb1592","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/ecosystem.md","hash":"f279d4d931ab54ee30757750c4ea8abe7789a32f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/support.md","hash":"24818a7cd01332b244a36b48fb3953afc2e7bdf3","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/css/index.scss","hash":"8bf2b70ad24911997890528cadaa08ea385b8b24","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/bar.js","hash":"74a16047fc0da8486a33de6cf3ecc881b2568988","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/controller.js","hash":"3c911f91bbefa7ecba08f1ccccc1cc6b40c500d0","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/events.js","hash":"f9bbe87494ec4a43daadc1ecd39c8a0541f4e434","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/index.js","hash":"b06b620244638433bf0e7015b932bca02e3db19c","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/list.js","hash":"126cf10a75251627862d1effb86f3992deddfe5b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/lrc.js","hash":"3a550a5d506ef4fb0ece608853f73542f37542ba","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/options.js","hash":"a69e3f87d68466ce97588e43c4745f0192b843b1","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/player.js","hash":"6df7fa9653982d95e0f82974ccfc69a25f6953ba","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/storage.js","hash":"820619bc8d78de4d430ffb866e740b51cdd780c6","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/template.js","hash":"5846a37ee44ef0eaca4376b98149e78bfaac4b67","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/timer.js","hash":"05ccc546427a055712ddbf8e0136ffb6b9f9f33c","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/utils.js","hash":"c1c4eba6d261c132beed0cdd073e0adc65ed9a9f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/player.art","hash":"eda981e8ed56d6d7bc81182e969f4766869b2662","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/yarn.lock","hash":"5fe4573f0f6aaad024a40503520848f63cba1257","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1522338206000},{"_id":"public/APlayer-1.10.1/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/CNAME","hash":"5b5021c61cf084dc192c225d2532dba17d765d5a","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/css/index.scss","hash":"8bf2b70ad24911997890528cadaa08ea385b8b24","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/player.art","hash":"eda981e8ed56d6d7bc81182e969f4766869b2662","modified":1611414505367},{"_id":"public/APlayer-1.10.1/package.json","hash":"f711b300f93d6fafef0d69e379e124ce91c38769","modified":1611414505367},{"_id":"public/APlayer-1.10.1/demo/demo.js","hash":"91511c265365b2d0b3e5fec44eed699ae5e35476","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/music.js","hash":"9fcf661ba67c3f932b9eb13261ab1e93a259b93c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/config.js","hash":"03ea6f8a9ee71aacca6ca30360951526f97e39de","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/dev.config.js","hash":"f4c5ca8858374d7d457d4d20994b1e3c7151c19b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/postcss.config.js","hash":"b319d7a602418969bc434d16ae1476f781b1e758","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/prod.config.js","hash":"4e5e59d35c811165766664e5c75e7514e9628048","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/bar.js","hash":"74a16047fc0da8486a33de6cf3ecc881b2568988","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/controller.js","hash":"3c911f91bbefa7ecba08f1ccccc1cc6b40c500d0","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/events.js","hash":"f9bbe87494ec4a43daadc1ecd39c8a0541f4e434","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/index.js","hash":"b06b620244638433bf0e7015b932bca02e3db19c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/list.js","hash":"126cf10a75251627862d1effb86f3992deddfe5b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/lrc.js","hash":"3a550a5d506ef4fb0ece608853f73542f37542ba","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/options.js","hash":"a69e3f87d68466ce97588e43c4745f0192b843b1","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/player.js","hash":"6df7fa9653982d95e0f82974ccfc69a25f6953ba","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/storage.js","hash":"820619bc8d78de4d430ffb866e740b51cdd780c6","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/template.js","hash":"5846a37ee44ef0eaca4376b98149e78bfaac4b67","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/timer.js","hash":"05ccc546427a055712ddbf8e0136ffb6b9f9f33c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/utils.js","hash":"c1c4eba6d261c132beed0cdd073e0adc65ed9a9f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/README.html","hash":"d4a83e323a294d8b05e89d5251c667f5808c4931","modified":1611414505367},{"_id":"public/APlayer-1.10.1/demo/index.html","hash":"efc650972f5415453c25d48fdf40afbe35256602","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/ecosystem.html","hash":"62798ead4a2a974c856f2779cff2e3f20e314e20","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/index.html","hash":"1cfe6294406deaea3b3b78a9a5ff9ec5f58ae96d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/support.html","hash":"61ea2536908b167d20deb1849820e3462d8d6176","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/ecosystem.html","hash":"69ea6483810741c04359a2573ad47764f7e2aad4","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/support.html","hash":"a2268752ed7678a3cfbc59e7555ad352c13db872","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/README.html","hash":"54cac2cd9a05a02d5bc392f4274534e91dc5a39c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/README.html","hash":"5ab4ebe380e311c888793479a3b87929b85dad4d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1611414505367},{"_id":"public/APlayer-1.10.1/yarn.lock","hash":"5fe4573f0f6aaad024a40503520848f63cba1257","modified":1611414505367},{"_id":"source/tags/index.md","hash":"c2ab47b114eb7cd934eddfc3f3a4bbe44e9739c0","modified":1611415953608},{"_id":"public/tags/index.html","hash":"0e990dafcd91821217e7e2d50248c69c33761936","modified":1612277468575},{"_id":"source/_posts/数据库基础-2.md","hash":"43deed0c385227eb1cd95e6e0b480fde285e65de","modified":1612277229558},{"_id":"public/2021/01/24/数据库基础-2/index.html","hash":"dba7416ee4d40515ffff32932a9a0b864c9092e8","modified":1612277318571},{"_id":"source/_posts/数据库基础-3.md","hash":"f5998fb8600729ceac3916192cbd674d9001a166","modified":1612277309382},{"_id":"public/2021/02/02/数据库基础-3/index.html","hash":"5778fa3f07b99d24d2bd4acdf4702d422d7d577b","modified":1612277318571},{"_id":"public/archives/2021/02/index.html","hash":"747c0f83a73afca0153795610e5af9c0e7ad80a8","modified":1612277468575}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2021-01-23T15:27:35.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-01-23 23:27:35\ntype: tags\nlayout: tags\n---\n","updated":"2021-01-23T15:32:33.608Z","path":"tags/index.html","_id":"ckk9vex080000g26wf4mf8ihy","comments":1,"content":"","site":{"data":{}},"cover":"https://i.imgur.com/RRUe0Mo.png","excerpt":"","more":""}],"Post":[{"title":"GAMES101_学习笔记","date":"2020-06-19T13:45:43.000Z","top_img":"/img/cover/games101.webp","cover":"/img/cover/games101.webp","mathjax":true,"_content":"\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","source":"_posts/GAMES101-学习笔记.md","raw":"---\ntitle: GAMES101_学习笔记\ndate: 2020-06-19 21:45:43\ntop_img: /img/cover/games101.webp\ncover: /img/cover/games101.webp\ntags: 笔记\nmathjax: true\n---\n\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","slug":"GAMES101-学习笔记","published":1,"updated":"2021-01-21T03:00:06.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e2x00003a6w2zzn7o85","content":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M<em>{persp-&gt;ortho}*M</em>{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u<em>0 = lerp(s, u</em>{00}, u_{10})$</li>\n<li>$u<em>1 = lerp(s, u</em>{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p<em>0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p</em>{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p<em>0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum</em>{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\ b_1 \\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\ S_1 \\cdot S \\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\  E_2 = p_2 - p_0 \\ S = O-p_0 \\ S_1=D \\times E_2 \\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\ 0 \\le b_1 \\le 1 \\ 0 \\le b_2 \\le 1 \\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L<em>r(p, \\omega_r) = \\int</em>{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L<em>o(p,\\omega_o) = L_e(p, \\omega_o) + \\int</em>{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L<em>i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum</em>{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F<em>{Schlick} = C</em>{spec} + (1-C<em>{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C</em>{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x<em>{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’</em>{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y<em>{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t</em>{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\ k_2 \\ k_3 \\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M<em>{persp-&gt;ortho}*M</em>{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u<em>0 = lerp(s, u</em>{00}, u_{10})$</li>\n<li>$u<em>1 = lerp(s, u</em>{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p<em>0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p</em>{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p<em>0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum</em>{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\ b_1 \\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\ S_1 \\cdot S \\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\  E_2 = p_2 - p_0 \\ S = O-p_0 \\ S_1=D \\times E_2 \\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\ 0 \\le b_1 \\le 1 \\ 0 \\le b_2 \\le 1 \\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L<em>r(p, \\omega_r) = \\int</em>{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L<em>o(p,\\omega_o) = L_e(p, \\omega_o) + \\int</em>{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L<em>i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum</em>{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F<em>{Schlick} = C</em>{spec} + (1-C<em>{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C</em>{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x<em>{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’</em>{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y<em>{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t</em>{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\ k_2 \\ k_3 \\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo + Github","date":"2020-06-12T14:11:13.000Z","top_img":"/img/cover/hexo_github.png","cover":"/img/cover/hexo_github.png","description":"配置个人专属博客网站，采坑小结","_content":"这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","source":"_posts/Hexo-Github.md","raw":"---\ntitle: Hexo + Github\ndate: 2020-06-12 22:11:13\ntop_img: /img/cover/hexo_github.png\ncover: /img/cover/hexo_github.png\ndescription: 配置个人专属博客网站，采坑小结\ntags: \n  - config\n  - 教程\n---\n这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","slug":"Hexo-Github","published":1,"updated":"2021-01-21T03:00:06.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3500013a6wag7x5ncv","content":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>"},{"title":"c++ 基础(1)","date":"2021-01-20T06:51:34.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### struct和class的区别\n在C++中，可以用`struct`和`class`定义类，都可以继承。区别在于：\n`struct`的默认继承权限和默认访问权限是**public**，而`class`的默认继承权限和默认访问权限是**private**。\n\n另外，`class`还可以定义模板类形参，比如\n```c++\ntemplate <class T, int i>\n```\n\n### static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","source":"_posts/c++基础-1.md","raw":"---\ntitle: c++ 基础(1)\ndate: 2021-01-20 14:51:34\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### struct和class的区别\n在C++中，可以用`struct`和`class`定义类，都可以继承。区别在于：\n`struct`的默认继承权限和默认访问权限是**public**，而`class`的默认继承权限和默认访问权限是**private**。\n\n另外，`class`还可以定义模板类形参，比如\n```c++\ntemplate <class T, int i>\n```\n\n### static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","slug":"c++基础-1","published":1,"updated":"2021-02-02T05:45:52.440Z","_id":"ckk6y1e3n00033a6w6rm5b4e1","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"struct和class的区别\"><a href=\"#struct和class的区别\" class=\"headerlink\" title=\"struct和class的区别\"></a>struct和class的区别</h3><p>在C++中，可以用<code>struct</code>和<code>class</code>定义类，都可以继承。区别在于：<br><code>struct</code>的默认继承权限和默认访问权限是<strong>public</strong>，而<code>class</code>的默认继承权限和默认访问权限是<strong>private</strong>。</p>\n<p>另外，<code>class</code>还可以定义模板类形参，比如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">int</span> <span class=\"title\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"static关键字的作用\"><a href=\"#static关键字的作用\" class=\"headerlink\" title=\"static关键字的作用\"></a>static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"struct和class的区别\"><a href=\"#struct和class的区别\" class=\"headerlink\" title=\"struct和class的区别\"></a>struct和class的区别</h3><p>在C++中，可以用<code>struct</code>和<code>class</code>定义类，都可以继承。区别在于：<br><code>struct</code>的默认继承权限和默认访问权限是<strong>public</strong>，而<code>class</code>的默认继承权限和默认访问权限是<strong>private</strong>。</p>\n<p>另外，<code>class</code>还可以定义模板类形参，比如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">int</span> <span class=\"title\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"static关键字的作用\"><a href=\"#static关键字的作用\" class=\"headerlink\" title=\"static关键字的作用\"></a>static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要在头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n"},{"title":"c++ 基础(2)","date":"2021-01-20T08:46:15.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","source":"_posts/c++基础-2.md","raw":"---\ntitle: c++ 基础(2)\ndate: 2021-01-20 16:46:15\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","slug":"c++基础-2","published":1,"updated":"2021-01-21T14:23:05.496Z","_id":"ckk6y1e3o00043a6w03n32plb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n"},{"title":"c++ 基础(3)","date":"2021-01-20T14:00:05.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（3）\n### 右值引用\n#### 左值和右值\n根据《C++ Primer》的说法，左值和右值可以这样区分：\n\n> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如\n```c++\nint foo(42);\nint bar;\n\n// 将 foo 的值赋给 bar，保存在 bar 对应的内存中\n// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值\n// 但是 foo 作为对象，既可以充当左值又可以充当右值\nbar = foo;\n```\n\n因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即\n\n+ 在大多数情况下，需要右值的地方可以用左值来替代，但\n+ 需要左值的地方，一定不能用右值来替代。\n\n又有一个重要的特点，即\n\n+ 左值存放在对象中，有持久的状态；而\n+ 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。\n\n#### 常量左值引用\n常量左值引用，即const的左值引用。\n\n右值只能绑定到右值引用上，左值引用不能绑定右值，例如：\n```c++\nint i = 42;\nint &&rr = i;     // ERR: i 是左值\nint &r = i * 2;   // ERR: i * 2 是右值\n```\n\n但是常量左值引用可以绑定右值：\n```c++\nint i = 42;\nconst int &r = i * 42;  // OK: 可以将 const 引用绑定到右值上\n```\n\n可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 `int &r = 42` 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：\n```c++\n// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么\ndouble dval = 3.14;\nconst int &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 先将双精度浮点数变成一个整型常量\nconst int &ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上\n```\n\n这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。\n\n我们再来看看如果 ri 不是常量引用会发生什么：\n```c++\ndouble dval = 3.14; \nint &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 还是先将双精度浮点数变成一个整型常量\nint &ri = tmp;          // 再让这个普通引用和 tmp 绑定\n```\n\n可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：\n\n+ tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。\n+ 就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。\n\n于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。\n\n通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。\n\n同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。\n\n#### 左值引用和右值引用\n在 C++ 中，有两种对对象的引用：左值引用和右值引用。\n\n左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。\n\n```c++\n// lvalue-reference\nint foo(42);\nint& bar = foo;  // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起\nint& baz = 42;   // Err: 42 是右值，不能将它绑定在左值引用上\nconst int& qux = 42;  // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上\n```\n右值引用也是引用，但是它只能且必须绑定在右值上。\n\n```c++\n// rvalue-reference\nint foo(42);\nint& bar = foo;        // OK: 将 foo 绑定在左值引用上\nint&& baz = foo;       // Err: foo 可以是左值，所以不能将它绑定在右值引用上\nint&& qux = 42;        // OK: 将右值 42 绑定在右值引用上\nint&& quux = foo * 1;  // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上\nint& garply = foo++;   // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上\nint&& waldo = foo--;   // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上\n```\n\n由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：\n\n+ 右值引用的对象，是临时的，即将被销毁；并且\n+ 右值引用的对象，不会在其它地方使用。\n\n> 敲黑板：这是重点！\n\n这两个特性意味着：**接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏**。\n\n需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：\n```c++\nint &&rr1 = 42;   // OK: 字面量是右值\nint &&rr2 = rr1;  // ERR: rr1 是变量，虽然它是右值引用，但仍然是左值\n```\n\n#### 右值的作用\n##### 标准库 move 函数\n虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：\n```c++\nint&& rr1 = 42;                 // 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值\nint&& rr2 = std::move(rr1);     // 使用 std::move() 而不是 move()\n```\n\n需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。\n\n##### 移动构造函数\n有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。\n\n和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。\n\n详见\n\n##### 移动赋值运算符\n移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：\n```c++\nMyString& Mystring::operator=(MyString&& rhs) noexcept {\n  if (this != &rhs) {\n    if (string) free(string);  // 先将原有资源释放\n    string = rhs.string;\n    rhs.string = nullptr;\n  }\n  return *this;\n}\n```\n只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。\n\n#### 转发\n转发与 std::forward 的内容详见[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。\n\n## 参考链接\n[struct和class的区别](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[C++ 引用、移动、转发 (一)](https://guodong.plus/2020/0307-190855/)\n[C++ 引用、移动、转发 (二)](https://guodong.plus/2020/0311-225314/)\n[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)\n[谈谈c++中的右值引用](https://liam.page/2016/12/11/rvalue-reference-in-Cpp/)","source":"_posts/c++基础-3.md","raw":"---\ntitle: c++ 基础(3)\ndate: 2021-01-20 22:00:05\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（3）\n### 右值引用\n#### 左值和右值\n根据《C++ Primer》的说法，左值和右值可以这样区分：\n\n> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如\n```c++\nint foo(42);\nint bar;\n\n// 将 foo 的值赋给 bar，保存在 bar 对应的内存中\n// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值\n// 但是 foo 作为对象，既可以充当左值又可以充当右值\nbar = foo;\n```\n\n因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即\n\n+ 在大多数情况下，需要右值的地方可以用左值来替代，但\n+ 需要左值的地方，一定不能用右值来替代。\n\n又有一个重要的特点，即\n\n+ 左值存放在对象中，有持久的状态；而\n+ 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。\n\n#### 常量左值引用\n常量左值引用，即const的左值引用。\n\n右值只能绑定到右值引用上，左值引用不能绑定右值，例如：\n```c++\nint i = 42;\nint &&rr = i;     // ERR: i 是左值\nint &r = i * 2;   // ERR: i * 2 是右值\n```\n\n但是常量左值引用可以绑定右值：\n```c++\nint i = 42;\nconst int &r = i * 42;  // OK: 可以将 const 引用绑定到右值上\n```\n\n可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 `int &r = 42` 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：\n```c++\n// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么\ndouble dval = 3.14;\nconst int &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 先将双精度浮点数变成一个整型常量\nconst int &ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上\n```\n\n这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。\n\n我们再来看看如果 ri 不是常量引用会发生什么：\n```c++\ndouble dval = 3.14; \nint &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 还是先将双精度浮点数变成一个整型常量\nint &ri = tmp;          // 再让这个普通引用和 tmp 绑定\n```\n\n可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：\n\n+ tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。\n+ 就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。\n\n于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。\n\n通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。\n\n同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。\n\n#### 左值引用和右值引用\n在 C++ 中，有两种对对象的引用：左值引用和右值引用。\n\n左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。\n\n```c++\n// lvalue-reference\nint foo(42);\nint& bar = foo;  // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起\nint& baz = 42;   // Err: 42 是右值，不能将它绑定在左值引用上\nconst int& qux = 42;  // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上\n```\n右值引用也是引用，但是它只能且必须绑定在右值上。\n\n```c++\n// rvalue-reference\nint foo(42);\nint& bar = foo;        // OK: 将 foo 绑定在左值引用上\nint&& baz = foo;       // Err: foo 可以是左值，所以不能将它绑定在右值引用上\nint&& qux = 42;        // OK: 将右值 42 绑定在右值引用上\nint&& quux = foo * 1;  // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上\nint& garply = foo++;   // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上\nint&& waldo = foo--;   // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上\n```\n\n由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：\n\n+ 右值引用的对象，是临时的，即将被销毁；并且\n+ 右值引用的对象，不会在其它地方使用。\n\n> 敲黑板：这是重点！\n\n这两个特性意味着：**接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏**。\n\n需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：\n```c++\nint &&rr1 = 42;   // OK: 字面量是右值\nint &&rr2 = rr1;  // ERR: rr1 是变量，虽然它是右值引用，但仍然是左值\n```\n\n#### 右值的作用\n##### 标准库 move 函数\n虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：\n```c++\nint&& rr1 = 42;                 // 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值\nint&& rr2 = std::move(rr1);     // 使用 std::move() 而不是 move()\n```\n\n需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。\n\n##### 移动构造函数\n有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。\n\n和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。\n\n详见\n\n##### 移动赋值运算符\n移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：\n```c++\nMyString& Mystring::operator=(MyString&& rhs) noexcept {\n  if (this != &rhs) {\n    if (string) free(string);  // 先将原有资源释放\n    string = rhs.string;\n    rhs.string = nullptr;\n  }\n  return *this;\n}\n```\n只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。\n\n#### 转发\n转发与 std::forward 的内容详见[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。\n\n## 参考链接\n[struct和class的区别](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[C++ 引用、移动、转发 (一)](https://guodong.plus/2020/0307-190855/)\n[C++ 引用、移动、转发 (二)](https://guodong.plus/2020/0311-225314/)\n[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)\n[谈谈c++中的右值引用](https://liam.page/2016/12/11/rvalue-reference-in-Cpp/)","slug":"c++基础-3","published":1,"updated":"2021-01-21T14:23:12.120Z","_id":"ckk6y1e3p00053a6w57ht8r87","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（3）\"><a href=\"#C-基础知识（3）\" class=\"headerlink\" title=\"C++ 基础知识（3）\"></a>C++ 基础知识（3）</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><h4 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h4><p>根据《C++ Primer》的说法，左值和右值可以这样区分：</p>\n<blockquote>\n<p>一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 的值赋给 bar，保存在 bar 对应的内存中</span></span><br><span class=\"line\"><span class=\"comment\">// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值</span></span><br><span class=\"line\"><span class=\"comment\">// 但是 foo 作为对象，既可以充当左值又可以充当右值</span></span><br><span class=\"line\">bar = foo;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即</p>\n<ul>\n<li>在大多数情况下，需要右值的地方可以用左值来替代，但</li>\n<li>需要左值的地方，一定不能用右值来替代。</li>\n</ul>\n<p>又有一个重要的特点，即</p>\n<ul>\n<li>左值存放在对象中，有持久的状态；而</li>\n<li>右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。</li>\n</ul>\n<h4 id=\"常量左值引用\"><a href=\"#常量左值引用\" class=\"headerlink\" title=\"常量左值引用\"></a>常量左值引用</h4><p>常量左值引用，即const的左值引用。</p>\n<p>右值只能绑定到右值引用上，左值引用不能绑定右值，例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i;     <span class=\"comment\">// ERR: i 是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">2</span>;   <span class=\"comment\">// ERR: i * 2 是右值</span></span><br></pre></td></tr></table></figure></p>\n<p>但是常量左值引用可以绑定右值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 可以将 const 引用绑定到右值上</span></span><br></pre></td></tr></table></figure></p>\n<p>可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 <code>int &amp;r = 42</code> 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = tmp;    <span class=\"comment\">// 让常量引用 ri 绑定到这个临时变量上</span></span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。</p>\n<p>我们再来看看如果 ri 不是常量引用会发生什么：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>; </span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 还是先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = tmp;          <span class=\"comment\">// 再让这个普通引用和 tmp 绑定</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：</p>\n<ul>\n<li>tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。</li>\n<li>就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。</li>\n</ul>\n<p>于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。</p>\n<p>通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。</p>\n<p>同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。</p>\n<h4 id=\"左值引用和右值引用\"><a href=\"#左值引用和右值引用\" class=\"headerlink\" title=\"左值引用和右值引用\"></a>左值引用和右值引用</h4><p>在 C++ 中，有两种对对象的引用：左值引用和右值引用。</p>\n<p>左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;  <span class=\"comment\">// OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; baz = <span class=\"number\">42</span>;   <span class=\"comment\">// Err: 42 是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; qux = <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上</span></span><br></pre></td></tr></table></figure>\n<p>右值引用也是引用，但是它只能且必须绑定在右值上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;        <span class=\"comment\">// OK: 将 foo 绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; baz = foo;       <span class=\"comment\">// Err: foo 可以是左值，所以不能将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; qux = <span class=\"number\">42</span>;        <span class=\"comment\">// OK: 将右值 42 绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; quux = foo * <span class=\"number\">1</span>;  <span class=\"comment\">// OK: foo * 1 的结果是一个右值，将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; garply = foo++;   <span class=\"comment\">// Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; waldo = foo--;   <span class=\"comment\">// OK: 后置自减运算符返回的是右值，将它绑定在右值引用上</span></span><br></pre></td></tr></table></figure>\n<p>由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：</p>\n<ul>\n<li>右值引用的对象，是临时的，即将被销毁；并且</li>\n<li>右值引用的对象，不会在其它地方使用。</li>\n</ul>\n<blockquote>\n<p>敲黑板：这是重点！</p>\n</blockquote>\n<p>这两个特性意味着：<strong>接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏</strong>。</p>\n<p>需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">// OK: 字面量是右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;  <span class=\"comment\">// ERR: rr1 是变量，虽然它是右值引用，但仍然是左值</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"右值的作用\"><a href=\"#右值的作用\" class=\"headerlink\" title=\"右值的作用\"></a>右值的作用</h4><h5 id=\"标准库-move-函数\"><a href=\"#标准库-move-函数\" class=\"headerlink\" title=\"标准库 move 函数\"></a>标准库 move 函数</h5><p>虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr1 = <span class=\"number\">42</span>;                 <span class=\"comment\">// 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr2 = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(rr1);     <span class=\"comment\">// 使用 std::move() 而不是 move()</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。</p>\n<h5 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h5><p>有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。</p>\n<p>和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。</p>\n<p>详见</p>\n<h5 id=\"移动赋值运算符\"><a href=\"#移动赋值运算符\" class=\"headerlink\" title=\"移动赋值运算符\"></a>移动赋值运算符</h5><p>移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyString&amp; Mystring::<span class=\"keyword\">operator</span>=(MyString&amp;&amp; rhs) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>) <span class=\"built_in\">free</span>(<span class=\"built_in\">string</span>);  <span class=\"comment\">// 先将原有资源释放</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> = rhs.<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    rhs.<span class=\"built_in\">string</span> = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。</p>\n<h4 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h4><p>转发与 std::forward 的内容详见<a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a>，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">struct和class的区别</a><br><a href=\"https://guodong.plus/2020/0307-190855/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (一)</a><br><a href=\"https://guodong.plus/2020/0311-225314/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (二)</a><br><a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a><br><a href=\"https://liam.page/2016/12/11/rvalue-reference-in-Cpp/\" target=\"_blank\" rel=\"noopener\">谈谈c++中的右值引用</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（3）\"><a href=\"#C-基础知识（3）\" class=\"headerlink\" title=\"C++ 基础知识（3）\"></a>C++ 基础知识（3）</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><h4 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h4><p>根据《C++ Primer》的说法，左值和右值可以这样区分：</p>\n<blockquote>\n<p>一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 的值赋给 bar，保存在 bar 对应的内存中</span></span><br><span class=\"line\"><span class=\"comment\">// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值</span></span><br><span class=\"line\"><span class=\"comment\">// 但是 foo 作为对象，既可以充当左值又可以充当右值</span></span><br><span class=\"line\">bar = foo;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即</p>\n<ul>\n<li>在大多数情况下，需要右值的地方可以用左值来替代，但</li>\n<li>需要左值的地方，一定不能用右值来替代。</li>\n</ul>\n<p>又有一个重要的特点，即</p>\n<ul>\n<li>左值存放在对象中，有持久的状态；而</li>\n<li>右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。</li>\n</ul>\n<h4 id=\"常量左值引用\"><a href=\"#常量左值引用\" class=\"headerlink\" title=\"常量左值引用\"></a>常量左值引用</h4><p>常量左值引用，即const的左值引用。</p>\n<p>右值只能绑定到右值引用上，左值引用不能绑定右值，例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i;     <span class=\"comment\">// ERR: i 是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">2</span>;   <span class=\"comment\">// ERR: i * 2 是右值</span></span><br></pre></td></tr></table></figure></p>\n<p>但是常量左值引用可以绑定右值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 可以将 const 引用绑定到右值上</span></span><br></pre></td></tr></table></figure></p>\n<p>可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 <code>int &amp;r = 42</code> 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = tmp;    <span class=\"comment\">// 让常量引用 ri 绑定到这个临时变量上</span></span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。</p>\n<p>我们再来看看如果 ri 不是常量引用会发生什么：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>; </span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 还是先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = tmp;          <span class=\"comment\">// 再让这个普通引用和 tmp 绑定</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：</p>\n<ul>\n<li>tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。</li>\n<li>就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。</li>\n</ul>\n<p>于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。</p>\n<p>通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。</p>\n<p>同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。</p>\n<h4 id=\"左值引用和右值引用\"><a href=\"#左值引用和右值引用\" class=\"headerlink\" title=\"左值引用和右值引用\"></a>左值引用和右值引用</h4><p>在 C++ 中，有两种对对象的引用：左值引用和右值引用。</p>\n<p>左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;  <span class=\"comment\">// OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; baz = <span class=\"number\">42</span>;   <span class=\"comment\">// Err: 42 是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; qux = <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上</span></span><br></pre></td></tr></table></figure>\n<p>右值引用也是引用，但是它只能且必须绑定在右值上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;        <span class=\"comment\">// OK: 将 foo 绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; baz = foo;       <span class=\"comment\">// Err: foo 可以是左值，所以不能将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; qux = <span class=\"number\">42</span>;        <span class=\"comment\">// OK: 将右值 42 绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; quux = foo * <span class=\"number\">1</span>;  <span class=\"comment\">// OK: foo * 1 的结果是一个右值，将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; garply = foo++;   <span class=\"comment\">// Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; waldo = foo--;   <span class=\"comment\">// OK: 后置自减运算符返回的是右值，将它绑定在右值引用上</span></span><br></pre></td></tr></table></figure>\n<p>由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：</p>\n<ul>\n<li>右值引用的对象，是临时的，即将被销毁；并且</li>\n<li>右值引用的对象，不会在其它地方使用。</li>\n</ul>\n<blockquote>\n<p>敲黑板：这是重点！</p>\n</blockquote>\n<p>这两个特性意味着：<strong>接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏</strong>。</p>\n<p>需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">// OK: 字面量是右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;  <span class=\"comment\">// ERR: rr1 是变量，虽然它是右值引用，但仍然是左值</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"右值的作用\"><a href=\"#右值的作用\" class=\"headerlink\" title=\"右值的作用\"></a>右值的作用</h4><h5 id=\"标准库-move-函数\"><a href=\"#标准库-move-函数\" class=\"headerlink\" title=\"标准库 move 函数\"></a>标准库 move 函数</h5><p>虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr1 = <span class=\"number\">42</span>;                 <span class=\"comment\">// 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr2 = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(rr1);     <span class=\"comment\">// 使用 std::move() 而不是 move()</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。</p>\n<h5 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h5><p>有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。</p>\n<p>和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。</p>\n<p>详见</p>\n<h5 id=\"移动赋值运算符\"><a href=\"#移动赋值运算符\" class=\"headerlink\" title=\"移动赋值运算符\"></a>移动赋值运算符</h5><p>移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyString&amp; Mystring::<span class=\"keyword\">operator</span>=(MyString&amp;&amp; rhs) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>) <span class=\"built_in\">free</span>(<span class=\"built_in\">string</span>);  <span class=\"comment\">// 先将原有资源释放</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> = rhs.<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    rhs.<span class=\"built_in\">string</span> = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。</p>\n<h4 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h4><p>转发与 std::forward 的内容详见<a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a>，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">struct和class的区别</a><br><a href=\"https://guodong.plus/2020/0307-190855/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (一)</a><br><a href=\"https://guodong.plus/2020/0311-225314/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (二)</a><br><a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a><br><a href=\"https://liam.page/2016/12/11/rvalue-reference-in-Cpp/\" target=\"_blank\" rel=\"noopener\">谈谈c++中的右值引用</a></p>\n"},{"title":"Hello World","date":"2020-06-12T08:46:15.000Z","top_img":"/img/cover/helloworld.png","cover":"/img/cover/helloworld.png","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2020-06-12 16:46:15\ntop_img: /img/cover/helloworld.png\ncover: /img/cover/helloworld.png\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2021-01-21T03:00:06.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3r00083a6wcazw9ebi","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"unity-shader学习记录","date":"2020-06-16T15:05:44.000Z","top_img":"/img/cover/shader.jpg","cover":"/img/cover/shader.jpg","_content":"\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","source":"_posts/unity-shader学习记录.md","raw":"---\ntitle: unity-shader学习记录\ndate: 2020-06-16 23:05:44\ntop_img: /img/cover/shader.jpg\ncover: /img/cover/shader.jpg\ntags: 笔记\n---\n\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","slug":"unity-shader学习记录","published":1,"updated":"2021-01-21T03:00:06.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3s00093a6w36me16r3","content":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n"},{"title":"数据库基础-1","date":"2021-01-21T11:50:55.000Z","top_img":"/img/cover/database.jpg","cover":"/img/cover/database.jpg","_content":"\n## 数据库基础知识（1）\n### 事务\n数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。\n\n#### 原子性(Atomicity)\n原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。\n\n#### 一致性(Consistency)\n一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。\n\n当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。\n\n#### 隔离性(Isolation)\n隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。\n\n隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n1. 脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。\n2. 不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。\n3. 幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。\n\nSQL 标准定义了四个隔离级别：\n1. **读取未提交**(Read Uncommited)\n    + 最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致**脏读、幻读或不可重复读**。\n2. **读取已提交**(Read Commited)\n    + 事务智能读取到其他事务已提交的修改。**可以阻止脏读，但不能阻止幻读和不可重复读**。\n3. **可重复读**(Repeatable Read)\n    + 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但不能阻止幻读**。\n4. **串行化**(Serializable)\n    + 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别**可以防止脏读、不可重复读以及幻读**。\n\n#### 持久性(Durability)\n持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 范式\n1. 第一范式(1NF)：无重复的列。\n    在关系模型中，对于添加的一个规范要求，**所有的域都应该是原子性**的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。\n2. 第二范式(2NF)：属性完全依赖于主键\n    第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。\n3. 第三范式(3NF)：任何非主属性不依赖于其它非主属性\n    第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。\n4. BCNF：主属性不能对主键子集依赖\n    巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。\n\n### 索引\n#### 索引的工作原理\n**数据库索引**，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。\n\n在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。\n\n+ 索引的优点：\n    1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n    2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\n    3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。\n    4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。\n    5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，**提高系统的性能**。\n\n+ 索引的缺点：\n    1. **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加。\n    2. 索引需要**占物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。\n    3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。\n\n+ 推荐建立索引的列：\n    1. 在**经常需要搜索**的列上，可以加快搜索的速度；\n    2. 在**作为主键**的列上，强制该列的唯一性和组织表中数据的排列结构；\n    3. 在**经常用在连接**的列上，这些列主要是一些外键，可以加快连接的速度；\n    4. 在**经常需要根据范围进行搜索**的列上创建索引，因为索引已经排序，其指定的范围是连续的；\n    5. 在**经常需要排序**的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；\n    6. 在**经常在 where 子句中使用**的列上面创建索引，加快条件的判断速度。\n\n+ 不应该创建索引的的列：\n    1. 对于那些**在查询中很少使用或者参考的列**不应该创建索引\n        这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。\n    2. 对于那些**只有很少数据值的列**也不应该增加索引\n        这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。\n    3. 对于那些**定义为 text, image 和 bit 数据类型的列**不应该增加索引\n        这是因为，这些列的数据量要么相当大，要么取值很少。\n    4. 当**修改性能远远大于检索性能时**，不应该创建索引\n        这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。\n\n#### 索引结构——B+树与B-树\nMySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。\n\n先简单介绍一下B-树和B+树的结构以及区别。\n\nB-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。\n\n而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。\n\n再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。\n\n而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。\n\n由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。\n\n#### 索引的种类\n根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。\n\n1. 唯一索引\n    唯一索引是不允许其中任何两行具有相同索引值的索引。\n    当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓\n\n2. 主键索引\n    数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。\n    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。\n\n3. 聚集索引\n    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。\n\n##### 聚簇索引与非聚簇索引\n索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n详细可见[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab)\n[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)\n[数据库范式解析](https://blog.csdn.net/GarfieldEr007/article/details/54319026)\n[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n[为什么Mongodb索引用B树，而Mysql用B+树](https://my.oschina.net/u/4365362/blog/4523180)","source":"_posts/数据库基础-1.md","raw":"---\ntitle: 数据库基础-1\ndate: 2021-01-21 19:50:55\ntop_img: /img/cover/database.jpg\ncover: /img/cover/database.jpg\ntags: [Database, intern, 笔记]\n---\n\n## 数据库基础知识（1）\n### 事务\n数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。\n\n#### 原子性(Atomicity)\n原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。\n\n#### 一致性(Consistency)\n一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。\n\n当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。\n\n#### 隔离性(Isolation)\n隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。\n\n隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n1. 脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。\n2. 不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。\n3. 幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。\n\nSQL 标准定义了四个隔离级别：\n1. **读取未提交**(Read Uncommited)\n    + 最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致**脏读、幻读或不可重复读**。\n2. **读取已提交**(Read Commited)\n    + 事务智能读取到其他事务已提交的修改。**可以阻止脏读，但不能阻止幻读和不可重复读**。\n3. **可重复读**(Repeatable Read)\n    + 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但不能阻止幻读**。\n4. **串行化**(Serializable)\n    + 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别**可以防止脏读、不可重复读以及幻读**。\n\n#### 持久性(Durability)\n持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 范式\n1. 第一范式(1NF)：无重复的列。\n    在关系模型中，对于添加的一个规范要求，**所有的域都应该是原子性**的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。\n2. 第二范式(2NF)：属性完全依赖于主键\n    第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。\n3. 第三范式(3NF)：任何非主属性不依赖于其它非主属性\n    第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。\n4. BCNF：主属性不能对主键子集依赖\n    巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。\n\n### 索引\n#### 索引的工作原理\n**数据库索引**，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。\n\n在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。\n\n+ 索引的优点：\n    1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n    2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\n    3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。\n    4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。\n    5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，**提高系统的性能**。\n\n+ 索引的缺点：\n    1. **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加。\n    2. 索引需要**占物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。\n    3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。\n\n+ 推荐建立索引的列：\n    1. 在**经常需要搜索**的列上，可以加快搜索的速度；\n    2. 在**作为主键**的列上，强制该列的唯一性和组织表中数据的排列结构；\n    3. 在**经常用在连接**的列上，这些列主要是一些外键，可以加快连接的速度；\n    4. 在**经常需要根据范围进行搜索**的列上创建索引，因为索引已经排序，其指定的范围是连续的；\n    5. 在**经常需要排序**的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；\n    6. 在**经常在 where 子句中使用**的列上面创建索引，加快条件的判断速度。\n\n+ 不应该创建索引的的列：\n    1. 对于那些**在查询中很少使用或者参考的列**不应该创建索引\n        这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。\n    2. 对于那些**只有很少数据值的列**也不应该增加索引\n        这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。\n    3. 对于那些**定义为 text, image 和 bit 数据类型的列**不应该增加索引\n        这是因为，这些列的数据量要么相当大，要么取值很少。\n    4. 当**修改性能远远大于检索性能时**，不应该创建索引\n        这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。\n\n#### 索引结构——B+树与B-树\nMySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。\n\n先简单介绍一下B-树和B+树的结构以及区别。\n\nB-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。\n\n而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。\n\n再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。\n\n而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。\n\n由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。\n\n#### 索引的种类\n根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。\n\n1. 唯一索引\n    唯一索引是不允许其中任何两行具有相同索引值的索引。\n    当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓\n\n2. 主键索引\n    数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。\n    在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。\n\n3. 聚集索引\n    在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。\n\n##### 聚簇索引与非聚簇索引\n索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。\n\n详细可见[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab)\n[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)\n[数据库范式解析](https://blog.csdn.net/GarfieldEr007/article/details/54319026)\n[聚集索引和非聚集索引的区别](https://juejin.cn/post/6844903845554814983)\n[为什么Mongodb索引用B树，而Mysql用B+树](https://my.oschina.net/u/4365362/blog/4523180)","slug":"数据库基础-1","published":1,"updated":"2021-02-02T14:51:03.962Z","_id":"ckk6y1e3u000b3a6w8cmy0sm7","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"数据库基础知识（1）\"><a href=\"#数据库基础知识（1）\" class=\"headerlink\" title=\"数据库基础知识（1）\"></a>数据库基础知识（1）</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。</p>\n<h4 id=\"原子性-Atomicity\"><a href=\"#原子性-Atomicity\" class=\"headerlink\" title=\"原子性(Atomicity)\"></a>原子性(Atomicity)</h4><p>原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。</p>\n<h4 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h4><p>一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。</p>\n<p>当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。</p>\n<h4 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h4><p>隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。</p>\n<p>隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ol>\n<li>脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。</li>\n<li>不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。</li>\n<li>幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。</li>\n</ol>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ol>\n<li><strong>读取未提交</strong>(Read Uncommited)<ul>\n<li>最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致<strong>脏读、幻读或不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>读取已提交</strong>(Read Commited)<ul>\n<li>事务智能读取到其他事务已提交的修改。<strong>可以阻止脏读，但不能阻止幻读和不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>(Repeatable Read)<ul>\n<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但不能阻止幻读</strong>。</li>\n</ul>\n</li>\n<li><strong>串行化</strong>(Serializable)<ul>\n<li>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h4><p>持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h3 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h3><ol>\n<li>第一范式(1NF)：无重复的列。<br> 在关系模型中，对于添加的一个规范要求，<strong>所有的域都应该是原子性</strong>的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。</li>\n<li>第二范式(2NF)：属性完全依赖于主键<br> 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。</li>\n<li>第三范式(3NF)：任何非主属性不依赖于其它非主属性<br> 第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</li>\n<li>BCNF：主属性不能对主键子集依赖<br> 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。</li>\n</ol>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"索引的工作原理\"><a href=\"#索引的工作原理\" class=\"headerlink\" title=\"索引的工作原理\"></a>索引的工作原理</h4><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>\n<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>\n<ul>\n<li><p>索引的优点：</p>\n<ol>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>\n<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>\n<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，<strong>提高系统的性能</strong>。</li>\n</ol>\n</li>\n<li><p>索引的缺点：</p>\n<ol>\n<li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加。</li>\n<li>索引需要<strong>占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>\n</ol>\n</li>\n<li><p>推荐建立索引的列：</p>\n<ol>\n<li>在<strong>经常需要搜索</strong>的列上，可以加快搜索的速度；</li>\n<li>在<strong>作为主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</li>\n<li>在<strong>经常用在连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</li>\n<li>在<strong>经常需要根据范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>\n<li>在<strong>经常需要排序</strong>的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>\n<li>在<strong>经常在 where 子句中使用</strong>的列上面创建索引，加快条件的判断速度。</li>\n</ol>\n</li>\n<li><p>不应该创建索引的的列：</p>\n<ol>\n<li>对于那些<strong>在查询中很少使用或者参考的列</strong>不应该创建索引<br> 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>\n<li>对于那些<strong>只有很少数据值的列</strong>也不应该增加索引<br> 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>\n<li>对于那些<strong>定义为 text, image 和 bit 数据类型的列</strong>不应该增加索引<br> 这是因为，这些列的数据量要么相当大，要么取值很少。</li>\n<li>当<strong>修改性能远远大于检索性能时</strong>，不应该创建索引<br> 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"索引结构——B-树与B-树\"><a href=\"#索引结构——B-树与B-树\" class=\"headerlink\" title=\"索引结构——B+树与B-树\"></a>索引结构——B+树与B-树</h4><p>MySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。</p>\n<p>先简单介绍一下B-树和B+树的结构以及区别。</p>\n<p>B-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。</p>\n<p>而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。</p>\n<p>再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。</p>\n<p>而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。</p>\n<p>由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。</p>\n<h4 id=\"索引的种类\"><a href=\"#索引的种类\" class=\"headerlink\" title=\"索引的种类\"></a>索引的种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p>\n<ol>\n<li><p>唯一索引<br> 唯一索引是不允许其中任何两行具有相同索引值的索引。<br> 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓</p>\n</li>\n<li><p>主键索引<br> 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。<br> 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>\n</li>\n<li><p>聚集索引<br> 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>\n</li>\n</ol>\n<h5 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h5><p>索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>\n<p>详细可见<a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://zhuanlan.zhihu.com/p/23624390\" target=\"_blank\" rel=\"noopener\">深入浅出数据库索引原理</a><br><a href=\"https://blog.csdn.net/GarfieldEr007/article/details/54319026\" target=\"_blank\" rel=\"noopener\">数据库范式解析</a><br><a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a><br><a href=\"https://my.oschina.net/u/4365362/blog/4523180\" target=\"_blank\" rel=\"noopener\">为什么Mongodb索引用B树，而Mysql用B+树</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据库基础知识（1）\"><a href=\"#数据库基础知识（1）\" class=\"headerlink\" title=\"数据库基础知识（1）\"></a>数据库基础知识（1）</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。</p>\n<h4 id=\"原子性-Atomicity\"><a href=\"#原子性-Atomicity\" class=\"headerlink\" title=\"原子性(Atomicity)\"></a>原子性(Atomicity)</h4><p>原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。</p>\n<h4 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h4><p>一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。</p>\n<p>当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。</p>\n<h4 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h4><p>隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。</p>\n<p>隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ol>\n<li>脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。</li>\n<li>不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。</li>\n<li>幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。</li>\n</ol>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ol>\n<li><strong>读取未提交</strong>(Read Uncommited)<ul>\n<li>最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致<strong>脏读、幻读或不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>读取已提交</strong>(Read Commited)<ul>\n<li>事务智能读取到其他事务已提交的修改。<strong>可以阻止脏读，但不能阻止幻读和不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>(Repeatable Read)<ul>\n<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但不能阻止幻读</strong>。</li>\n</ul>\n</li>\n<li><strong>串行化</strong>(Serializable)<ul>\n<li>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h4><p>持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h3 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h3><ol>\n<li>第一范式(1NF)：无重复的列。<br> 在关系模型中，对于添加的一个规范要求，<strong>所有的域都应该是原子性</strong>的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。</li>\n<li>第二范式(2NF)：属性完全依赖于主键<br> 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。</li>\n<li>第三范式(3NF)：任何非主属性不依赖于其它非主属性<br> 第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</li>\n<li>BCNF：主属性不能对主键子集依赖<br> 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。</li>\n</ol>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"索引的工作原理\"><a href=\"#索引的工作原理\" class=\"headerlink\" title=\"索引的工作原理\"></a>索引的工作原理</h4><p><strong>数据库索引</strong>，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>\n<p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>\n<ul>\n<li><p>索引的优点：</p>\n<ol>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>\n<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>\n<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，<strong>提高系统的性能</strong>。</li>\n</ol>\n</li>\n<li><p>索引的缺点：</p>\n<ol>\n<li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加。</li>\n<li>索引需要<strong>占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>\n</ol>\n</li>\n<li><p>推荐建立索引的列：</p>\n<ol>\n<li>在<strong>经常需要搜索</strong>的列上，可以加快搜索的速度；</li>\n<li>在<strong>作为主键</strong>的列上，强制该列的唯一性和组织表中数据的排列结构；</li>\n<li>在<strong>经常用在连接</strong>的列上，这些列主要是一些外键，可以加快连接的速度；</li>\n<li>在<strong>经常需要根据范围进行搜索</strong>的列上创建索引，因为索引已经排序，其指定的范围是连续的；</li>\n<li>在<strong>经常需要排序</strong>的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li>\n<li>在<strong>经常在 where 子句中使用</strong>的列上面创建索引，加快条件的判断速度。</li>\n</ol>\n</li>\n<li><p>不应该创建索引的的列：</p>\n<ol>\n<li>对于那些<strong>在查询中很少使用或者参考的列</strong>不应该创建索引<br> 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</li>\n<li>对于那些<strong>只有很少数据值的列</strong>也不应该增加索引<br> 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</li>\n<li>对于那些<strong>定义为 text, image 和 bit 数据类型的列</strong>不应该增加索引<br> 这是因为，这些列的数据量要么相当大，要么取值很少。</li>\n<li>当<strong>修改性能远远大于检索性能时</strong>，不应该创建索引<br> 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"索引结构——B-树与B-树\"><a href=\"#索引结构——B-树与B-树\" class=\"headerlink\" title=\"索引结构——B+树与B-树\"></a>索引结构——B+树与B-树</h4><p>MySQL用B+树作索引，而MongoDB用B-树作索引。这是由于两者的应用场景不同导致的。</p>\n<p>先简单介绍一下B-树和B+树的结构以及区别。</p>\n<p>B-树和B+树都是多路非二叉树，B-树的每个子节点既存索引，又存数据，搜索时就相当于二分查找；B-树的查找时间并不稳定，在O(1)~O(logN)间波动；B-树适合单次查询，其结构没法满足范围查询的要求。</p>\n<p>而B+树的每个非叶子节点只存索引用来存索引，所有的数据均保存在叶子节点中；所有的叶子节点形成了双向链表，适合作范围查询；尽管B+树的单次查询时间都是O(logN)，但是因为非叶子节点只存索引的缘故，B+树的高度也相对更低，所以总体查询时间并不比B-树差。</p>\n<p>再来说说MySQL和MongoDB的应用场景。MongoDB是文档型的数据库，是一种 nosql，它使用类 Json 格式保存数据，这种情况下数据与数据之间的关联并不大，查询时仅仅只需要查询到单个数据即可。</p>\n<p>而MySQL是关系型数据库，数据之间的关系十分紧密，区间访问是最常见的一种情况。</p>\n<p>由此可见，针对MySQL和MongoDB的应用场景，MySQL适合用B+树，而MongoDB适合用B-树。</p>\n<h4 id=\"索引的种类\"><a href=\"#索引的种类\" class=\"headerlink\" title=\"索引的种类\"></a>索引的种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。</p>\n<ol>\n<li><p>唯一索引<br> 唯一索引是不允许其中任何两行具有相同索引值的索引。<br> 当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓</p>\n</li>\n<li><p>主键索引<br> 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。<br> 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</p>\n</li>\n<li><p>聚集索引<br> 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。</p>\n</li>\n</ol>\n<h5 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h5><p>索引是通过二叉树的数据结构来描述的。简单来说，聚簇索引和非聚簇索引的区别在于：聚簇索引的叶节点就是数据节点；而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</p>\n<p>详细可见<a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a></p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://zhuanlan.zhihu.com/p/23624390\" target=\"_blank\" rel=\"noopener\">深入浅出数据库索引原理</a><br><a href=\"https://blog.csdn.net/GarfieldEr007/article/details/54319026\" target=\"_blank\" rel=\"noopener\">数据库范式解析</a><br><a href=\"https://juejin.cn/post/6844903845554814983\" target=\"_blank\" rel=\"noopener\">聚集索引和非聚集索引的区别</a><br><a href=\"https://my.oschina.net/u/4365362/blog/4523180\" target=\"_blank\" rel=\"noopener\">为什么Mongodb索引用B树，而Mysql用B+树</a></p>\n"},{"title":"数据库基础-2","date":"2021-01-24T14:59:00.000Z","top_img":"/img/cover/database.jpg","cover":"/img/cover/database.jpg","_content":"\n## 数据库基础知识（2）\n### Mysql\n#### 超键 候选键 主键 外键\n**超键(super key)**：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。\n**候选键(candidate key)**：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。\n**主键(primary key)**：用户选作元组标识的一个候选键。\n**外键(foreign key)**：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。\n\n#### 视图\n基本语法：\n```sql\ncreate view view_name as select_sql;                -- 创建视图\nselect * from view_name;                            -- 查看视图\ncreate or replace view name as select_sql;          -- 更新视图，不更新表\nupdate view_name;                                   -- 更新视图，也更新表\ndrop view view_name;                                -- 删除视图\n```\n\n视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。\n\n一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。\n\n视图和表的区别：\n1. 视图是已经编译好的sql语句；而表不是。  \n2. 视图没有实际的物理记录；而表有。\n3. 表是内容；视图是窗口。\n4. 表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。\n5. 表是内模式；视图是外模式。\n6. 视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。\n7. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。\n8. 视图的建立和删除只影响视图本身，不影响对应的基本表。\n\n视图和表的联系：\n    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。\n\n#### drop delete truncate\n基本语法：\n```sql\ndrop table table_name                           -- 直接删掉表\ntruncate table table_name                       -- 删除表中数据，再插入时自增长id又从1开始\ndelete from table_name where_sql                -- 删除表中数据，可以加where字句\n```\n\n1. 一般而言，drop > truncate > delete\n2. 应用范围：truncate 只能对 table；delete 可以是 table 和 view 。\n3. truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。\n4. 表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。\n5. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。\n6. delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。\n7. truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。\n8. truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。\n9. truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。\n10. 对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。\n\n#### 连接的种类\n查询分析器中执行：\n```sql\n--建表table1,table2：\ncreate table table1(id int,name varchar(10));\ncreate table table2(id int,score int);\n\ninsert into table1 select 1,'lee';\ninsert into table1 select 2,'zhang';\ninsert into table1 select 4,'wang';\ninsert into table2 select 1,90;\ninsert into table2 select 2,100;\ninsert into table2 select 3,70;\n```\n\n如表:\n```sql\n-------------------------------------------------\n|  table1  |  table2  |\n-------------------------------------------------\n| id  name | id score |\n| 1    lee | 1     90 |\n| 2  zhang | 2    100 |\n| 4   wang | 3     70 |\n-------------------------------------------------\n```\n\n以下均在查询分析器中执行\n##### 一、外连接\n概念：包括左向外联接、右向外联接和完整外部联接\n\n1. 左连接：`left join`或`left outer join`\n    左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。\n\n    ```sql\n    select * from table1 left join table2 on table1.id=table2.id\n    -----------result------------\n    | id  name   id  score |\n    -----------------------------\n    | 1    lee    1     90 |\n    | 2  zhang    2    100 |\n    | 4   wang  NULL  NULL |\n    -----------------------------\n    -- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示\n    ```\n\n2. 右连接：`right join`或`right outer join`\n    右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。\n\n    ```sql\n    select * from table1 right join table2 on table1.id=table2.id\n    ------------result------------\n    | id    name id  score |\n    ------------------------------\n    |   1    lee  1     90 |\n    |   2  zhang  2    100 |\n    | NULL  NULL  3     70 |\n    ------------------------------\n    -- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示\n    ```\n\n3. 完整外部联接:`full join`或`full outer join`\n    完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。\n    ```sql\n    select * from table1 full join table2 on table1.id=table2.id\n    -------------结果-------------\n    | id   name   id score |\n    ------------------------------\n    | 1     lee    1    90 |\n    | 2   zhang    2   100 |\n    | 4    wang NULL  NULL |\n    | NULL NULL    3    70 |\n    ------------------------------\n    -- 注释：返回左右连接的和（见上左、右连接）\n    ```\n\n##### 二、内连接\n概念：内联接是用比较运算符比较要联接列的值的联接\n\n内连接：`join`或`inner join`\n```sql\nselect * from table1 join table2 on table1.id=table2.id\n-------------结果-------------\n| id  name  id  score |\n------------------------------\n|  1   lee   1     90 |\n|  2 zhang   2    100 |\n------------------------------\n-- 注释：只返回符合条件的table1和table2的列\n```\n等价（与下列执行效果相同）\n```sql\nA: select a.*, b.* from table1 a, table2 b where a.id=b.id\nB: select * from table1 cross join table2 where table1.id=table2.id\n-- 注：cross join后加条件只能用where, 不能用on\n```\n\n##### 三、交叉连接(完全)\n概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）\n\n交叉连接：`cross join`(不带条件where...)\n\n```sql\nselect * from table1 cross join table2\n-------------结果-------------\n| id  name  id score |\n------------------------------\n| 1    lee   1    90 |\n| 2  zhang   1    90 |\n| 4   wang   1    90 |\n| 1    lee   2   100 |\n| 2  zhang   2   100 |\n| 4   wang   2   100 |\n| 1    lee   3    70 |\n| 2  zhang   3    70 |\n| 4   wang   3    70 |\n------------------------------\n-- 注释：返回3*3=9条记录，即笛卡尔积\n```\n\n等价\n```sql\nA: select * from table1, table2\n```\n\n#### 数据库优化的思路\n##### 1. SQL语句优化\n- 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描。  \n- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n    ```sql\n    select id from t where num is null\n    ```\n    可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：\n    ```sql\n    select id from t where num=0\n    ```\n- 很多时候用 exists 代替 in 是一个好的选择。\n- 用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。\n\n##### 2. 索引优化\n详见[数据库基础-1](https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/)索引部分\n\n##### 3. 数据库结构优化\n1. 范式优化： 比如消除冗余（节省空间......）\n2. 反范式优化：比如适当加冗余等（减少join）\n3. 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。\n\n- 拆分其实又分垂直拆分和水平拆分：\n    + **垂直拆分**：\n    解决问题：表与表之间的io竞争 \n    不解决问题：单表中数据量增长出现的压力 \n    + **水平拆分**：    \n    解决问题：单表中数据量增长出现的压力 \n    不解决问题：表与表之间的io争夺\n\n    + 案例： 简单购物系统暂设涉及如下表：\n        1. 产品表（数据量10w，稳定） \n        2. 订单表（数据量200w，且有增长趋势）\n        3. 用户表 （数据量100w，且有增长趋势）    \n    \n        + 垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上\n        + 水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)\n\n##### 4. 服务器硬件优化\n这个么，多花钱咯\n\n#### 存储过程与触发器的区别\n触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。\n\n触发器是在一个修改了指定表中的数据时执行的存储过程。\n\n通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。\n\n触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。\n\n#### 锁\n在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。\n\nMySQL中这3种锁的特性可大致归纳如下:\n\n| 模式 | 开锁、加锁速度、死锁、粒度、并发性能 |\n| --- | --- |\n| 行级锁 | 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 |\n| 页面锁 | 开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 |\n| 表级锁 | 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 |\n\n而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。\n\n#### 事务日志\n事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。\n如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。\n\nMySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：\n+ Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的\n+ Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。\n+ Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c)\n[SQL视图](https://www.w3school.com.cn/sql/sql_view.asp)\n[视图和表的区别](https://www.cnblogs.com/binyao/p/4899970.html)\n[Mysql常见的三种存储引擎](https://segmentfault.com/a/1190000012588602)\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)","source":"_posts/数据库基础-2.md","raw":"---\ntitle: 数据库基础-2\ndate: 2021-01-24 22:59:00\ntop_img: /img/cover/database.jpg\ncover: /img/cover/database.jpg\ntags: [Database, intern, 笔记]\n---\n\n## 数据库基础知识（2）\n### Mysql\n#### 超键 候选键 主键 外键\n**超键(super key)**：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。\n**候选键(candidate key)**：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。\n**主键(primary key)**：用户选作元组标识的一个候选键。\n**外键(foreign key)**：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。\n\n#### 视图\n基本语法：\n```sql\ncreate view view_name as select_sql;                -- 创建视图\nselect * from view_name;                            -- 查看视图\ncreate or replace view name as select_sql;          -- 更新视图，不更新表\nupdate view_name;                                   -- 更新视图，也更新表\ndrop view view_name;                                -- 删除视图\n```\n\n视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。\n\n一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。\n\n视图和表的区别：\n1. 视图是已经编译好的sql语句；而表不是。  \n2. 视图没有实际的物理记录；而表有。\n3. 表是内容；视图是窗口。\n4. 表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。\n5. 表是内模式；视图是外模式。\n6. 视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。\n7. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。\n8. 视图的建立和删除只影响视图本身，不影响对应的基本表。\n\n视图和表的联系：\n    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。\n\n#### drop delete truncate\n基本语法：\n```sql\ndrop table table_name                           -- 直接删掉表\ntruncate table table_name                       -- 删除表中数据，再插入时自增长id又从1开始\ndelete from table_name where_sql                -- 删除表中数据，可以加where字句\n```\n\n1. 一般而言，drop > truncate > delete\n2. 应用范围：truncate 只能对 table；delete 可以是 table 和 view 。\n3. truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。\n4. 表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。\n5. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。\n6. delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。\n7. truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。\n8. truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。\n9. truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。\n10. 对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。\n\n#### 连接的种类\n查询分析器中执行：\n```sql\n--建表table1,table2：\ncreate table table1(id int,name varchar(10));\ncreate table table2(id int,score int);\n\ninsert into table1 select 1,'lee';\ninsert into table1 select 2,'zhang';\ninsert into table1 select 4,'wang';\ninsert into table2 select 1,90;\ninsert into table2 select 2,100;\ninsert into table2 select 3,70;\n```\n\n如表:\n```sql\n-------------------------------------------------\n|  table1  |  table2  |\n-------------------------------------------------\n| id  name | id score |\n| 1    lee | 1     90 |\n| 2  zhang | 2    100 |\n| 4   wang | 3     70 |\n-------------------------------------------------\n```\n\n以下均在查询分析器中执行\n##### 一、外连接\n概念：包括左向外联接、右向外联接和完整外部联接\n\n1. 左连接：`left join`或`left outer join`\n    左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。\n\n    ```sql\n    select * from table1 left join table2 on table1.id=table2.id\n    -----------result------------\n    | id  name   id  score |\n    -----------------------------\n    | 1    lee    1     90 |\n    | 2  zhang    2    100 |\n    | 4   wang  NULL  NULL |\n    -----------------------------\n    -- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示\n    ```\n\n2. 右连接：`right join`或`right outer join`\n    右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。\n\n    ```sql\n    select * from table1 right join table2 on table1.id=table2.id\n    ------------result------------\n    | id    name id  score |\n    ------------------------------\n    |   1    lee  1     90 |\n    |   2  zhang  2    100 |\n    | NULL  NULL  3     70 |\n    ------------------------------\n    -- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示\n    ```\n\n3. 完整外部联接:`full join`或`full outer join`\n    完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。\n    ```sql\n    select * from table1 full join table2 on table1.id=table2.id\n    -------------结果-------------\n    | id   name   id score |\n    ------------------------------\n    | 1     lee    1    90 |\n    | 2   zhang    2   100 |\n    | 4    wang NULL  NULL |\n    | NULL NULL    3    70 |\n    ------------------------------\n    -- 注释：返回左右连接的和（见上左、右连接）\n    ```\n\n##### 二、内连接\n概念：内联接是用比较运算符比较要联接列的值的联接\n\n内连接：`join`或`inner join`\n```sql\nselect * from table1 join table2 on table1.id=table2.id\n-------------结果-------------\n| id  name  id  score |\n------------------------------\n|  1   lee   1     90 |\n|  2 zhang   2    100 |\n------------------------------\n-- 注释：只返回符合条件的table1和table2的列\n```\n等价（与下列执行效果相同）\n```sql\nA: select a.*, b.* from table1 a, table2 b where a.id=b.id\nB: select * from table1 cross join table2 where table1.id=table2.id\n-- 注：cross join后加条件只能用where, 不能用on\n```\n\n##### 三、交叉连接(完全)\n概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）\n\n交叉连接：`cross join`(不带条件where...)\n\n```sql\nselect * from table1 cross join table2\n-------------结果-------------\n| id  name  id score |\n------------------------------\n| 1    lee   1    90 |\n| 2  zhang   1    90 |\n| 4   wang   1    90 |\n| 1    lee   2   100 |\n| 2  zhang   2   100 |\n| 4   wang   2   100 |\n| 1    lee   3    70 |\n| 2  zhang   3    70 |\n| 4   wang   3    70 |\n------------------------------\n-- 注释：返回3*3=9条记录，即笛卡尔积\n```\n\n等价\n```sql\nA: select * from table1, table2\n```\n\n#### 数据库优化的思路\n##### 1. SQL语句优化\n- 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描。  \n- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n    ```sql\n    select id from t where num is null\n    ```\n    可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：\n    ```sql\n    select id from t where num=0\n    ```\n- 很多时候用 exists 代替 in 是一个好的选择。\n- 用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。\n\n##### 2. 索引优化\n详见[数据库基础-1](https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/)索引部分\n\n##### 3. 数据库结构优化\n1. 范式优化： 比如消除冗余（节省空间......）\n2. 反范式优化：比如适当加冗余等（减少join）\n3. 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。\n\n- 拆分其实又分垂直拆分和水平拆分：\n    + **垂直拆分**：\n    解决问题：表与表之间的io竞争 \n    不解决问题：单表中数据量增长出现的压力 \n    + **水平拆分**：    \n    解决问题：单表中数据量增长出现的压力 \n    不解决问题：表与表之间的io争夺\n\n    + 案例： 简单购物系统暂设涉及如下表：\n        1. 产品表（数据量10w，稳定） \n        2. 订单表（数据量200w，且有增长趋势）\n        3. 用户表 （数据量100w，且有增长趋势）    \n    \n        + 垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上\n        + 水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)\n\n##### 4. 服务器硬件优化\n这个么，多花钱咯\n\n#### 存储过程与触发器的区别\n触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。\n\n触发器是在一个修改了指定表中的数据时执行的存储过程。\n\n通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。\n\n触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。\n\n#### 锁\n在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。\n\nMySQL中这3种锁的特性可大致归纳如下:\n\n| 模式 | 开锁、加锁速度、死锁、粒度、并发性能 |\n| --- | --- |\n| 行级锁 | 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 |\n| 页面锁 | 开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 |\n| 表级锁 | 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 |\n\n而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。\n\n#### 事务日志\n事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。\n如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。\n\nMySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：\n+ Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的\n+ Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。\n+ Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c)\n[SQL视图](https://www.w3school.com.cn/sql/sql_view.asp)\n[视图和表的区别](https://www.cnblogs.com/binyao/p/4899970.html)\n[Mysql常见的三种存储引擎](https://segmentfault.com/a/1190000012588602)\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)","slug":"数据库基础-2","published":1,"updated":"2021-02-02T14:47:09.558Z","_id":"ckkca6rbr0000w46wa4iverw0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"数据库基础知识（2）\"><a href=\"#数据库基础知识（2）\" class=\"headerlink\" title=\"数据库基础知识（2）\"></a>数据库基础知识（2）</h2><h3 id=\"Mysql\"><a href=\"#Mysql\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h3><h4 id=\"超键-候选键-主键-外键\"><a href=\"#超键-候选键-主键-外键\" class=\"headerlink\" title=\"超键 候选键 主键 外键\"></a>超键 候选键 主键 外键</h4><p><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。<br><strong>候选键(candidate key)</strong>：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。<br><strong>主键(primary key)</strong>：用户选作元组标识的一个候选键。<br><strong>外键(foreign key)</strong>：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</p>\n<h4 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> view_name <span class=\"keyword\">as</span> select_sql;                <span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> view_name;                            <span class=\"comment\">-- 查看视图</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">or</span> <span class=\"keyword\">replace</span> <span class=\"keyword\">view</span> <span class=\"keyword\">name</span> <span class=\"keyword\">as</span> select_sql;          <span class=\"comment\">-- 更新视图，不更新表</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> view_name;                                   <span class=\"comment\">-- 更新视图，也更新表</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> view_name;                                <span class=\"comment\">-- 删除视图</span></span><br></pre></td></tr></table></figure></p>\n<p>视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。</p>\n<p>一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。</p>\n<p>视图和表的区别：</p>\n<ol>\n<li>视图是已经编译好的sql语句；而表不是。  </li>\n<li>视图没有实际的物理记录；而表有。</li>\n<li>表是内容；视图是窗口。</li>\n<li>表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。</li>\n<li>表是内模式；视图是外模式。</li>\n<li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。</li>\n<li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li>\n<li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li>\n</ol>\n<p>视图和表的联系：<br>    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p>\n<h4 id=\"drop-delete-truncate\"><a href=\"#drop-delete-truncate\" class=\"headerlink\" title=\"drop delete truncate\"></a>drop delete truncate</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> table_name                           <span class=\"comment\">-- 直接删掉表</span></span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">table</span> table_name                       <span class=\"comment\">-- 删除表中数据，再插入时自增长id又从1开始</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> table_name where_sql                <span class=\"comment\">-- 删除表中数据，可以加where字句</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>一般而言，drop &gt; truncate &gt; delete</li>\n<li>应用范围：truncate 只能对 table；delete 可以是 table 和 view 。</li>\n<li>truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。</li>\n<li>表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。</li>\n<li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。</li>\n<li>delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。</li>\n<li>truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。</li>\n<li>truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。</li>\n<li>truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。</li>\n<li>对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。</li>\n</ol>\n<h4 id=\"连接的种类\"><a href=\"#连接的种类\" class=\"headerlink\" title=\"连接的种类\"></a>连接的种类</h4><p>查询分析器中执行：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--建表table1,table2：</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table1(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,<span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table2(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,score <span class=\"built_in\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"string\">'lee'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"string\">'zhang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">4</span>,<span class=\"string\">'wang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"number\">90</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">3</span>,<span class=\"number\">70</span>;</span><br></pre></td></tr></table></figure></p>\n<p>如表:<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">|  table1  |  table2  |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">| id  name | id score |</span><br><span class=\"line\">| 1    lee | 1     90 |</span><br><span class=\"line\">| 2  zhang | 2    100 |</span><br><span class=\"line\">| 4   wang | 3     70 |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br></pre></td></tr></table></figure></p>\n<p>以下均在查询分析器中执行</p>\n<h5 id=\"一、外连接\"><a href=\"#一、外连接\" class=\"headerlink\" title=\"一、外连接\"></a>一、外连接</h5><p>概念：包括左向外联接、右向外联接和完整外部联接</p>\n<ol>\n<li><p>左连接：<code>left join</code>或<code>left outer join</code><br> 左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-----------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee    <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang    <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang  <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>右连接：<code>right join</code>或<code>right outer join</code><br> 右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">------------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>    <span class=\"keyword\">name</span> <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|   <span class=\"number\">1</span>    lee  <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|   <span class=\"number\">2</span>  zhang  <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span>  <span class=\"number\">3</span>     <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完整外部联接:<code>full join</code>或<code>full outer join</code><br> 完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">full</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>   <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>     lee    <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>   zhang    <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>    wang <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span> <span class=\"literal\">NULL</span>    <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回左右连接的和（见上左、右连接）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"二、内连接\"><a href=\"#二、内连接\" class=\"headerlink\" title=\"二、内连接\"></a>二、内连接</h5><p>概念：内联接是用比较运算符比较要联接列的值的联接</p>\n<p>内连接：<code>join</code>或<code>inner join</code><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|  <span class=\"number\">1</span>   lee   <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|  <span class=\"number\">2</span> zhang   <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：只返回符合条件的table1和table2的列</span></span><br></pre></td></tr></table></figure><br>等价（与下列执行效果相同）<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> a.*, b.* <span class=\"keyword\">from</span> table1 a, table2 b <span class=\"keyword\">where</span> a.id=b.id</span><br><span class=\"line\">B: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">where</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-- 注：cross join后加条件只能用where, 不能用on</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"三、交叉连接-完全\"><a href=\"#三、交叉连接-完全\" class=\"headerlink\" title=\"三、交叉连接(完全)\"></a>三、交叉连接(完全)</h5><p>概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）</p>\n<p>交叉连接：<code>cross join</code>(不带条件where…)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回3*3=9条记录，即笛卡尔积</span></span><br></pre></td></tr></table></figure>\n<p>等价<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1, table2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数据库优化的思路\"><a href=\"#数据库优化的思路\" class=\"headerlink\" title=\"数据库优化的思路\"></a>数据库优化的思路</h4><h5 id=\"1-SQL语句优化\"><a href=\"#1-SQL语句优化\" class=\"headerlink\" title=\"1. SQL语句优化\"></a>1. SQL语句优化</h5><ul>\n<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将导致引擎放弃使用索引而进行全表扫描。  </li>\n<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span> <span class=\"keyword\">is</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span>=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n<li>很多时候用 exists 代替 in 是一个好的选择。</li>\n<li>用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。</li>\n</ul>\n<h5 id=\"2-索引优化\"><a href=\"#2-索引优化\" class=\"headerlink\" title=\"2. 索引优化\"></a>2. 索引优化</h5><p>详见<a href=\"https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/\">数据库基础-1</a>索引部分</p>\n<h5 id=\"3-数据库结构优化\"><a href=\"#3-数据库结构优化\" class=\"headerlink\" title=\"3. 数据库结构优化\"></a>3. 数据库结构优化</h5><ol>\n<li>范式优化： 比如消除冗余（节省空间……）</li>\n<li>反范式优化：比如适当加冗余等（减少join）</li>\n<li>拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。</li>\n</ol>\n<ul>\n<li><p>拆分其实又分垂直拆分和水平拆分：</p>\n<ul>\n<li><strong>垂直拆分</strong>：<br>解决问题：表与表之间的io竞争<br>不解决问题：单表中数据量增长出现的压力 </li>\n<li><p><strong>水平拆分</strong>：<br>解决问题：单表中数据量增长出现的压力<br>不解决问题：表与表之间的io争夺</p>\n</li>\n<li><p>案例： 简单购物系统暂设涉及如下表：</p>\n<ol>\n<li>产品表（数据量10w，稳定） </li>\n<li>订单表（数据量200w，且有增长趋势）</li>\n<li>用户表 （数据量100w，且有增长趋势）    </li>\n</ol>\n<ul>\n<li>垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上</li>\n<li>水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"4-服务器硬件优化\"><a href=\"#4-服务器硬件优化\" class=\"headerlink\" title=\"4. 服务器硬件优化\"></a>4. 服务器硬件优化</h5><p>这个么，多花钱咯</p>\n<h4 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h4><p>触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。</p>\n<p>触发器是在一个修改了指定表中的数据时执行的存储过程。</p>\n<p>通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p>\n<p>触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p>\n<h4 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h4><p>在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。</p>\n<p>MySQL中这3种锁的特性可大致归纳如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>开锁、加锁速度、死锁、粒度、并发性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>行级锁</td>\n<td>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td>\n</tr>\n<tr>\n<td>页面锁</td>\n<td>开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td>\n</tr>\n<tr>\n<td>表级锁</td>\n<td>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。</p>\n<h4 id=\"事务日志\"><a href=\"#事务日志\" class=\"headerlink\" title=\"事务日志\"></a>事务日志</h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。<br>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>\n<p>MySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：</p>\n<ul>\n<li>Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的</li>\n<li>Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。</li>\n<li>Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://www.w3school.com.cn/sql/sql_view.asp\" target=\"_blank\" rel=\"noopener\">SQL视图</a><br><a href=\"https://www.cnblogs.com/binyao/p/4899970.html\" target=\"_blank\" rel=\"noopener\">视图和表的区别</a><br><a href=\"https://segmentfault.com/a/1190000012588602\" target=\"_blank\" rel=\"noopener\">Mysql常见的三种存储引擎</a><br><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据库基础知识（2）\"><a href=\"#数据库基础知识（2）\" class=\"headerlink\" title=\"数据库基础知识（2）\"></a>数据库基础知识（2）</h2><h3 id=\"Mysql\"><a href=\"#Mysql\" class=\"headerlink\" title=\"Mysql\"></a>Mysql</h3><h4 id=\"超键-候选键-主键-外键\"><a href=\"#超键-候选键-主键-外键\" class=\"headerlink\" title=\"超键 候选键 主键 外键\"></a>超键 候选键 主键 外键</h4><p><strong>超键(super key)</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。<br><strong>候选键(candidate key)</strong>：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。<br><strong>主键(primary key)</strong>：用户选作元组标识的一个候选键。<br><strong>外键(foreign key)</strong>：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。</p>\n<h4 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> view_name <span class=\"keyword\">as</span> select_sql;                <span class=\"comment\">-- 创建视图</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> view_name;                            <span class=\"comment\">-- 查看视图</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">or</span> <span class=\"keyword\">replace</span> <span class=\"keyword\">view</span> <span class=\"keyword\">name</span> <span class=\"keyword\">as</span> select_sql;          <span class=\"comment\">-- 更新视图，不更新表</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> view_name;                                   <span class=\"comment\">-- 更新视图，也更新表</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> view_name;                                <span class=\"comment\">-- 删除视图</span></span><br></pre></td></tr></table></figure></p>\n<p>视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。</p>\n<p>一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。</p>\n<p>视图和表的区别：</p>\n<ol>\n<li>视图是已经编译好的sql语句；而表不是。  </li>\n<li>视图没有实际的物理记录；而表有。</li>\n<li>表是内容；视图是窗口。</li>\n<li>表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。</li>\n<li>表是内模式；视图是外模式。</li>\n<li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。</li>\n<li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li>\n<li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li>\n</ol>\n<p>视图和表的联系：<br>    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。</p>\n<h4 id=\"drop-delete-truncate\"><a href=\"#drop-delete-truncate\" class=\"headerlink\" title=\"drop delete truncate\"></a>drop delete truncate</h4><p>基本语法：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">table</span> table_name                           <span class=\"comment\">-- 直接删掉表</span></span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">table</span> table_name                       <span class=\"comment\">-- 删除表中数据，再插入时自增长id又从1开始</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> table_name where_sql                <span class=\"comment\">-- 删除表中数据，可以加where字句</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>一般而言，drop &gt; truncate &gt; delete</li>\n<li>应用范围：truncate 只能对 table；delete 可以是 table 和 view 。</li>\n<li>truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。</li>\n<li>表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。</li>\n<li>在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。</li>\n<li>delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。</li>\n<li>truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。</li>\n<li>truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。</li>\n<li>truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。</li>\n<li>对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。</li>\n</ol>\n<h4 id=\"连接的种类\"><a href=\"#连接的种类\" class=\"headerlink\" title=\"连接的种类\"></a>连接的种类</h4><p>查询分析器中执行：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--建表table1,table2：</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table1(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,<span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table2(<span class=\"keyword\">id</span> <span class=\"built_in\">int</span>,score <span class=\"built_in\">int</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"string\">'lee'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"string\">'zhang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table1 <span class=\"keyword\">select</span> <span class=\"number\">4</span>,<span class=\"string\">'wang'</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">1</span>,<span class=\"number\">90</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">2</span>,<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> table2 <span class=\"keyword\">select</span> <span class=\"number\">3</span>,<span class=\"number\">70</span>;</span><br></pre></td></tr></table></figure></p>\n<p>如表:<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">|  table1  |  table2  |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br><span class=\"line\">| id  name | id score |</span><br><span class=\"line\">| 1    lee | 1     90 |</span><br><span class=\"line\">| 2  zhang | 2    100 |</span><br><span class=\"line\">| 4   wang | 3     70 |</span><br><span class=\"line\"><span class=\"comment\">-------------------------------------------------</span></span><br></pre></td></tr></table></figure></p>\n<p>以下均在查询分析器中执行</p>\n<h5 id=\"一、外连接\"><a href=\"#一、外连接\" class=\"headerlink\" title=\"一、外连接\"></a>一、外连接</h5><p>概念：包括左向外联接、右向外联接和完整外部联接</p>\n<ol>\n<li><p>左连接：<code>left join</code>或<code>left outer join</code><br> 左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-----------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee    <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang    <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang  <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\"><span class=\"comment\">-----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>右连接：<code>right join</code>或<code>right outer join</code><br> 右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">------------result------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>    <span class=\"keyword\">name</span> <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|   <span class=\"number\">1</span>    lee  <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|   <span class=\"number\">2</span>  zhang  <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span>  <span class=\"number\">3</span>     <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完整外部联接:<code>full join</code>或<code>full outer join</code><br> 完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">full</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>   <span class=\"keyword\">name</span>   <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>     lee    <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>   zhang    <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>    wang <span class=\"literal\">NULL</span>  <span class=\"literal\">NULL</span> |</span><br><span class=\"line\">| <span class=\"literal\">NULL</span> <span class=\"literal\">NULL</span>    <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回左右连接的和（见上左、右连接）</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"二、内连接\"><a href=\"#二、内连接\" class=\"headerlink\" title=\"二、内连接\"></a>二、内连接</h5><p>概念：内联接是用比较运算符比较要联接列的值的联接</p>\n<p>内连接：<code>join</code>或<code>inner join</code><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">join</span> table2 <span class=\"keyword\">on</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span>  score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">|  <span class=\"number\">1</span>   lee   <span class=\"number\">1</span>     <span class=\"number\">90</span> |</span><br><span class=\"line\">|  <span class=\"number\">2</span> zhang   <span class=\"number\">2</span>    <span class=\"number\">100</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：只返回符合条件的table1和table2的列</span></span><br></pre></td></tr></table></figure><br>等价（与下列执行效果相同）<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> a.*, b.* <span class=\"keyword\">from</span> table1 a, table2 b <span class=\"keyword\">where</span> a.id=b.id</span><br><span class=\"line\">B: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2 <span class=\"keyword\">where</span> table1.id=table2.id</span><br><span class=\"line\"><span class=\"comment\">-- 注：cross join后加条件只能用where, 不能用on</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"三、交叉连接-完全\"><a href=\"#三、交叉连接-完全\" class=\"headerlink\" title=\"三、交叉连接(完全)\"></a>三、交叉连接(完全)</h5><p>概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）</p>\n<p>交叉连接：<code>cross join</code>(不带条件where…)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1 <span class=\"keyword\">cross</span> <span class=\"keyword\">join</span> table2</span><br><span class=\"line\"><span class=\"comment\">-------------结果-------------</span></span><br><span class=\"line\">| <span class=\"keyword\">id</span>  <span class=\"keyword\">name</span>  <span class=\"keyword\">id</span> score |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">1</span>    <span class=\"number\">90</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">2</span>   <span class=\"number\">100</span> |</span><br><span class=\"line\">| <span class=\"number\">1</span>    lee   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">2</span>  zhang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\">| <span class=\"number\">4</span>   wang   <span class=\"number\">3</span>    <span class=\"number\">70</span> |</span><br><span class=\"line\"><span class=\"comment\">------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- 注释：返回3*3=9条记录，即笛卡尔积</span></span><br></pre></td></tr></table></figure>\n<p>等价<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> table1, table2</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"数据库优化的思路\"><a href=\"#数据库优化的思路\" class=\"headerlink\" title=\"数据库优化的思路\"></a>数据库优化的思路</h4><h5 id=\"1-SQL语句优化\"><a href=\"#1-SQL语句优化\" class=\"headerlink\" title=\"1. SQL语句优化\"></a>1. SQL语句优化</h5><ul>\n<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将导致引擎放弃使用索引而进行全表扫描。  </li>\n<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span> <span class=\"keyword\">is</span> <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：  <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span> <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> <span class=\"keyword\">num</span>=<span class=\"number\">0</span></span><br></pre></td></tr></table></figure></li>\n<li>很多时候用 exists 代替 in 是一个好的选择。</li>\n<li>用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。</li>\n</ul>\n<h5 id=\"2-索引优化\"><a href=\"#2-索引优化\" class=\"headerlink\" title=\"2. 索引优化\"></a>2. 索引优化</h5><p>详见<a href=\"https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/\">数据库基础-1</a>索引部分</p>\n<h5 id=\"3-数据库结构优化\"><a href=\"#3-数据库结构优化\" class=\"headerlink\" title=\"3. 数据库结构优化\"></a>3. 数据库结构优化</h5><ol>\n<li>范式优化： 比如消除冗余（节省空间……）</li>\n<li>反范式优化：比如适当加冗余等（减少join）</li>\n<li>拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。</li>\n</ol>\n<ul>\n<li><p>拆分其实又分垂直拆分和水平拆分：</p>\n<ul>\n<li><strong>垂直拆分</strong>：<br>解决问题：表与表之间的io竞争<br>不解决问题：单表中数据量增长出现的压力 </li>\n<li><p><strong>水平拆分</strong>：<br>解决问题：单表中数据量增长出现的压力<br>不解决问题：表与表之间的io争夺</p>\n</li>\n<li><p>案例： 简单购物系统暂设涉及如下表：</p>\n<ol>\n<li>产品表（数据量10w，稳定） </li>\n<li>订单表（数据量200w，且有增长趋势）</li>\n<li>用户表 （数据量100w，且有增长趋势）    </li>\n</ol>\n<ul>\n<li>垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上</li>\n<li>水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"4-服务器硬件优化\"><a href=\"#4-服务器硬件优化\" class=\"headerlink\" title=\"4. 服务器硬件优化\"></a>4. 服务器硬件优化</h5><p>这个么，多花钱咯</p>\n<h4 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h4><p>触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。</p>\n<p>触发器是在一个修改了指定表中的数据时执行的存储过程。</p>\n<p>通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。</p>\n<p>触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</p>\n<h4 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h4><p>在Mysql数据库系统中,不同的存储引擎支持不同的锁机制。比如MyISAM和MEMORY存储引擎采用的表级锁，BDB采用的是页面锁，也支持表级锁，InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下采用行级锁。</p>\n<p>MySQL中这3种锁的特性可大致归纳如下:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>开锁、加锁速度、死锁、粒度、并发性能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>行级锁</td>\n<td>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</td>\n</tr>\n<tr>\n<td>页面锁</td>\n<td>开销和加锁速度界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td>\n</tr>\n<tr>\n<td>表级锁</td>\n<td>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>而每种锁又可分为共享锁和排他锁，共享锁和排他锁的两两组合中，仅有共享锁和共享锁可以互相兼容，即加了共享锁的记录仍可被其他事务以共享读的形式访问。</p>\n<h4 id=\"事务日志\"><a href=\"#事务日志\" class=\"headerlink\" title=\"事务日志\"></a>事务日志</h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。<br>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。</p>\n<p>MySQL InnoDB 中跟数据持久性、一致性有关的日志，有以下几种：</p>\n<ul>\n<li>Bin Log：是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的</li>\n<li>Redo Log：记录了数据操作在物理层面的修改，mysql中使用了大量缓存，修改操作时会直接修改内存，而不是立刻修改磁盘，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。</li>\n<li>Undo Log：除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC</li>\n</ul>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://www.w3school.com.cn/sql/sql_view.asp\" target=\"_blank\" rel=\"noopener\">SQL视图</a><br><a href=\"https://www.cnblogs.com/binyao/p/4899970.html\" target=\"_blank\" rel=\"noopener\">视图和表的区别</a><br><a href=\"https://segmentfault.com/a/1190000012588602\" target=\"_blank\" rel=\"noopener\">Mysql常见的三种存储引擎</a><br><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a></p>\n"},{"title":"数据库基础-3","date":"2021-02-02T13:13:24.000Z","top_img":"/img/cover/database.jpg","cover":"/img/cover/database.jpg","_content":"\n## 数据库基础知识（3）\n### 当前读与快照读\n1. 当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；\n\n    使用当前读的操作主要包括：**显式加锁的读操作与插入/更新/删除等写操作**，如下所示：\n\n    ```sql\n    select * from table where ? lock in share mode;          -- 显式加锁的读操作\n    select * from table where ? for update;                  -- 显式加锁的读操作\n    insert into table values (…);                            -- 插入操作\n    update table set ? where ?;                              -- 更新操作\n    delete from table where ?;                               -- 删除操作\n    ```\n\n    > 注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。\n\n2. 快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；\n\n    InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；\n\n### MVCC 原理\nMVCC（多版本并发控制）的最大好处：**读不加任何锁**，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；\n\n**MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。**\n\n在REPEATABLE READ隔离级别下，MVCC的操作方式如下：\n+ **SELECT**\n    InnoDB会根据以下两个条件检查每行记录：\n    1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。\n    2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。\n    只有符合上述两个条件的记录，才能返回作为查询结果\n+ **INSERT**\n    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。\n+ **DELETE**\n    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。\n+ **UPDATE**\n    InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。\n\n保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。\n\n### MySQL存储引擎\n```sql\nshow engines;                                            -- 查看存储引擎\nshow variables like 'storage_engine';                    -- 查看数据库默认使用的引擎\ncreate table table_name()engine=engine_name;             -- 建表时设置引擎\n\nshow status like '%table_lock%'                          -- 查看表级锁争用情况\nshow status like 'innodb_row_lock'                       -- 查看InnoDB行级锁争用情况\n```\n\nMysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。\n\n#### InnoDB存储引擎\nInnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用\n\n> InnoDB主要特性\n+ 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合\n+ 为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上\n+ InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键\n\n+ InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高\n+ 共享锁和排他锁是InnoDB实现的两种标准的行锁\n+ InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)\n\n##### InnoDB 锁算法\nInnoDB 的三种锁算法：\n\n| 行锁算法 | 锁定内容 |\n| --- | --- |\n| Record Lock | 记录锁，锁定一个行记录 |\n| Gap Lock | 间隙锁，锁定一个区间 |\n| Next-key Lock | 记录锁+间隙锁，锁定行记录+区间 |\n\nInnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；\n\n不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：\n\n| 等值查询使用的索引类型 | 锁定内容 |\n| --- | --- |\n| 主键(聚簇索引) | 对聚簇索引记录 + 记录锁 |\n| 唯一索引 | 对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁 |\n| 普通索引 | 对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁 |\n| 不使用索引 | 对聚簇索引全表 + next-key锁 |\n\n行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。\n\n#### MyISAM存储引擎\nMyISAM 基于`ISAM存储引擎`，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有**较高的插入、查询速度，但不支持事务**。\n\n> MyISAM主要特性：\n+ 被大文件系统和操作系统支持\n+ 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成\n+ 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16\n+ 最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上\n+ BLOB和TEXT列可以被索引\n+ NULL被允许在索引的列中，这个值占每个键的0~1个字节\n+ 所有数字键值以高字节优先被存储以允许一个更高的索引压缩\n+ 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快\n+ 可以把数据文件和索引文件放在不同目录\n+ 每个字符列可以有不同的字符集\n+ 有VARCHAR的表可以固定或动态记录长度\n+ VARCHAR和CHAR列可以多达64KB\n\n与默认支持行级锁的InnoDB不同，MyISAM使用**表级锁**，表级锁也可细分为共享锁和排他锁。\n\nMyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中**写操作的优先级更高**。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。\n\n+ 调节MyISAM调度方式的一些方法\n    + 通过指定启动参数`low-priority-updates`，使MyISAM引擎默认给予读请求以优先的权利。\n    + 通过执行命令`SET LOW_PRIORITY_UPDATES=1`，使该连接发出的更新请求优先级降低。\n    + 通过指定INSERT、UPDATE、DELETE语句的`LOW_PRIORITY`属性，降低该语句的优先级。\n\nMySQL也提供了一种折中的办法来调节读写冲突，即给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。\n\n#### 存储引擎的比较与选择\n在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。\n\n| 特性 | InnoDB | MyISAM |\n| --- | :---: | :---: |\n| 事务安全 | 支持 | 无 |\n| 存储限制 | 64TB | 有 |\n| 空间使用 | 高 | 低 |\n| 内存使用 | 高 | 低 |\n| 插入数据的速度 | 低 | 高 |\n| 对外键的支持 | 支持 | 无 |\n\n**InnoDB**： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。\n\n**MyISAM**： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。\n\n## 参考链接\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)\n[MyISAM表锁](https://segmentfault.com/a/1190000019899944)\n[InnoDB行锁](https://segmentfault.com/a/1190000014133576)","source":"_posts/数据库基础-3.md","raw":"---\ntitle: 数据库基础-3\ndate: 2021-02-02 21:13:24\ntop_img: /img/cover/database.jpg\ncover: /img/cover/database.jpg\ntags: [Database, intern, 笔记]\n---\n\n## 数据库基础知识（3）\n### 当前读与快照读\n1. 当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；\n\n    使用当前读的操作主要包括：**显式加锁的读操作与插入/更新/删除等写操作**，如下所示：\n\n    ```sql\n    select * from table where ? lock in share mode;          -- 显式加锁的读操作\n    select * from table where ? for update;                  -- 显式加锁的读操作\n    insert into table values (…);                            -- 插入操作\n    update table set ? where ?;                              -- 更新操作\n    delete from table where ?;                               -- 删除操作\n    ```\n\n    > 注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。\n\n2. 快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；\n\n    InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；\n\n### MVCC 原理\nMVCC（多版本并发控制）的最大好处：**读不加任何锁**，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；\n\n**MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。**\n\n在REPEATABLE READ隔离级别下，MVCC的操作方式如下：\n+ **SELECT**\n    InnoDB会根据以下两个条件检查每行记录：\n    1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。\n    2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。\n    只有符合上述两个条件的记录，才能返回作为查询结果\n+ **INSERT**\n    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。\n+ **DELETE**\n    InnoDB为删除的每一行保存当前系统版本号作为行删除标识。\n+ **UPDATE**\n    InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。\n\n保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。\n\n### MySQL存储引擎\n```sql\nshow engines;                                            -- 查看存储引擎\nshow variables like 'storage_engine';                    -- 查看数据库默认使用的引擎\ncreate table table_name()engine=engine_name;             -- 建表时设置引擎\n\nshow status like '%table_lock%'                          -- 查看表级锁争用情况\nshow status like 'innodb_row_lock'                       -- 查看InnoDB行级锁争用情况\n```\n\nMysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。\n\n#### InnoDB存储引擎\nInnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用\n\n> InnoDB主要特性\n+ 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合\n+ 为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上\n+ InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键\n\n+ InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高\n+ 共享锁和排他锁是InnoDB实现的两种标准的行锁\n+ InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)\n\n##### InnoDB 锁算法\nInnoDB 的三种锁算法：\n\n| 行锁算法 | 锁定内容 |\n| --- | --- |\n| Record Lock | 记录锁，锁定一个行记录 |\n| Gap Lock | 间隙锁，锁定一个区间 |\n| Next-key Lock | 记录锁+间隙锁，锁定行记录+区间 |\n\nInnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；\n\n不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：\n\n| 等值查询使用的索引类型 | 锁定内容 |\n| --- | --- |\n| 主键(聚簇索引) | 对聚簇索引记录 + 记录锁 |\n| 唯一索引 | 对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁 |\n| 普通索引 | 对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁 |\n| 不使用索引 | 对聚簇索引全表 + next-key锁 |\n\n行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。\n\n#### MyISAM存储引擎\nMyISAM 基于`ISAM存储引擎`，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有**较高的插入、查询速度，但不支持事务**。\n\n> MyISAM主要特性：\n+ 被大文件系统和操作系统支持\n+ 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成\n+ 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16\n+ 最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上\n+ BLOB和TEXT列可以被索引\n+ NULL被允许在索引的列中，这个值占每个键的0~1个字节\n+ 所有数字键值以高字节优先被存储以允许一个更高的索引压缩\n+ 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快\n+ 可以把数据文件和索引文件放在不同目录\n+ 每个字符列可以有不同的字符集\n+ 有VARCHAR的表可以固定或动态记录长度\n+ VARCHAR和CHAR列可以多达64KB\n\n与默认支持行级锁的InnoDB不同，MyISAM使用**表级锁**，表级锁也可细分为共享锁和排他锁。\n\nMyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中**写操作的优先级更高**。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。\n\n+ 调节MyISAM调度方式的一些方法\n    + 通过指定启动参数`low-priority-updates`，使MyISAM引擎默认给予读请求以优先的权利。\n    + 通过执行命令`SET LOW_PRIORITY_UPDATES=1`，使该连接发出的更新请求优先级降低。\n    + 通过指定INSERT、UPDATE、DELETE语句的`LOW_PRIORITY`属性，降低该语句的优先级。\n\nMySQL也提供了一种折中的办法来调节读写冲突，即给系统参数`max_write_lock_count`设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。\n\n#### 存储引擎的比较与选择\n在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。\n\n| 特性 | InnoDB | MyISAM |\n| --- | :---: | :---: |\n| 事务安全 | 支持 | 无 |\n| 存储限制 | 64TB | 有 |\n| 空间使用 | 高 | 低 |\n| 内存使用 | 高 | 低 |\n| 插入数据的速度 | 低 | 高 |\n| 对外键的支持 | 支持 | 无 |\n\n**InnoDB**： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。\n\n**MyISAM**： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。\n\n## 参考链接\n[MVCC实现原理](https://www.jianshu.com/p/f692d4f8a53e)\n[MyISAM表锁](https://segmentfault.com/a/1190000019899944)\n[InnoDB行锁](https://segmentfault.com/a/1190000014133576)","slug":"数据库基础-3","published":1,"updated":"2021-02-02T14:48:29.382Z","_id":"ckko43nia0000n26w9yf5eza0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"数据库基础知识（3）\"><a href=\"#数据库基础知识（3）\" class=\"headerlink\" title=\"数据库基础知识（3）\"></a>数据库基础知识（3）</h2><h3 id=\"当前读与快照读\"><a href=\"#当前读与快照读\" class=\"headerlink\" title=\"当前读与快照读\"></a>当前读与快照读</h3><ol>\n<li><p>当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；</p>\n<p> 使用当前读的操作主要包括：<strong>显式加锁的读操作与插入/更新/删除等写操作</strong>，如下所示：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span>;          <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;                  <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> <span class=\"keyword\">values</span> (…);                            <span class=\"comment\">-- 插入操作</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">table</span> <span class=\"keyword\">set</span> ? <span class=\"keyword\">where</span> ?;                              <span class=\"comment\">-- 更新操作</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ?;                               <span class=\"comment\">-- 删除操作</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>\n</blockquote>\n</li>\n<li><p>快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；</p>\n<p> InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p>\n</li>\n</ol>\n<h3 id=\"MVCC-原理\"><a href=\"#MVCC-原理\" class=\"headerlink\" title=\"MVCC 原理\"></a>MVCC 原理</h3><p>MVCC（多版本并发控制）的最大好处：<strong>读不加任何锁</strong>，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；</p>\n<p><strong>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong></p>\n<p>在REPEATABLE READ隔离级别下，MVCC的操作方式如下：</p>\n<ul>\n<li><strong>SELECT</strong><br>  InnoDB会根据以下两个条件检查每行记录：<ol>\n<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>\n<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的记录，才能返回作为查询结果</li>\n</ol>\n</li>\n<li><strong>INSERT</strong><br>  InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>\n<li><strong>DELETE</strong><br>  InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>\n<li><strong>UPDATE</strong><br>  InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。</li>\n</ul>\n<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>\n<h3 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;                                            <span class=\"comment\">-- 查看存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'storage_engine'</span>;                    <span class=\"comment\">-- 查看数据库默认使用的引擎</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table_name()<span class=\"keyword\">engine</span>=engine_name;             <span class=\"comment\">-- 建表时设置引擎</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'%table_lock%'</span>                          <span class=\"comment\">-- 查看表级锁争用情况</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'innodb_row_lock'</span>                       <span class=\"comment\">-- 查看InnoDB行级锁争用情况</span></span><br></pre></td></tr></table></figure>\n<p>Mysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。</p>\n<h4 id=\"InnoDB存储引擎\"><a href=\"#InnoDB存储引擎\" class=\"headerlink\" title=\"InnoDB存储引擎\"></a>InnoDB存储引擎</h4><p>InnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用</p>\n<blockquote>\n<p>InnoDB主要特性</p>\n<ul>\n<li>为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>\n<li>为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</li>\n<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>\n</ul>\n</blockquote>\n<ul>\n<li>InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高</li>\n<li>共享锁和排他锁是InnoDB实现的两种标准的行锁</li>\n<li>InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)</li>\n</ul>\n<h5 id=\"InnoDB-锁算法\"><a href=\"#InnoDB-锁算法\" class=\"headerlink\" title=\"InnoDB 锁算法\"></a>InnoDB 锁算法</h5><p>InnoDB 的三种锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>行锁算法</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Record Lock</td>\n<td>记录锁，锁定一个行记录</td>\n</tr>\n<tr>\n<td>Gap Lock</td>\n<td>间隙锁，锁定一个区间</td>\n</tr>\n<tr>\n<td>Next-key Lock</td>\n<td>记录锁+间隙锁，锁定行记录+区间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；</p>\n<p>不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>等值查询使用的索引类型</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主键(聚簇索引)</td>\n<td>对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>普通索引</td>\n<td>对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>不使用索引</td>\n<td>对聚簇索引全表 + next-key锁</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。</p>\n<h4 id=\"MyISAM存储引擎\"><a href=\"#MyISAM存储引擎\" class=\"headerlink\" title=\"MyISAM存储引擎\"></a>MyISAM存储引擎</h4><p>MyISAM 基于<code>ISAM存储引擎</code>，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有<strong>较高的插入、查询速度，但不支持事务</strong>。</p>\n<blockquote>\n<p>MyISAM主要特性：</p>\n<ul>\n<li>被大文件系统和操作系统支持</li>\n<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成</li>\n<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>\n<li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li>\n<li>BLOB和TEXT列可以被索引</li>\n<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li>\n<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>\n<li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</li>\n<li>可以把数据文件和索引文件放在不同目录</li>\n<li>每个字符列可以有不同的字符集</li>\n<li>有VARCHAR的表可以固定或动态记录长度</li>\n<li>VARCHAR和CHAR列可以多达64KB</li>\n</ul>\n</blockquote>\n<p>与默认支持行级锁的InnoDB不同，MyISAM使用<strong>表级锁</strong>，表级锁也可细分为共享锁和排他锁。</p>\n<p>MyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中<strong>写操作的优先级更高</strong>。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。</p>\n<ul>\n<li>调节MyISAM调度方式的一些方法<ul>\n<li>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。</li>\n<li>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。</li>\n<li>通过指定INSERT、UPDATE、DELETE语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级。</li>\n</ul>\n</li>\n</ul>\n<p>MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p>\n<h4 id=\"存储引擎的比较与选择\"><a href=\"#存储引擎的比较与选择\" class=\"headerlink\" title=\"存储引擎的比较与选择\"></a>存储引擎的比较与选择</h4><p>在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th style=\"text-align:center\">InnoDB</th>\n<th style=\"text-align:center\">MyISAM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>事务安全</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td>存储限制</td>\n<td style=\"text-align:center\">64TB</td>\n<td style=\"text-align:center\">有</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>插入数据的速度</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n<tr>\n<td>对外键的支持</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>InnoDB</strong>： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>\n<p><strong>MyISAM</strong>： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a><br><a href=\"https://segmentfault.com/a/1190000019899944\" target=\"_blank\" rel=\"noopener\">MyISAM表锁</a><br><a href=\"https://segmentfault.com/a/1190000014133576\" target=\"_blank\" rel=\"noopener\">InnoDB行锁</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据库基础知识（3）\"><a href=\"#数据库基础知识（3）\" class=\"headerlink\" title=\"数据库基础知识（3）\"></a>数据库基础知识（3）</h2><h3 id=\"当前读与快照读\"><a href=\"#当前读与快照读\" class=\"headerlink\" title=\"当前读与快照读\"></a>当前读与快照读</h3><ol>\n<li><p>当前读：即加锁读，读取记录的最新版本，会加锁保证其他并发事务不能修改当前记录，直至获取了锁的事务释放锁；</p>\n<p> 使用当前读的操作主要包括：<strong>显式加锁的读操作与插入/更新/删除等写操作</strong>，如下所示：</p>\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">lock</span> <span class=\"keyword\">in</span> <span class=\"keyword\">share</span> <span class=\"keyword\">mode</span>;          <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ? <span class=\"keyword\">for</span> <span class=\"keyword\">update</span>;                  <span class=\"comment\">-- 显式加锁的读操作</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">table</span> <span class=\"keyword\">values</span> (…);                            <span class=\"comment\">-- 插入操作</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">table</span> <span class=\"keyword\">set</span> ? <span class=\"keyword\">where</span> ?;                              <span class=\"comment\">-- 更新操作</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> <span class=\"keyword\">where</span> ?;                               <span class=\"comment\">-- 删除操作</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁，待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>\n</blockquote>\n</li>\n<li><p>快照读：即不加锁读，读取记录的快照版本而非最新版本，通过MVCC实现；</p>\n<p> InnoDB默认的RR事务隔离级别下，不显式加『lock in share mode』与『for update』的『select』操作都属于快照读，保证事务执行过程中只有第一次读之前提交的修改和自己的修改可见，其他的均不可见；</p>\n</li>\n</ol>\n<h3 id=\"MVCC-原理\"><a href=\"#MVCC-原理\" class=\"headerlink\" title=\"MVCC 原理\"></a>MVCC 原理</h3><p>MVCC（多版本并发控制）的最大好处：<strong>读不加任何锁</strong>，读写不冲突，对于读操作多于写操作的应用，极大的增加了系统的并发性能；</p>\n<p><strong>MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</strong></p>\n<p>在REPEATABLE READ隔离级别下，MVCC的操作方式如下：</p>\n<ul>\n<li><strong>SELECT</strong><br>  InnoDB会根据以下两个条件检查每行记录：<ol>\n<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>\n<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。<br>只有符合上述两个条件的记录，才能返回作为查询结果</li>\n</ol>\n</li>\n<li><strong>INSERT</strong><br>  InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</li>\n<li><strong>DELETE</strong><br>  InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</li>\n<li><strong>UPDATE</strong><br>  InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。即UPDATE = INSERT新行 + DELETE旧行。</li>\n</ul>\n<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>\n<h3 id=\"MySQL存储引擎\"><a href=\"#MySQL存储引擎\" class=\"headerlink\" title=\"MySQL存储引擎\"></a>MySQL存储引擎</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">engines</span>;                                            <span class=\"comment\">-- 查看存储引擎</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">variables</span> <span class=\"keyword\">like</span> <span class=\"string\">'storage_engine'</span>;                    <span class=\"comment\">-- 查看数据库默认使用的引擎</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> table_name()<span class=\"keyword\">engine</span>=engine_name;             <span class=\"comment\">-- 建表时设置引擎</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'%table_lock%'</span>                          <span class=\"comment\">-- 查看表级锁争用情况</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">status</span> <span class=\"keyword\">like</span> <span class=\"string\">'innodb_row_lock'</span>                       <span class=\"comment\">-- 查看InnoDB行级锁争用情况</span></span><br></pre></td></tr></table></figure>\n<p>Mysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。</p>\n<h4 id=\"InnoDB存储引擎\"><a href=\"#InnoDB存储引擎\" class=\"headerlink\" title=\"InnoDB存储引擎\"></a>InnoDB存储引擎</h4><p>InnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持外键，支持表锁和行锁，不过行锁是在命中索引的情况下才会起作用</p>\n<blockquote>\n<p>InnoDB主要特性</p>\n<ul>\n<li>为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>\n<li>为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</li>\n<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>\n</ul>\n</blockquote>\n<ul>\n<li>InnoDB支持多粒度锁，默认使用行锁，锁粒度最小，锁冲突发生的概率也最低，支持的并发度也最高，但系统消耗成本也相对最高</li>\n<li>共享锁和排他锁是InnoDB实现的两种标准的行锁</li>\n<li>InnoDB有三种锁算法——记录锁(Record Lock)、间隙锁(Gap Lock)、next-key锁(Next-key Lock)</li>\n</ul>\n<h5 id=\"InnoDB-锁算法\"><a href=\"#InnoDB-锁算法\" class=\"headerlink\" title=\"InnoDB 锁算法\"></a>InnoDB 锁算法</h5><p>InnoDB 的三种锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>行锁算法</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Record Lock</td>\n<td>记录锁，锁定一个行记录</td>\n</tr>\n<tr>\n<td>Gap Lock</td>\n<td>间隙锁，锁定一个区间</td>\n</tr>\n<tr>\n<td>Next-key Lock</td>\n<td>记录锁+间隙锁，锁定行记录+区间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>InnoDB所有的行锁算法都是基于索引实现的，锁定的也都是索引或索引区间；</p>\n<p>不同的事务隔离级别、不同的索引类型、是否为等值查询，使用的行锁算法也会有所不同；下面仅以InnoDB默认的RR隔离级别、等值查询为例，介绍几种行锁算法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>等值查询使用的索引类型</th>\n<th>锁定内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>主键(聚簇索引)</td>\n<td>对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>唯一索引</td>\n<td>对辅助索引记录 + 记录锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>普通索引</td>\n<td>对相关辅助索引 + next-key锁；对聚簇索引记录 + 记录锁</td>\n</tr>\n<tr>\n<td>不使用索引</td>\n<td>对聚簇索引全表 + next-key锁</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>行级锁也分为共享锁和排他锁，具体的兼容情况详见参考链接描述。</p>\n<h4 id=\"MyISAM存储引擎\"><a href=\"#MyISAM存储引擎\" class=\"headerlink\" title=\"MyISAM存储引擎\"></a>MyISAM存储引擎</h4><p>MyISAM 基于<code>ISAM存储引擎</code>，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有<strong>较高的插入、查询速度，但不支持事务</strong>。</p>\n<blockquote>\n<p>MyISAM主要特性：</p>\n<ul>\n<li>被大文件系统和操作系统支持</li>\n<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成</li>\n<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>\n<li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li>\n<li>BLOB和TEXT列可以被索引</li>\n<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li>\n<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>\n<li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</li>\n<li>可以把数据文件和索引文件放在不同目录</li>\n<li>每个字符列可以有不同的字符集</li>\n<li>有VARCHAR的表可以固定或动态记录长度</li>\n<li>VARCHAR和CHAR列可以多达64KB</li>\n</ul>\n</blockquote>\n<p>与默认支持行级锁的InnoDB不同，MyISAM使用<strong>表级锁</strong>，表级锁也可细分为共享锁和排他锁。</p>\n<p>MyISAM的读操作是串行的，读操作和写操作是互斥的，并且MyISAM中<strong>写操作的优先级更高</strong>。例如，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？答案是写进程先获得锁。不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前！这是因为MySQL认为写请求一般比读请求重要。这也正是MyISAM表不太适合有大量更新操作和查询操作应用的原因，因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。</p>\n<ul>\n<li>调节MyISAM调度方式的一些方法<ul>\n<li>通过指定启动参数<code>low-priority-updates</code>，使MyISAM引擎默认给予读请求以优先的权利。</li>\n<li>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接发出的更新请求优先级降低。</li>\n<li>通过指定INSERT、UPDATE、DELETE语句的<code>LOW_PRIORITY</code>属性，降低该语句的优先级。</li>\n</ul>\n</li>\n</ul>\n<p>MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的读锁达到这个值后，MySQL变暂时将写请求的优先级降低，给读进程一定获得锁的机会。</p>\n<h4 id=\"存储引擎的比较与选择\"><a href=\"#存储引擎的比较与选择\" class=\"headerlink\" title=\"存储引擎的比较与选择\"></a>存储引擎的比较与选择</h4><p>在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th style=\"text-align:center\">InnoDB</th>\n<th style=\"text-align:center\">MyISAM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>事务安全</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n<tr>\n<td>存储限制</td>\n<td style=\"text-align:center\">64TB</td>\n<td style=\"text-align:center\">有</td>\n</tr>\n<tr>\n<td>空间使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>内存使用</td>\n<td style=\"text-align:center\">高</td>\n<td style=\"text-align:center\">低</td>\n</tr>\n<tr>\n<td>插入数据的速度</td>\n<td style=\"text-align:center\">低</td>\n<td style=\"text-align:center\">高</td>\n</tr>\n<tr>\n<td>对外键的支持</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>InnoDB</strong>： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>\n<p><strong>MyISAM</strong>： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.jianshu.com/p/f692d4f8a53e\" target=\"_blank\" rel=\"noopener\">MVCC实现原理</a><br><a href=\"https://segmentfault.com/a/1190000019899944\" target=\"_blank\" rel=\"noopener\">MyISAM表锁</a><br><a href=\"https://segmentfault.com/a/1190000014133576\" target=\"_blank\" rel=\"noopener\">InnoDB行锁</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckk6y1e2x00003a6w2zzn7o85","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e3r00073a6w4lpyat19"},{"post_id":"ckk6y1e3s00093a6w36me16r3","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e3v000c3a6w1becbjpw"},{"post_id":"ckk6y1e3500013a6wag7x5ncv","tag_id":"ckk6y1e3q00063a6we1504yqv","_id":"ckk6y1e3x000e3a6w9gu5gv5r"},{"post_id":"ckk6y1e3500013a6wag7x5ncv","tag_id":"ckk6y1e3t000a3a6wga0mh52l","_id":"ckk6y1e3x000f3a6w0zwj527y"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e41000j3a6wdl7y5hn8"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e41000k3a6wdv74e449"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e42000m3a6wdlgr2mc6"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e43000o3a6w4fc5bat8"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e43000p3a6w160dazad"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e44000r3a6w5xmldt4k"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e45000t3a6w5jotgfev"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e45000u3a6w52wx72g5"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e46000w3a6wflum7fbf"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e44000s3a6wh1s69ajs","_id":"ckk6y1e46000x3a6whuyo9sxi"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e47000y3a6w5by9222p"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e47000z3a6wf5ra7n5o"},{"post_id":"ckko43nia0000n26w9yf5eza0","tag_id":"ckk6y1e44000s3a6wh1s69ajs","_id":"ckko43niu0001n26wg0zgfylk"},{"post_id":"ckko43nia0000n26w9yf5eza0","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckko43niv0002n26wekwcb22c"},{"post_id":"ckko43nia0000n26w9yf5eza0","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckko43niv0003n26w26nc5kbi"},{"post_id":"ckkca6rbr0000w46wa4iverw0","tag_id":"ckk6y1e44000s3a6wh1s69ajs","_id":"ckko48d3o0000236whcwzb0mu"},{"post_id":"ckkca6rbr0000w46wa4iverw0","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckko48d3p0001236w4oyy8d5o"},{"post_id":"ckkca6rbr0000w46wa4iverw0","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckko48d3p0002236w4q1l3q1j"}],"Tag":[{"name":"笔记","_id":"ckk6y1e3l00023a6w6b6x1r3h"},{"name":"config","_id":"ckk6y1e3q00063a6we1504yqv"},{"name":"教程","_id":"ckk6y1e3t000a3a6wga0mh52l"},{"name":"c++","_id":"ckk6y1e3v000d3a6wcpcp2rv3"},{"name":"intern","_id":"ckk6y1e3x000g3a6w6iz3hyjm"},{"name":"Database","_id":"ckk6y1e44000s3a6wh1s69ajs"}]}}