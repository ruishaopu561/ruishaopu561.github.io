{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","path":"js/third-party/ClickShowText.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","path":"js/third-party/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","path":"js/third-party/activate-power-mode.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","path":"js/third-party/click_heart.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","path":"js/third-party/fireworks.js","modified":0,"renderable":1},{"_id":"themes/Butterfly/source/js/third-party/piao.js","path":"js/third-party/piao.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Butterfly/LICENSE","hash":"c372b56b7553dafd2d8a8abf12d0dd71b4e2bfc0","modified":1611198006684},{"_id":"themes/Butterfly/README.md","hash":"8e4d01331f9a820ec30fca075c6956859772530e","modified":1611198006684},{"_id":"themes/Butterfly/README_CN.md","hash":"4fd3e96f5c18f721118c175c807e19ae874a7793","modified":1611198006684},{"_id":"themes/Butterfly/_config.yml","hash":"2814fb85d7d7cdd7f26134fc95d5dec0fff4a75b","modified":1611416439475},{"_id":"themes/Butterfly/package.json","hash":"43a92e039fe98e01259dc84ee4066b5d5efb8e7f","modified":1611198006740},{"_id":"source/_posts/GAMES101-学习笔记.md","hash":"58086fd150891d398954b2455a1784ea601ae8ec","modified":1611198006680},{"_id":"source/_posts/Hexo-Github.md","hash":"12d25cf807f8fd8289b160a1be69251b5fdc38fe","modified":1611198006680},{"_id":"source/_posts/c++基础-1.md","hash":"80694e5ecc6eda0ffb425936f3df6b6b8d44220d","modified":1611198006680},{"_id":"source/_posts/c++基础-2.md","hash":"548d17454e3e6c14a3de912128a0fcf69c26f5e1","modified":1611238985496},{"_id":"source/_posts/c++基础-3.md","hash":"03d1746742b06e6416bbf54e2f3c16a0cbce457e","modified":1611238992120},{"_id":"source/_posts/hello-world.md","hash":"951d6d2b455faae8e17dd454bf658de7f91ccc15","modified":1611198006684},{"_id":"source/_posts/unity-shader学习记录.md","hash":"0ee009ec9da7d70421629f66734a923704eab2b0","modified":1611198006684},{"_id":"source/_posts/数据库基础-1.md","hash":"eb54951f6b3334b114de1f85d196f887cdc7bdc2","modified":1611238881032},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE.md","hash":"bc427d7f13fec05cfd2dcc10953cbb2a96bc31be","modified":1611198006684},{"_id":"themes/Butterfly/.github/stale.yml","hash":"cd5a929ce25a6293a9f449e7b80dfe4307326797","modified":1611198006684},{"_id":"themes/Butterfly/languages/default.yml","hash":"8cc398208ebd0326d0bdac09cf96b8aeeed78fcc","modified":1611198006684},{"_id":"themes/Butterfly/languages/en.yml","hash":"8cc398208ebd0326d0bdac09cf96b8aeeed78fcc","modified":1611198006684},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"848871887cc5ea38c50292df7f7c9d9dbb07b5ca","modified":1611198006684},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"6dc0abceee6a1c4b47d3ecdae81667ffb4a09f88","modified":1611198006684},{"_id":"themes/Butterfly/layout/404.pug","hash":"3ade9903e1e0dedfb11b46d7161f2100defba31e","modified":1611198006700},{"_id":"themes/Butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1611198006700},{"_id":"themes/Butterfly/layout/category.pug","hash":"d014234c26d2c07caaea6703f7b48cb69c51907d","modified":1611198006700},{"_id":"themes/Butterfly/layout/flink.pug","hash":"f922cafc12857cff327d6621ea5517976e85c229","modified":1611198006700},{"_id":"themes/Butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1611198006740},{"_id":"themes/Butterfly/layout/page.pug","hash":"130ab657a6acfe149dbc59e481dc05d4d7d926a3","modified":1611198006740},{"_id":"themes/Butterfly/layout/post.pug","hash":"2e34fd65d36508faec9fd015d6cdb108d4c29b58","modified":1611198006740},{"_id":"themes/Butterfly/layout/tag.pug","hash":"3bb2a700c6d709d2757d55d357eed1fca5644e24","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"5265bfbd6514fde10b42f5f5482776450e2bd582","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"855c5d7e427730178c2f6e4f3e816d7fbee40198","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"901122c065cb08589a52911773d9baf01c599faa","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"055747cdb64b27ac707402481e79c82ce946b0d3","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"385a186f0e77900db685b97d40bb4d26fa48a4d5","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"9ba725c0f9661a156f82dee35a422fdd4639a5ce","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"b41c97424c588209c0d24817f5120b50933135fd","modified":1611198006712},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1611198006740},{"_id":"themes/Butterfly/scripts/events/replace_config.js","hash":"537e556e76760ce2103f359d5a424c6e2b9a0710","modified":1611198006740},{"_id":"themes/Butterfly/scripts/filters/post_lazyload.js","hash":"4c7f4562183f28acb359b7e826eb0a198086e3f0","modified":1611198006740},{"_id":"themes/Butterfly/scripts/filters/random_cover.js","hash":"0b4775aaa955b75f03648fc1957fb88a6d440803","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/aside_archives.js","hash":"87c63d5b46fdc13724d5d213cdfde608af6a5bb3","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/aside_categories.js","hash":"21c89a1502e9964cb48d32ab0476427cc41b010d","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/page.js","hash":"729a9f40c5bf603036f6e9443db93b1704cf17d9","modified":1611198006740},{"_id":"themes/Butterfly/scripts/helpers/related_post.js","hash":"7ebe4dc2b42094a5b55799c0af5c28d6ab97d25f","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/gallery.js","hash":"2fad0a9e6645613631aad36dc3473fe8e032809b","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/hide.js","hash":"8c70135d5367b9a589ec92be66841488e9acdd29","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/mermaid.js","hash":"53eaff19d8da32e04e2c871300ea495356d633cd","modified":1611198006740},{"_id":"themes/Butterfly/scripts/tags/note.js","hash":"c739846637c48b4779df2f62effb78e15100fd9f","modified":1611198006740},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1611198006744},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1611198006744},{"_id":"themes/Butterfly/source/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611198006744},{"_id":"themes/Butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1611198006744},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611198006744},{"_id":"themes/Butterfly/source/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1611198006744},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1611198006744},{"_id":"themes/Butterfly/source/css/index.styl","hash":"96eb343f77fc891ff5adedb1f4a3fb34ab4ee20f","modified":1611198006744},{"_id":"themes/Butterfly/source/css/var.styl","hash":"907b5ee1d5cb44ebb90493b068c00bef068ef748","modified":1611198006744},{"_id":"themes/Butterfly/source/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1611198006744},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1611198006744},{"_id":"themes/Butterfly/source/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1611198006748},{"_id":"themes/Butterfly/layout/includes/comments/disqus.pug","hash":"821d968122bab8ce1ce04dc553b731eaf8e0d181","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/disqusjs.pug","hash":"050085054a68942e8833c6a4033fb437b6b01e52","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/facebook_comments.pug","hash":"7b7bb7d2b39b639cc8e1edf1274148460796662e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/gitalk.pug","hash":"e98f5c199a76ad939a29a46c0dcbf7e85ec60ed2","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/index.pug","hash":"f9556b40b00d5a566c64904afa833aa2e0d9449d","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/laibili.pug","hash":"00022f763085b6852bc172b0ba91b0eacb403389","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/utterances.pug","hash":"9427cb07bcfe2bc7198755eeebf60f9fe430a342","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/comments/valine.pug","hash":"4f6e49639896bc8a4d4fe2257502f98ab63f6a7d","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"6ba5794cffb47cfd2727e388b7cd7370c43e3559","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"8ec0609f14c284c3e6120940d7c4d7f1f201cd67","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/comment.pug","hash":"7de136bdce45afa81341b13e61b7a3926e15f03b","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"dd7cd1b3b20873044e0c0ed1280001a0e06ea358","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"2c7a5a097a2f815ba43a4e99c810405da3b9eebc","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/darkmode.pug","hash":"dcc8c01e1b0f8a4960ed873f49fb0f18d9912d21","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/dns_prefetch.pug","hash":"d2f81fadc68532cd27db8895c1834cdefb7e577e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"ff4ceda534cdd711cfa2cb9e95e36258988674e1","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"47a10164395d8200c8d962df68a01e7deee4053b","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"be1ff710e4381fc684243313dcadf0140d7469de","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"f5c8ec73c797ff3455e732fa7c92c856692f3ce5","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/head/subtitle.pug","hash":"bbdb2280a74cd7b573b8e03e1c2b44c37571ad22","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/header.pug","hash":"0b50e70efa91519e3ba7fa7a55e9603f33a8e6eb","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"e612fe17bbd8cb39772e9dac54df3fcd1da99ba6","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"addeb5765ab0635c665dcca99f7918561131ae09","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"9c50171335c65533af09a1c11648860b59be3299","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0d684f897fcdfe1e98300851b7fd955a30b68dd9","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/loading/loading-js.pug","hash":"3cf431a4f04997b55873f7099c1402155b19cc95","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/index.pug","hash":"ec97f284626b67208370b5084e5c5822844fa30a","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/katex.pug","hash":"73356f1068c7426597e268d6c4aefa2b0ac3a1d9","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/mathjax.pug","hash":"6ccfaa776fc913ccf8b34825d918ab2b4d457434","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/math/mermaid.pug","hash":"db848ff451d4c58670af415882ca6bb2e0da971b","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"53cd1b89dc4bc45c315a2f54bfce9d6c3a695f27","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mixins/post-ui.pug","hash":"40108322ce7f5b5ac52765ca39901fa2c00348d6","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/index.pug","hash":"d12fab033fb32b55abbc9be9b04cc6ab6465b98e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/mobile-sidebar/mobile-menus.pug","hash":"b7f1b9ff32ea868965e5dbb533c0117ce195663f","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"8efc0b7886bdb5959e173b5e11f5ffb8d1c5230e","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"6612174871d833981f1a4a4ec67bc0fbd6913fd8","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/search/local-search.pug","hash":"a45b5453e35479e58cd44b6bd2af0e08789890af","modified":1611198006700},{"_id":"themes/Butterfly/layout/includes/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/share/addtoany.pug","hash":"bbf5b70460b17c4fecb9ee6880aa71cdb2d807a8","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/share/index.pug","hash":"c341aaa00113681b22f945f5004e6b22c8a0ca69","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/share/share-js.pug","hash":"828a04c6e8e3a56c3c7f3c9bb1ecf4f99ed842fe","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-nest.pug","hash":"3d7a3654ae03fd2665ea355ee9eac48af0ee82af","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon-piao.pug","hash":"001f28c633d2ec2d5ef9ca047fb1fe61ffefd66f","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/canvas-ribbon.pug","hash":"b4acf48c98ba2a6a5a5fb5387a0fd610bdfd55ef","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"3f7de99f4307ac9bfd89e669aaa7c2ae54d5224a","modified":1611198006712},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"2e940de1a6261fd378e16e4cd3362a9d69c12f50","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"edf9658dbb95c964e4c6d60bd71d1dc7ebfbb0ac","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"8274404ec2f83f1ba6439d42e8a4e29e932067ac","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"56d27e39fa050a4d311d92b572ce291d7618026a","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"9fe3e264236835cfb6a91f54ee96bb3a79e36539","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"07eebb9d024feba44a2c66e04aef19151df8991c","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"c0309c49a92c1176f008ad322f86a8a19031b41e","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"6caff3cb958ccb0da7d88b51d87e22d27fcd9625","modified":1611198006740},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"15fb3730f829e237c102a70ab9781178471fd786","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"d9d19c2f5dbe671815b6048ff40b876e02d0fd7b","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_highlight/diff.styl","hash":"b0079f6da761935b720d70dafd826ef62fad86d2","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"4a61f436cd9a44a3bb4259549b05adf72cd941d7","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"efceb8105830544cef5e4afad3243326b3118fc1","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"964d16c30f307ec354b47375aa5f00f0417c7bf0","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"aeadbc2b3a057ab11f409b584d8c39c1d72ed0e7","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/category.styl","hash":"7267043e52a9e620adfa860bdb3e4de400ff2596","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/flink.styl","hash":"0631c50cdccd29ca41fbac3423b2fd91a9be49b8","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"d8709e29efcfa0a7356384026dfbaac8861d3baa","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"a23ff8c52bfc581a741158c75f3d4923c4cdf810","modified":1611198006740},{"_id":"themes/Butterfly/source/css/_layout/loadding.styl","hash":"144ef01b03ae34d3ede4b9aa18f4c8cd3d6651ea","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/mobile-sidebar.styl","hash":"5492d68c1c9bb85898d41b357f695d6fb17ec646","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/page.styl","hash":"970bd971b06411be85146c97ca30884ff3847910","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"d6f0b7d9dc10761c15a5a2b84cc63e914a10d339","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"e20057cc5a065078cb57821a63595ef9a0c36648","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"1103f2cead8ab1aa9945c20c7d608bb4b829d2cd","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"92b615795f02eff2a018edb425f923968c9e9814","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"9a44881bd4c2aea0b0774809d91d58e4067496ed","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"33da3da65715ce1a85b8ecab92e0eab6ce620a58","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"0fcfeef99c0bef8d48be9180b6fed5aace55acba","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"fa20ccacd51b0c87f4a9ae107bb20b629d5953ab","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"919f0a869203a03ca783dd3fc9df1aeb229de2c2","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"641ef2bc7af135c17fd90f3f974e78ebbaf1ac13","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"e31b475cbac2af8d3401fba6382d34968c8063ef","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"da791f46239eabbbf28eb30b9e441f1ac2a8ced1","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_tags/gallery.styl","hash":"d6af5c4f1966b5b575427c117712c173e23657ad","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_tags/hide.styl","hash":"a1de1df9f3cff44bcee7822107ec1e51d9a1b0b1","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_tags/note.styl","hash":"1ec06d5ac4148798babd2475a5d10f0d3a1b5870","modified":1611198006744},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"001bd6d68a9b9af5dd0158fe116889434f36b1fd","modified":1611198006744},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1611198006744},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1611198006744},{"_id":"themes/Butterfly/source/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1611198006744},{"_id":"public/2021/01/21/数据库基础-1/index.html","hash":"b19102eb49cc7e72715e134a6dcc79b3e5d1ee2c","modified":1611416499116},{"_id":"public/2021/01/20/c++基础-3/index.html","hash":"a523a50599f6e435db4509c59a76845b0352ef68","modified":1611416499116},{"_id":"public/2021/01/20/c++基础-2/index.html","hash":"4701e9f6c5d736baebb11b745530aee417bd5c7c","modified":1611416499116},{"_id":"public/2021/01/20/c++基础-1/index.html","hash":"5984da97429984835b8b1033ef0350667e1f3f24","modified":1611416499116},{"_id":"public/2020/06/19/GAMES101-学习笔记/index.html","hash":"45cc6784e427dfa2da928d2c8d3dbd59b8182ec3","modified":1611416499116},{"_id":"public/2020/06/16/unity-shader学习记录/index.html","hash":"8152e478c70c46f23ab03f79e68703c9ff9bdd29","modified":1611416499116},{"_id":"public/2020/06/12/Hexo-Github/index.html","hash":"4f4d8acaaf872e453fc49cc2970933659f704ac0","modified":1611416499116},{"_id":"public/2020/06/12/hello-world/index.html","hash":"a9f3c729ce691ddfece15aaac5ea4ec6af8a3b18","modified":1611416499116},{"_id":"public/archives/index.html","hash":"5db3fbcc6689b99ffc3b4c269a7dfef63aceaabc","modified":1611416568401},{"_id":"public/archives/2020/index.html","hash":"56cdfaf0be650ce1fe78ef3c95cba58baa2113bb","modified":1611416568401},{"_id":"public/archives/2020/06/index.html","hash":"78c781aee5c7d04471f0205dbf37fc5c969dff1e","modified":1611416568401},{"_id":"public/archives/2021/index.html","hash":"86f2b9b22961020ff75dec4efe2a539496777f0e","modified":1611416568401},{"_id":"public/archives/2021/01/index.html","hash":"d34c4c927e81fe11379b0352e9729c180ca66d72","modified":1611416568401},{"_id":"public/index.html","hash":"98064fe7d51a4ba1d02b2d7aa59a9e98b0ead297","modified":1611416568401},{"_id":"public/tags/笔记/index.html","hash":"bce3a38c77ace8184bae7103ea7c6db28f55f68f","modified":1611416568401},{"_id":"public/tags/config/index.html","hash":"65253ba9bc7f30f919ef3b2ab19dc93acf0b8d8c","modified":1611416568401},{"_id":"public/tags/教程/index.html","hash":"6adf3e921eba3d4c028f1bc35acc5a119dff945b","modified":1611416568401},{"_id":"public/tags/c/index.html","hash":"a56873b98c767d189035b1f68993c613dca620ea","modified":1611416568401},{"_id":"public/tags/intern/index.html","hash":"9faa1119592f648e10d8511dd6b713c47dfd6f1c","modified":1611416568401},{"_id":"public/tags/Database/index.html","hash":"d793f419aeaeb33face48c60e067a28a54b643ca","modified":1611416568401},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1611238894689},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1611238894689},{"_id":"public/img/avatar.png","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611238894689},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1611238894689},{"_id":"public/img/friend_404.gif","hash":"7572db8ef3d899dd7e7210ad1e1ca4e0c85b14cc","modified":1611238894689},{"_id":"public/img/icp.png","hash":"cb1fd69b38ec23ce8366668ddffbbd0160de0104","modified":1611238894689},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1611238894689},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1611238894689},{"_id":"public/js/utils.js","hash":"1906e1b61590368aa567e7064ff7f2492b57b257","modified":1611238894689},{"_id":"public/js/search/algolia.js","hash":"09219d497f54c834ec506a4f63d02f6cad7c2dc7","modified":1611238894689},{"_id":"public/js/search/local-search.js","hash":"497993860b3c42bdc926a3bd83b4b8f480febd99","modified":1611238894689},{"_id":"public/js/third-party/ClickShowText.js","hash":"32864aee35b5d739a36702b8d916b17bac52b17e","modified":1611238894689},{"_id":"public/js/third-party/canvas-nest.js","hash":"978402a16f3ceebe453806e3e25a5905a89776be","modified":1611238894689},{"_id":"public/js/third-party/activate-power-mode.js","hash":"2c4ab494225b7d04eed934efc43a43791e596f4a","modified":1611238894689},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"2496200178510a12b2436947a93bb15120560937","modified":1611238894689},{"_id":"public/js/third-party/click_heart.js","hash":"004ea645ed8c5e354711b5fc0dbfe015e181916b","modified":1611238894689},{"_id":"public/js/third-party/fireworks.js","hash":"411ced4031a856a5b87f7c62d3800027d12bacec","modified":1611238894689},{"_id":"public/js/third-party/piao.js","hash":"05da3437664bb335e2336a52be8587e7719f7b89","modified":1611238894689},{"_id":"public/css/index.css","hash":"817ba8be5bdd463183cbd107504640ecb21ca02d","modified":1611238894689},{"_id":"public/js/main.js","hash":"8a398625427c6dc3d2d23b55faa4ebbd8f45cea4","modified":1611238894689},{"_id":"public/js/tw_cn.js","hash":"d468bf1634950ed1ffd7cedd3c87f2037e27543f","modified":1611238894689},{"_id":"themes/Butterfly/layout/_layout.swig","hash":"e69985f2fad6d9d9292e54fa5a6adb19c8d84d45","modified":1611414457424},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.eslintrc","hash":"9274e9ce5a031fc936330eb0aa35653b03e5c1bc","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.gitignore","hash":"082286dac7149a87a9b5073a562bb0661a6a78df","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.travis.yml","hash":"0f3c18d294110f9a27aeff0ebe7023bb07ad52f8","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/README.md","hash":"055903e391b19d4eceaf220f57e3a5ac6764e389","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/package.json","hash":"0da94ab339e666fb97fa9d0344603704f1045a51","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/.github/ISSUE_TEMPLATE.md","hash":"24938de1141e8f26b6a2241f232b3e25129ac2e2","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/demo/demo.js","hash":"91511c265365b2d0b3e5fec44eed699ae5e35476","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/demo/index.html","hash":"05f752644aeb1a1d82ab113f76328eff0599f324","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/music.js","hash":"9fcf661ba67c3f932b9eb13261ab1e93a259b93c","modified":1611414312660},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/CNAME","hash":"5b5021c61cf084dc192c225d2532dba17d765d5a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/README.md","hash":"57fa2f31c725b96a287152b05c9e69ee185eef6a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/config.js","hash":"03ea6f8a9ee71aacca6ca30360951526f97e39de","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/ecosystem.md","hash":"9d51d4e6e6290d15cbf8c3444559a7c808f7e8dd","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/index.html","hash":"97fdf9b2508a04722b1544808ef5cbae7a02ef67","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/support.md","hash":"41424289691882abf0f61e51d4455059034a12d1","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/dev.config.js","hash":"f4c5ca8858374d7d457d4d20994b1e3c7151c19b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/postcss.config.js","hash":"b319d7a602418969bc434d16ae1476f781b1e758","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/webpack/prod.config.js","hash":"4e5e59d35c811165766664e5c75e7514e9628048","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/README.md","hash":"9d9945caa066db6235549c7c04577a0236bb1592","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/ecosystem.md","hash":"f279d4d931ab54ee30757750c4ea8abe7789a32f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/docs/zh-Hans/support.md","hash":"24818a7cd01332b244a36b48fb3953afc2e7bdf3","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/css/index.scss","hash":"8bf2b70ad24911997890528cadaa08ea385b8b24","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/bar.js","hash":"74a16047fc0da8486a33de6cf3ecc881b2568988","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/controller.js","hash":"3c911f91bbefa7ecba08f1ccccc1cc6b40c500d0","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/events.js","hash":"f9bbe87494ec4a43daadc1ecd39c8a0541f4e434","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/index.js","hash":"b06b620244638433bf0e7015b932bca02e3db19c","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/list.js","hash":"126cf10a75251627862d1effb86f3992deddfe5b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/lrc.js","hash":"3a550a5d506ef4fb0ece608853f73542f37542ba","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/options.js","hash":"a69e3f87d68466ce97588e43c4745f0192b843b1","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/player.js","hash":"6df7fa9653982d95e0f82974ccfc69a25f6953ba","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/storage.js","hash":"820619bc8d78de4d430ffb866e740b51cdd780c6","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/template.js","hash":"5846a37ee44ef0eaca4376b98149e78bfaac4b67","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/timer.js","hash":"05ccc546427a055712ddbf8e0136ffb6b9f9f33c","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/js/utils.js","hash":"c1c4eba6d261c132beed0cdd073e0adc65ed9a9f","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/src/template/player.art","hash":"eda981e8ed56d6d7bc81182e969f4766869b2662","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/yarn.lock","hash":"5fe4573f0f6aaad024a40503520848f63cba1257","modified":1522338206000},{"_id":"themes/Butterfly/source/APlayer-1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1522338206000},{"_id":"public/APlayer-1.10.1/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/CNAME","hash":"5b5021c61cf084dc192c225d2532dba17d765d5a","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/css/index.scss","hash":"8bf2b70ad24911997890528cadaa08ea385b8b24","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/template/player.art","hash":"eda981e8ed56d6d7bc81182e969f4766869b2662","modified":1611414505367},{"_id":"public/APlayer-1.10.1/package.json","hash":"f711b300f93d6fafef0d69e379e124ce91c38769","modified":1611414505367},{"_id":"public/APlayer-1.10.1/demo/demo.js","hash":"91511c265365b2d0b3e5fec44eed699ae5e35476","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/music.js","hash":"9fcf661ba67c3f932b9eb13261ab1e93a259b93c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/config.js","hash":"03ea6f8a9ee71aacca6ca30360951526f97e39de","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/dev.config.js","hash":"f4c5ca8858374d7d457d4d20994b1e3c7151c19b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/postcss.config.js","hash":"b319d7a602418969bc434d16ae1476f781b1e758","modified":1611414505367},{"_id":"public/APlayer-1.10.1/webpack/prod.config.js","hash":"4e5e59d35c811165766664e5c75e7514e9628048","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/bar.js","hash":"74a16047fc0da8486a33de6cf3ecc881b2568988","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/controller.js","hash":"3c911f91bbefa7ecba08f1ccccc1cc6b40c500d0","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/events.js","hash":"f9bbe87494ec4a43daadc1ecd39c8a0541f4e434","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/index.js","hash":"b06b620244638433bf0e7015b932bca02e3db19c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/list.js","hash":"126cf10a75251627862d1effb86f3992deddfe5b","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/lrc.js","hash":"3a550a5d506ef4fb0ece608853f73542f37542ba","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/options.js","hash":"a69e3f87d68466ce97588e43c4745f0192b843b1","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/player.js","hash":"6df7fa9653982d95e0f82974ccfc69a25f6953ba","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/storage.js","hash":"820619bc8d78de4d430ffb866e740b51cdd780c6","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/template.js","hash":"5846a37ee44ef0eaca4376b98149e78bfaac4b67","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/timer.js","hash":"05ccc546427a055712ddbf8e0136ffb6b9f9f33c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/src/js/utils.js","hash":"c1c4eba6d261c132beed0cdd073e0adc65ed9a9f","modified":1611414505367},{"_id":"public/APlayer-1.10.1/README.html","hash":"d4a83e323a294d8b05e89d5251c667f5808c4931","modified":1611414505367},{"_id":"public/APlayer-1.10.1/demo/index.html","hash":"efc650972f5415453c25d48fdf40afbe35256602","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/ecosystem.html","hash":"62798ead4a2a974c856f2779cff2e3f20e314e20","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/index.html","hash":"1cfe6294406deaea3b3b78a9a5ff9ec5f58ae96d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/support.html","hash":"61ea2536908b167d20deb1849820e3462d8d6176","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/ecosystem.html","hash":"69ea6483810741c04359a2573ad47764f7e2aad4","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/support.html","hash":"a2268752ed7678a3cfbc59e7555ad352c13db872","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/README.html","hash":"54cac2cd9a05a02d5bc392f4274534e91dc5a39c","modified":1611414505367},{"_id":"public/APlayer-1.10.1/docs/zh-Hans/README.html","hash":"5ab4ebe380e311c888793479a3b87929b85dad4d","modified":1611414505367},{"_id":"public/APlayer-1.10.1/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1611414505367},{"_id":"public/APlayer-1.10.1/yarn.lock","hash":"5fe4573f0f6aaad024a40503520848f63cba1257","modified":1611414505367},{"_id":"source/tags/index.md","hash":"c2ab47b114eb7cd934eddfc3f3a4bbe44e9739c0","modified":1611415953608},{"_id":"public/tags/index.html","hash":"3a248276c2f2a13ef332604d4a94daa32ae43ef3","modified":1611416568401}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2021-01-23T15:27:35.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-01-23 23:27:35\ntype: tags\nlayout: tags\n---\n","updated":"2021-01-23T15:32:33.608Z","path":"tags/index.html","_id":"ckk9vex080000g26wf4mf8ihy","comments":1,"content":"","site":{"data":{}},"cover":"https://i.imgur.com/RRUe0Mo.png","excerpt":"","more":""}],"Post":[{"title":"GAMES101_学习笔记","date":"2020-06-19T13:45:43.000Z","top_img":"/img/cover/games101.webp","cover":"/img/cover/games101.webp","mathjax":true,"_content":"\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","source":"_posts/GAMES101-学习笔记.md","raw":"---\ntitle: GAMES101_学习笔记\ndate: 2020-06-19 21:45:43\ntop_img: /img/cover/games101.webp\ncover: /img/cover/games101.webp\ntags: 笔记\nmathjax: true\n---\n\n## Computer Graphics\n[课程视频](https://www.bilibili.com/video/BV1X7411F744)\n\n学习新知识的方式：Why, What and How\n\n### Lecture3. Transformation\n#### 2D变换\n+ 缩放矩阵(Scale)\n$$\\left[ \\begin{matrix}\n   x' \\\\ y'\n  \\end{matrix}\n  \\right] = \\left[\n \\begin{matrix}\n   s_x & 0 \\\\\n   0 & s_y\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{1}\n$$\n\n+ 反射/对称矩阵(Reflection)\n以水平对称为例：\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   -1 & 0 \\\\\n   0 & -1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{2}\n$$\n\n+ 切片矩阵(Shear)\n$$\n  \\left[\n \\begin{matrix}\n   x'\\\\\n   y'\n  \\end{matrix}\n  \\right] = \n  \\left[\n \\begin{matrix}\n   1 & a \\\\\n   0 & 1\n  \\end{matrix}\n  \\right]\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y\n  \\end{matrix}\n  \\right]\n   \\tag{3}\n$$\n\n+ 旋转变换(Rotate)\n$$ R_\\theta = \n    \\left[\n        \\begin{matrix}\n        cos\\theta & -sin\\theta \\\\ \n        sin\\theta & cos\\theta \n    \\end{matrix}\n    \\right]\n    =>\n    \\left[\n        \\begin{matrix}\n        x' \\\\ y' \n        \\end{matrix}\n    \\right] = R_\\theta \n    \\left[\n        \\begin{matrix}\n        x \\\\ y \n        \\end{matrix}\n    \\right]\n    \\tag{4}\n$$\n\n+ 逆变换(Inverse)\n求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 \n\n#### 齐次坐标\n+ 为什么要用齐次坐标？\n    + 将各种变换进行统一，可以用统一的矩阵T表示变换矩阵\n增加一维：\n+ 2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ \n+ 2D向量：$(x, y, 0)^T$,\n    + 向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)\n+ 三维坐标同理\n\n#### 矩阵知识\n+ 某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵\n\n### Lecture4. 观测变换(Viewing transformation)\n#### 视图变换(View/Model transformation)\n\n简而言之是照相机(观察点)的位置\n+ Position: $\\hat{e}$\n+ Look-at: $\\hat{g}$\n+ Up direction: $\\hat{t}$\n\n照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。\n\n+ 先平移$\\hat{e}$到原点\n    $$T_{view} = \n        \\left[ \n            \\begin{matrix}\n            1 & 0 & 0 & -x_e \\\\\n            0 & 1 & 0 & -y_e \\\\\n            0 & 0 & 1 & -z_e \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] $$\n+ 旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：\n    $$R_{view}^{-1} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n            y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n            z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right] \n        => \n        R_{view} = \n        \\left[ \n            \\begin{matrix}\n            x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n            x_{t} & y_{t} & z_{t} & 0 \\\\\n            x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n            0 & 0 & 0 & 1\n            \\end{matrix}\n        \\right]\n    $$\n\n相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。\n#### 投影变换(projection transformation)\n\n##### 正交投影(Orthographic projection)\n\n##### 透视投影(Perspective projection)\n透视投影->正交投影，+正交投影就得到了透视投影\n\n假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面\n+ 挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。\n\n根据相似三角形的对应关系得到最终挤压矩阵$M_{persp->ortho}$:\n$$ M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]\n$$\n$ => M_{persp->ortho}*M_{persp} = M_{ortho}$\n\n### Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\n光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。\n\n锯齿：由于采样->光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。\n\n由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。\n\n走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。\n\n+ 时域的卷积==频域的乘积\n+ 高通滤波求边界，低通滤波模糊\n\n#### 反采样的方法\n+ 增加采样率：像素小，采样率更高\n    + 这是物理限制。\n+ 采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理\n    + 如何模糊：低通滤波器过滤掉高频波-->各种滤波器\n    + 结果：效果还可以，先采样后模糊不行\n+ 超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果\n\n#### z-buffer\n+ 复杂度：O(n)，n是三角形的个数\n+ 可能不只是对每个像素操作，而是对每个采样点操作，比如超采样\n+ 处理不了透明物体，因为有$\\alpha$\n\n#### Shadow Mapping\n单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。\n\n重要现象：阴影中的点只有视点能看到，但是光源看不到\n\n过程：\n+ 从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）\n+ 从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。\n\n问题：\n+ 只能做硬阴影（point light only），边缘非常锐利\n+ 数值精度导致深度对比判断有问题\n+ 光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。\n\n软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。\n\n### Lecture7/8/9. Shading\n#### Illumination & Shading\n##### Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\n+ 1.基础定义：\n    + 视点向量：v\n    + 光源向量：l\n    + 物体法线向量：n\n+ 2.Lambert's余弦定律：$cos\\theta = l \\cdot n$\n+ 3.点光源的传播随距离增加而衰减，$r^2$级\n+ 结合1/2/3 =>\n    + 反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$\n    + $k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + 与观察方向v无关，漫反射向各方向的反射相同\n+ 4.关于高光的定义\n    + 镜面反射方向向量: R\n    + 半程向量: h ($h = \\frac{v+l}{||v+l||}$)\n+ 5.半程向量h与法线向量n是否接近\n+ 结合4/5 =>\n    + 镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$\n    + $k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_i$: 光的颜色\n    + $p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200\n+ 环境光照ambient：$L_a = k_aI_a$\n    + $k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值\n    + $L_a$: 光的颜色\n    + 不考虑光线方向、观察方向、法线方向\n    + 真正的全局光照非常复杂，这里是大胆假设，简化了模型\n+ 结合ambient + diffuse + specular => \n    + $L = L_a + L_d + L_s$\n\n##### Shading频率\n+ Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样\n    + 效果较差\n+ Gouraud shading\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n        + 各面求和或加权求和，再归一化\n    + 三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)\n+ Phong Shading：逐像素\n    + 求出所有顶点法线向量，计算出各顶点颜色值\n    + 三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)\n    + 逐像素着色\n\n#### Grahics Pipeline(图形管线)\n![Graphics Pipeline](/img/games101/graphicspipeline.png)\n\n+ Vertex Shader: 顶点着色器\n+ Fragment Shader: 像素/片段着色器\n\n#### Texture Mapping(纹理映射)\n+ 纹理放大：\n    + 双线性插值\n    + 双立方（三次）插值\n        + 效果更好，开销更大\n\n+ Mipmap\n    + 快速的、近似的、方形的范围查询\n    + 根据原纹理计算出更小分辨率的纹理\n    + 计算level D的Mipmap:\n        + $L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$\n        + $D = log_2L$\n    + 现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果\n        + 1.在D层求插值\n        + 2.在D+1层求插值\n        + 3.求层与层的插值\n+ Anisotropic Filter(各向异性过滤)\n    + Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略\n##### 插值\n+ 线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$\n+ 双线性插值：\n    + $u_0 = lerp(s, u_{00}, u_{10})$\n    + $u_1 = lerp(s, u_{01}, u_{11})$\n    + $f(x, y) = lerp(t, u_0, u_1)$\n#### 重心坐标\n+ 三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha >=0 \\beta>=0, \\gamma>=0$\n+ 重心：$\\alpha = \\beta = \\gamma = 1/3$\n\n+ 结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。\n+ 三维空间中需要先计算插值再投影\n+ 投影之后没有不变性，这是缺点\n\n#### 纹理应用\n+ Environment Map(环境映射): 记录环境中各种光照信息\n    + sphere map\n    + cube map：将sphere map的内容映射到cube上\n+ 凹凸映射(Bump mapping)\n    + 并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height->normal->shading\n    + 纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$\n    + 纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$\n    + 最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$\n+ 位移贴图(Displacment Mapping)\n    + 也是存了高度，但是真的改了顶点位置\n    + 模型更细致更好，能更好的表现贴图结果\n\n### Lecture10/11/12. Geometry\n+ 分类：隐式几何，显式几何\n    + 结合需要进行选择\n+ 隐式几何：\n    + 不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$\n    + 具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易\n+ 显式几何：\n    + 直接给出所有点坐标，或者用参数映射\n        + 参数映射：\n            + 遍历(u, v)就能得到所有点的集合\n            + 例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$\n    + 判断内外位置很复杂，判断形状比较简单\n\n#### 隐式表现方法\n+ CSG\n    + Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何\n+ Signed Distance Function(符号距离函数)\n+ Level Set(水平集)\n+ Fractal(分形)\n\n#### 显式表现方法\n+ 点云\n+ 多边形网格\n+ 贝塞尔曲线(通过参数t定义)\n#### 贝塞尔曲线\n用一系列的控制点$p_0...p_n$去定义某个曲线。\n\n曲线一定经过$p_0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p_{n-1}$，$p_n$的切线相同\n\n+ 画线的算法：\n    + 假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t<1)的点在哪。遍历就能画出曲线上的所有点\n    + 推导过程见下图，就是一个递归求t的过程 ![bezier t](/img/games101/beziert.png)\n    + 总结公式：(n+1)个控制点$p_0...p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum_{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值\n        + $B_i^n(t) = \\left( \\begin{matrix} n \\\\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$\n\n+ 仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。\n+ 投影变换下不适用。\n+ 凸包性质：不会超过给定控制点形成的凸包范围\n\n##### 逐段贝塞尔曲线\n复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。\n+ 连续性：\n    + c0连续：曲线A的终点就是曲线B的起点\n    + c1连续：c0连续，且该重合点切线相同\n\n##### B-splines(B样条曲线)\n比贝塞尔曲线更好，修改的时候只有局部会发生改变\n\n##### 贝塞尔曲面\n简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。\n\n因此这里需要两个参数$t_1$，$t_2$\n\n#### Mesh Operations(网格操作)\n\n#### Mesh Subvision(网格细分)(UpSampling)\n+ Loop细分\n    + 将一个三角形分成4个（各边中点相连）\n    + 对各新旧顶点进行不同的顶点位置更新\n        + 对新顶点的更新方式：（白点） ![new vertex](/img/games101/new_vertex.png)\n        + 对旧顶点的更新方式：（白点） \n            + n: 该顶点的度\n            + u: 考虑周围顶点的值\n            + ![old vertex](/img/games101/old_vertex.png)\n    + 只能用三角形面\n+ Catmull-Clark细分\n    + 基础定义：\n        + quad face: 四边形的面，non-quad face: 非四边形的面\n        + Extraordinary vertex: 奇异点，度不为4的点\n    + 取各边和各面的中点，并且面中点与边中点连接\n    + 一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。\n    + 点的更新\n        + 面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：\n        + ![Catmull Clark](/img/games101/catmull_clark.png)\n\n#### Mesh Simplification(网格简化)(DownSampling)\n+ Collapse Edge：一条边坍缩成一个点\n    + Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置\n        + 问题：某边的坍缩会影响相邻边的二次误差度量值 => 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值\n        + 这其实是贪心算法，没法全局取坍缩的边\n\n#### Mesh Regularization(网格正则化)(Same #Triangles)\n\n### Lecture13/14/15/16. Ray Tracing\n光线追踪需要解决的问题：\n+ 软阴影(Soft shadows)\n+ Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)\n+ 间接光照(Indirect illumination): 类似于环境光的真实模拟\n\n光线追踪类型：\n+ Pinhole Ray Tracing\n+ Recursive(Whitted-style) Ray Tracing\n    ![recurcive ray tracing](/img/games101/recurcive_raytracing.png)\n\n#### 光线追踪的技术问题\n+ 光线与物体表面的焦点\n    + 光线：$r(t) = oringin + t * direction, 0 \\le t < \\infty$\n    + 与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 \n    + 与显式表面相交计算，\n        + 也就是与三角形求交点 <=> 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p') \\cdot N = (origin + t * direction - p') \\cdot N = 0 => t = \\frac{p'\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t < \\infty$\n        + Moller Trumbore算法：\n            + 光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：\n            $\\left[ \\begin{matrix} t \\\\ b_1 \\\\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\\\ S_1 \\cdot S \\\\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\\\  E_2 = p_2 - p_0 \\\\ S = O-p_0 \\\\ S_1=D \\times E_2 \\\\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t < \\infty \\\\ 0 \\le b_1 \\le 1 \\\\ 0 \\le b_2 \\le 1 \\\\  \\end{matrix}$\n\n+ 加速光线与表面求交的加速(显然不能与每个三角形都求一次)\n    + Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。\n        + Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。\n    + Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大\n    + 空间划分：\n        划分的停止条件，某块为空或者块内的物体数量足够少\n        + Oct Tree: 八叉树\n        + KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x->y->z->x->y->z...\n            + 并不是按物体划分，因此后续的物体判断比较复杂\n        + BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.\n        ![spatial partition](/img/games101/spatial_partition.png)\n    + Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。\n        + 问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题\n\n#### Basic radiometry(辐射度量学)\n物理上准确定义光线的方法。\n\n基础定义：\n+ Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$\n+ Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率\n+ Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$\n    + 立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$\n+ Irradiance：\n    + 接受辐射，或者是光源往外辐射\n    + $E(x) = \\frac{d(\\Phi)}{dA}$\n    + 联系Lambert's Cosine Law，因为有这个定义，才有那个法则\n    + 也能解释季节变化，因为自转导致直射纬度在变\n    + <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/irradiance_falloff.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                Irradiance衰减图示\n            </div>\n        </center>\n+ radiance：\n    + 单位立体角、单位辐射面积上的功率\n    + $L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角\n\n#### BRDF\nBRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布\n\n+ BRDF：某个入射方向的出射方向的贡献分布计算式\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/rushe_fanshe.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            BRDF: 入射光与反射光\n        </div>\n    </center>\n+ 反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）\n    + $L_r(p, \\omega_r) = \\int_{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$\n+ 渲染方程：\n    + 反射光 = 自己发光+反射别人的光\n    + $L_o(p,\\omega_o) = L_e(p, \\omega_o) + \\int_{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$\n    + 方程简化\n        + 最终算式：$L = E + KE+K^2E+ K^3E+...$\n        ![original](/img/games101/brdf1.png) ![./simmplify](/img/games101/brdf2.png)\n    + 光栅化只能做到$E$和$E+KE$\n\n#### Monte Carlo Intergration(蒙特卡洛积分)\n求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$\n\n+ 常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确\n\n#### 解渲染方程\n+ Simple蒙特卡洛解法(不考虑自光源)\n    + 直接光照下\n        $L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i\n        =\\frac{1}{N} \\sum_{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$\n+ 考虑物体发光，也就是考虑间接反射。\n    + 只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/motekarluo_n.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                蒙特卡洛方法——N\n            </div>\n        </center>\n+ 每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/motekarluo_1.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            蒙特卡洛方法——1\n        </div>\n    </center>\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/ray_generation.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Ray Generation\n        </div>\n    </center>\n+ 解决无限递归：采用概率p决定是否往下递归。伪代码如下：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/games101/recursion_solution.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            解决无限递归\n        </div>\n    </center>\n\n+ 在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量\n    + 首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta'}{||x'-p||^2} dA$，$\\theta'$是光源面的法线向量与入射光线的夹角，$||x'-p||^2$光源点到入射点的距离的平方(这个不难理解)\n    + 得到新的渲染方程：$L_o(a,\\omega_o) \n        =\\int_{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta'}{||x'-p||^2} dA$\n    + 因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。\n    + 注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。\n    + 伪代码如下：\n        <center>\n            <img style=\"border-radius: 0.3125em;\n            box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n            src=\"/img/games101/lightsource.png\">\n            <br>\n            <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n            display: inline-block;\n            color: #999;\n            padding: 2px;\">\n                光源采样\n            </div>\n        </center>\n\n### Lecture17. Materials and Appearances(材质外观)\n+ Diffuse / Lambertian Material\n    + BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置\n+ Glossy Material(抛光金属)\n+ Ideal reflective / refractive material (BSDF*)\n    + 水、玻璃等既可反射也可折射的材质(也有部分吸收)\n    + 折射定律：Snell's Law \n        + $\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$\n+ Specular \n+ Fresnel Term(菲涅尔项，$\\eta = 1.5$)\n    + 视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。\n    + Schlick's近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。\n+ Microfacet Material(微表面材料，非常重要！！！)\n    + 从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。\n    + 近处是几何，远处的材质\n    + 因此，微表面上法线方向不同但大体相同也就是Glossy的材质\n    + $f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$\n        + F(i, h)：$F_{Schlick} = C_{spec} + (1-C_{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C_{spec}$)，菲涅尔项，描述光的反射与折射量\n        + G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况\n        + D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布\n            <center>\n                <img style=\"border-radius: 0.3125em;\n                box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n                src=\"/img/games101/microfacet.png\">\n                <br>\n                <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n                display: inline-block;\n                color: #999;\n                padding: 2px;\">\n                    微表面模型\n                </div>\n            </center>\n+ Isotropic / Anisotropic Materials(各向同性/各向异性材料)\n    + 与绝对方位角有关\n\n### Lecture18. Advanced Topics in Rendering\n+ 无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)\n+ 有偏：biased，与unbiased相反。\n    + 一致：consistent，原本有偏，收敛之后是无偏的。\n\n#### 无偏光线传播算法\n+ BDPT: Bidrectional Path Tracing\n    + 从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。\n    + 很难实现，速度也很慢，对某些情况的效果很好。\n+ MLT: Metropolis Light Transport\n    + 马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径\n    + 复杂光路上效果很好。但是很难判断是否收敛\n\n#### 有偏光线传播算法\n+ Photon Mapping\n    + 能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics\n        + caustics: 由于光线聚焦产生的非常强烈的图案\n    + 实现过程\n        + stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。\n        + 计算：local density estimation\n            + 对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。\n            + N越小的时候，noise就会比较大\n+ Vertex Connection and Merging\n    + BDPT和Photon Mapping的组合\n+ Instant Radiosity(IR)实时辐射度\n    + 不能处理Glossy的物体\n\n### Lecture19. Cameras, Lenses and Light Fields\n### Lecture20. Color and Perception\n上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。\n\n### Lecture21/22. Animation\n+ 关键帧动画\n+ 质点弹簧系统\n+ 粒子系统\n+ Forward Kinematics\n+ Rigging(绑定)\n\n#### Euler方法\n+ 一阶(前向)欧拉方法\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^t, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^t$\n    + 受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差\n    + 非常不稳定，可能会出现不符合实际规律得到结果\n+ 中点法（Midpoint method）\n    + $x_{mid} = x^t + \\Delta t /2 \\cdot x'^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x'_{mid}$\n    + 上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x'^t + \\frac{(\\Delta t)^2}{2} x''^t$\n+ Implicit Euler Method\n    + 与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量\n    + $x^{t+ \\Delta t} = x^t + \\Delta t x'^{t+ \\Delta t}, x'^{t+ \\Delta t} = x'^t + \\Delta t x''^{t+ \\Delta t}$\n+ Runge Kutta Method\n    + RK4,4阶，最常用\n    + 假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$\n    + 有$y_{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t_{n+1} = t_n + h$\n    + 上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\\\ k_2 \\\\ k_3 \\\\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\\\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\\\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$\n+ Position Based / Verlet Integration\n\n#### 大规模粒子的模拟方法\n+ 拉格朗日法（质点法）\n    + 对每个单独的粒子计算其运动变化规律\n+ 欧拉法（网格法）\n    + 划分空间，以空间为单位考虑\n+ Material Point Method(MPM)\n    + 现在非常热门的方法，也是拉格朗日法和的结合","slug":"GAMES101-学习笔记","published":1,"updated":"2021-01-21T03:00:06.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e2x00003a6w2zzn7o85","content":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M<em>{persp-&gt;ortho}*M</em>{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u<em>0 = lerp(s, u</em>{00}, u_{10})$</li>\n<li>$u<em>1 = lerp(s, u</em>{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p<em>0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p</em>{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p<em>0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum</em>{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\ b_1 \\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\ S_1 \\cdot S \\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\  E_2 = p_2 - p_0 \\ S = O-p_0 \\ S_1=D \\times E_2 \\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\ 0 \\le b_1 \\le 1 \\ 0 \\le b_2 \\le 1 \\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L<em>r(p, \\omega_r) = \\int</em>{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L<em>o(p,\\omega_o) = L_e(p, \\omega_o) + \\int</em>{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L<em>i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum</em>{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F<em>{Schlick} = C</em>{spec} + (1-C<em>{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C</em>{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x<em>{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’</em>{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y<em>{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t</em>{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\ k_2 \\ k_3 \\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Computer-Graphics\"><a href=\"#Computer-Graphics\" class=\"headerlink\" title=\"Computer Graphics\"></a>Computer Graphics</h2><p><a href=\"https://www.bilibili.com/video/BV1X7411F744\" target=\"_blank\" rel=\"noopener\">课程视频</a></p>\n<p>学习新知识的方式：Why, What and How</p>\n<h3 id=\"Lecture3-Transformation\"><a href=\"#Lecture3-Transformation\" class=\"headerlink\" title=\"Lecture3. Transformation\"></a>Lecture3. Transformation</h3><h4 id=\"2D变换\"><a href=\"#2D变换\" class=\"headerlink\" title=\"2D变换\"></a>2D变换</h4><ul>\n<li><p>缩放矩阵(Scale)</p>\n<script type=\"math/tex; mode=display\">\\left[ \\begin{matrix}\n x' \\\\ y'\n\\end{matrix}\n\\right] = \\left[\n\\begin{matrix}\n s_x & 0 \\\\\n 0 & s_y\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{1}</script></li>\n<li><p>反射/对称矩阵(Reflection)<br>以水平对称为例：</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n -1 & 0 \\\\\n 0 & -1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{2}</script></li>\n<li><p>切片矩阵(Shear)</p>\n<script type=\"math/tex; mode=display\">\n\\left[\n\\begin{matrix}\n x'\\\\\n y'\n\\end{matrix}\n\\right] = \n\\left[\n\\begin{matrix}\n 1 & a \\\\\n 0 & 1\n\\end{matrix}\n\\right]\n\\left[\n\\begin{matrix}\n x \\\\\n y\n\\end{matrix}\n\\right]\n \\tag{3}</script></li>\n<li><p>旋转变换(Rotate)</p>\n<script type=\"math/tex; mode=display\">R_\\theta = \n  \\left[\n      \\begin{matrix}\n      cos\\theta & -sin\\theta \\\\ \n      sin\\theta & cos\\theta \n  \\end{matrix}\n  \\right]\n  =>\n  \\left[\n      \\begin{matrix}\n      x' \\\\ y' \n      \\end{matrix}\n  \\right] = R_\\theta \n  \\left[\n      \\begin{matrix}\n      x \\\\ y \n      \\end{matrix}\n  \\right]\n  \\tag{4}</script></li>\n<li><p>逆变换(Inverse)<br>求原先变换矩阵$M$的逆矩阵$M^{-1}$即可。 </p>\n</li>\n</ul>\n<h4 id=\"齐次坐标\"><a href=\"#齐次坐标\" class=\"headerlink\" title=\"齐次坐标\"></a>齐次坐标</h4><ul>\n<li>为什么要用齐次坐标？<ul>\n<li>将各种变换进行统一，可以用统一的矩阵T表示变换矩阵<br>增加一维：</li>\n</ul>\n</li>\n<li>2D点：$(x, y, 1)^T$，or $(x, y, w)^T = (x/w, y/w, 1)$ 并且 $w!=0$ </li>\n<li>2D向量：$(x, y, 0)^T$,<ul>\n<li>向量加0是为了保护向量的平移不变性，同时可以区分向量与点，而且向量与点的计算结果类型也得到直观体现(1为点，0为向量)</li>\n</ul>\n</li>\n<li>三维坐标同理</li>\n</ul>\n<h4 id=\"矩阵知识\"><a href=\"#矩阵知识\" class=\"headerlink\" title=\"矩阵知识\"></a>矩阵知识</h4><ul>\n<li>某矩阵的逆矩阵和转置矩阵相同，则该矩阵为正交矩阵</li>\n</ul>\n<h3 id=\"Lecture4-观测变换-Viewing-transformation\"><a href=\"#Lecture4-观测变换-Viewing-transformation\" class=\"headerlink\" title=\"Lecture4. 观测变换(Viewing transformation)\"></a>Lecture4. 观测变换(Viewing transformation)</h3><h4 id=\"视图变换-View-Model-transformation\"><a href=\"#视图变换-View-Model-transformation\" class=\"headerlink\" title=\"视图变换(View/Model transformation)\"></a>视图变换(View/Model transformation)</h4><p>简而言之是照相机(观察点)的位置</p>\n<ul>\n<li>Position: $\\hat{e}$</li>\n<li>Look-at: $\\hat{g}$</li>\n<li>Up direction: $\\hat{t}$</li>\n</ul>\n<p>照相机摆放到原点，并将观察方向指向-Z，Up方向指向Y。</p>\n<ul>\n<li>先平移$\\hat{e}$到原点<script type=\"math/tex; mode=display\">T_{view} = \n      \\left[ \n          \\begin{matrix}\n          1 & 0 & 0 & -x_e \\\\\n          0 & 1 & 0 & -y_e \\\\\n          0 & 0 & 1 & -z_e \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n<li>旋转观察方向和up方向，直接秋旋转矩阵不好求，但是可以根据正交矩阵逆与转置相同的性质先求旋转的逆矩阵，即：<script type=\"math/tex; mode=display\">R_{view}^{-1} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & x_{t} & x_{-g} & 0 \\\\\n          y_{\\hat{g}\\times\\hat{t}} & y_{t} & y_{-g} & 0 \\\\\n          z_{\\hat{g}\\times\\hat{t}} & z_{t} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right] \n      => \n      R_{view} = \n      \\left[ \n          \\begin{matrix}\n          x_{\\hat{g}\\times\\hat{t}} & y_{\\hat{g}\\times\\hat{t}} & z_{\\hat{g}\\times\\hat{t}} & 0 \\\\\n          x_{t} & y_{t} & z_{t} & 0 \\\\\n          x_{-g} & y_{-g} & z_{-g} & 0 \\\\\n          0 & 0 & 0 & 1\n          \\end{matrix}\n      \\right]</script></li>\n</ul>\n<p>相机移动之后，模型也需要根据这些矩阵移动到相对应的位置，以保持和相机的相对位置不变。</p>\n<h4 id=\"投影变换-projection-transformation\"><a href=\"#投影变换-projection-transformation\" class=\"headerlink\" title=\"投影变换(projection transformation)\"></a>投影变换(projection transformation)</h4><h5 id=\"正交投影-Orthographic-projection\"><a href=\"#正交投影-Orthographic-projection\" class=\"headerlink\" title=\"正交投影(Orthographic projection)\"></a>正交投影(Orthographic projection)</h5><h5 id=\"透视投影-Perspective-projection\"><a href=\"#透视投影-Perspective-projection\" class=\"headerlink\" title=\"透视投影(Perspective projection)\"></a>透视投影(Perspective projection)</h5><p>透视投影-&gt;正交投影，+正交投影就得到了透视投影</p>\n<p>假设相机在原点，近景z坐标为n，远景z坐标为f。如何挤压远景得到和近景等大的正交投影的画面</p>\n<ul>\n<li>挤压后近景完全不变，而远景的x、y坐标与近景一致，z坐标不变。</li>\n</ul>\n<p>根据相似三角形的对应关系得到最终挤压矩阵$M_{persp-&gt;ortho}$:</p>\n<script type=\"math/tex; mode=display\">M_{persp->ortho} = \n    \\left[\n        \\begin{matrix}\n        n & 0 & 0 & 0 \\\\\n        0 & n & 0 & 0 \\\\\n        0 & 0 & n+f & -nf \\\\\n        0 & 0 & 1 & 0 \\\\\n        \\end{matrix}\n    \\right]</script><p>$ =&gt; M<em>{persp-&gt;ortho}*M</em>{persp} = M_{ortho}$</p>\n<h3 id=\"Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\"><a href=\"#Lecture5-6-Rasterization-光栅化-Antialiasing-反采样-抗锯齿\" class=\"headerlink\" title=\"Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)\"></a>Lecture5/6. Rasterization(光栅化)/Antialiasing(反采样/抗锯齿)</h3><p>光栅化：简而言之就是将图形空间里的models采样到二维图像里，并通过以希望物理设备进行展示，也就是现在的各类显示器。</p>\n<p>锯齿：由于采样-&gt;光栅化这个过程中的最小单位是像素，是从连续到不连续，因此采样的结果与实际有区别，常常会形成锯齿。因此需要技术来解决这个问题，即抗锯齿。</p>\n<p>由傅立叶变换可知，任意函数可以转换为许多不同频率的信号之和，因此对于不同频率的信号不能使用相同频率的采样方法，否则采样的结果会与实际差距太大。</p>\n<p>走样：不同频率的函数的采样结果无法区分（说明采样频率有问题），因此出现走样。</p>\n<ul>\n<li>时域的卷积==频域的乘积</li>\n<li>高通滤波求边界，低通滤波模糊</li>\n</ul>\n<h4 id=\"反采样的方法\"><a href=\"#反采样的方法\" class=\"headerlink\" title=\"反采样的方法\"></a>反采样的方法</h4><ul>\n<li>增加采样率：像素小，采样率更高<ul>\n<li>这是物理限制。</li>\n</ul>\n</li>\n<li>采样前模糊(Pre-Filter)：没有改进判断单个像素颜色的方法，而是对图形进行模糊处理<ul>\n<li>如何模糊：低通滤波器过滤掉高频波—&gt;各种滤波器</li>\n<li>结果：效果还可以，先采样后模糊不行</li>\n</ul>\n</li>\n<li>超采样：对单个像素进行多点采样，再将采样结果进行卷积（也就是平均/滤波），就可以实现更精准的模糊效果</li>\n</ul>\n<h4 id=\"z-buffer\"><a href=\"#z-buffer\" class=\"headerlink\" title=\"z-buffer\"></a>z-buffer</h4><ul>\n<li>复杂度：O(n)，n是三角形的个数</li>\n<li>可能不只是对每个像素操作，而是对每个采样点操作，比如超采样</li>\n<li>处理不了透明物体，因为有$\\alpha$</li>\n</ul>\n<h4 id=\"Shadow-Mapping\"><a href=\"#Shadow-Mapping\" class=\"headerlink\" title=\"Shadow Mapping\"></a>Shadow Mapping</h4><p>单独的光栅化不考虑物体间的相互遮挡，然而这与实际不符，于是引入Shadow Mapping。但它还是存在走样现象的。</p>\n<p>重要现象：阴影中的点只有视点能看到，但是光源看不到</p>\n<p>过程：</p>\n<ul>\n<li>从光源（必须是点光源）看向场景，根据z-buffer的方式记录各点的深度值（以像素为单位，总体上也就是一次光栅化）</li>\n<li>从摄像机/眼睛看向场景，对看到的每个点，查看光源记录的深度。如果记录的深度与点的深度一致，则该点在阴影外；否则，在阴影内。</li>\n</ul>\n<p>问题：</p>\n<ul>\n<li>只能做硬阴影（point light only），边缘非常锐利</li>\n<li>数值精度导致深度对比判断有问题</li>\n<li>光源的分辨率与视点的分辨率不同，又会导致计算的时候会出问题，比如光源分辨率太小就会使得一个像素记录太多信息，即出现了走样。</li>\n</ul>\n<p>软阴影的存在就是因为光源存在大小，而每个顶点并不是都能看到所有光源，因此存在本影与半影的区别，也正是因此才有了软阴影。</p>\n<h3 id=\"Lecture7-8-9-Shading\"><a href=\"#Lecture7-8-9-Shading\" class=\"headerlink\" title=\"Lecture7/8/9. Shading\"></a>Lecture7/8/9. Shading</h3><h4 id=\"Illumination-amp-Shading\"><a href=\"#Illumination-amp-Shading\" class=\"headerlink\" title=\"Illumination &amp; Shading\"></a>Illumination &amp; Shading</h4><h5 id=\"Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\"><a href=\"#Blinn-Phong着色模型：ambient-环境光-diffuse-漫反射-specular-高光\" class=\"headerlink\" title=\"Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)\"></a>Blinn-Phong着色模型：ambient(环境光) + diffuse(漫反射) + specular(高光)</h5><ul>\n<li>1.基础定义：<ul>\n<li>视点向量：v</li>\n<li>光源向量：l</li>\n<li>物体法线向量：n</li>\n</ul>\n</li>\n<li>2.Lambert’s余弦定律：$cos\\theta = l \\cdot n$</li>\n<li>3.点光源的传播随距离增加而衰减，$r^2$级</li>\n<li>结合1/2/3 =&gt;<ul>\n<li>反射出去的值diffuse: $L_d = k_d(L_i/d^2)max(0, n \\cdot l)$</li>\n<li>$k_d$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>与观察方向v无关，漫反射向各方向的反射相同</li>\n</ul>\n</li>\n<li>4.关于高光的定义<ul>\n<li>镜面反射方向向量: R</li>\n<li>半程向量: h ($h = \\frac{v+l}{||v+l||}$)</li>\n</ul>\n</li>\n<li>5.半程向量h与法线向量n是否接近</li>\n<li>结合4/5 =&gt;<ul>\n<li>镜面反射(高光)specular: $L_s = k_s(L_i/r^2)max(0, n \\cdot h)^p$</li>\n<li>$k_s$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_i$: 光的颜色</li>\n<li>$p$: 因为实际高光区域很小，仅仅是余弦不足以表现真实的高光，一般在100~200</li>\n</ul>\n</li>\n<li>环境光照ambient：$L_a = k_aI_a$<ul>\n<li>$k_a$: 材料本身的漫反射系数，表示为(r,g,b)的三通道color值</li>\n<li>$L_a$: 光的颜色</li>\n<li>不考虑光线方向、观察方向、法线方向</li>\n<li>真正的全局光照非常复杂，这里是大胆假设，简化了模型</li>\n</ul>\n</li>\n<li>结合ambient + diffuse + specular =&gt; <ul>\n<li>$L = L_a + L_d + L_s$</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"Shading频率\"><a href=\"#Shading频率\" class=\"headerlink\" title=\"Shading频率\"></a>Shading频率</h5><ul>\n<li>Flat Shading: 每个三角面一个法线向量，面的颜色处理的一模一样<ul>\n<li>效果较差</li>\n</ul>\n</li>\n<li>Gouraud shading<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值<ul>\n<li>各面求和或加权求和，再归一化</li>\n</ul>\n</li>\n<li>三角形内的点通过顶点颜色值作插值得到(即不用求法线向量)</li>\n</ul>\n</li>\n<li>Phong Shading：逐像素<ul>\n<li>求出所有顶点法线向量，计算出各顶点颜色值</li>\n<li>三角形内的像素点的法线向量通过顶点法线向量作插值得到，再计算颜色值(即要求法线向量)</li>\n<li>逐像素着色</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Grahics-Pipeline-图形管线\"><a href=\"#Grahics-Pipeline-图形管线\" class=\"headerlink\" title=\"Grahics Pipeline(图形管线)\"></a>Grahics Pipeline(图形管线)</h4><p><img src=\"/img/games101/graphicspipeline.png\" alt=\"Graphics Pipeline\"></p>\n<ul>\n<li>Vertex Shader: 顶点着色器</li>\n<li>Fragment Shader: 像素/片段着色器</li>\n</ul>\n<h4 id=\"Texture-Mapping-纹理映射\"><a href=\"#Texture-Mapping-纹理映射\" class=\"headerlink\" title=\"Texture Mapping(纹理映射)\"></a>Texture Mapping(纹理映射)</h4><ul>\n<li><p>纹理放大：</p>\n<ul>\n<li>双线性插值</li>\n<li>双立方（三次）插值<ul>\n<li>效果更好，开销更大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Mipmap</p>\n<ul>\n<li>快速的、近似的、方形的范围查询</li>\n<li>根据原纹理计算出更小分辨率的纹理</li>\n<li>计算level D的Mipmap:<ul>\n<li>$L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{du}{dy})^2}, \\sqrt{(\\frac{dv}{dx})^2, (\\frac{dv}{dy})^2})$</li>\n<li>$D = log_2L$</li>\n</ul>\n</li>\n<li>现在的查询是离散的，无法计算类似1.2层的结果。因此有三线性插值的方法，实现比较连续的插值结果<ul>\n<li>1.在D层求插值</li>\n<li>2.在D+1层求插值</li>\n<li>3.求层与层的插值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Anisotropic Filter(各向异性过滤)<ul>\n<li>Mipmap只能处理正方形的纹理缩小，而各向异性过滤可以对不同的维度采取不同的缩小策略<h5 id=\"插值\"><a href=\"#插值\" class=\"headerlink\" title=\"插值\"></a>插值</h5></li>\n</ul>\n</li>\n<li>线性插值：$lerp(x, v_0, v_1) = v_0 + x(v_1-v_0)$</li>\n<li>双线性插值：<ul>\n<li>$u<em>0 = lerp(s, u</em>{00}, u_{10})$</li>\n<li>$u<em>1 = lerp(s, u</em>{01}, u_{11})$</li>\n<li>$f(x, y) = lerp(t, u_0, u_1)$<h4 id=\"重心坐标\"><a href=\"#重心坐标\" class=\"headerlink\" title=\"重心坐标\"></a>重心坐标</h4></li>\n</ul>\n</li>\n<li>三角形内任一点$(x, y) = \\alpha A + \\beta B + \\gamma C, \\alpha+\\beta+\\gamma=1, \\alpha &gt;=0 \\beta&gt;=0, \\gamma&gt;=0$</li>\n<li><p>重心：$\\alpha = \\beta = \\gamma = 1/3$</p>\n</li>\n<li><p>结合重心坐标可以实现各种插值，颜色、纹理坐标、法线向量等等。</p>\n</li>\n<li>三维空间中需要先计算插值再投影</li>\n<li>投影之后没有不变性，这是缺点</li>\n</ul>\n<h4 id=\"纹理应用\"><a href=\"#纹理应用\" class=\"headerlink\" title=\"纹理应用\"></a>纹理应用</h4><ul>\n<li>Environment Map(环境映射): 记录环境中各种光照信息<ul>\n<li>sphere map</li>\n<li>cube map：将sphere map的内容映射到cube上</li>\n</ul>\n</li>\n<li>凹凸映射(Bump mapping)<ul>\n<li>并没有改变任何实际的几何信息，而是通过增加高度来计算新的法线向量，从而改变最终的着色。即：height-&gt;normal-&gt;shading</li>\n<li>纹理图中对u求导得：$dp/du = (\\Delta u, 0, h(u+1)-h(u))$</li>\n<li>纹理图中对v求导得：$dp/dv = (\\Delta v, 0, h(v+1)-h(v))$</li>\n<li>最终法线是两者叉积得到的结果，当然得注意方向：$normal = dp/du \\cdot dp/dv = (-dp/du, -dp/dv, 1)$</li>\n</ul>\n</li>\n<li>位移贴图(Displacment Mapping)<ul>\n<li>也是存了高度，但是真的改了顶点位置</li>\n<li>模型更细致更好，能更好的表现贴图结果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture10-11-12-Geometry\"><a href=\"#Lecture10-11-12-Geometry\" class=\"headerlink\" title=\"Lecture10/11/12. Geometry\"></a>Lecture10/11/12. Geometry</h3><ul>\n<li>分类：隐式几何，显式几何<ul>\n<li>结合需要进行选择</li>\n</ul>\n</li>\n<li>隐式几何：<ul>\n<li>不给实际的点，用隐函数表示点坐标的关系，比如$x^2+y^2+z^2=1$</li>\n<li>具体解释该几何体是什么很复杂，但是判断单个点的内外位置很容易</li>\n</ul>\n</li>\n<li>显式几何：<ul>\n<li>直接给出所有点坐标，或者用参数映射<ul>\n<li>参数映射：<ul>\n<li>遍历(u, v)就能得到所有点的集合</li>\n<li>例：$f(u, v) = ((2+cosu)cosv, (2+cosu)sinv, sinu)$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>判断内外位置很复杂，判断形状比较简单</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"隐式表现方法\"><a href=\"#隐式表现方法\" class=\"headerlink\" title=\"隐式表现方法\"></a>隐式表现方法</h4><ul>\n<li>CSG<ul>\n<li>Constructive Solid Geometry: 将简单的基本几何组合起来得到复杂的几何</li>\n</ul>\n</li>\n<li>Signed Distance Function(符号距离函数)</li>\n<li>Level Set(水平集)</li>\n<li>Fractal(分形)</li>\n</ul>\n<h4 id=\"显式表现方法\"><a href=\"#显式表现方法\" class=\"headerlink\" title=\"显式表现方法\"></a>显式表现方法</h4><ul>\n<li>点云</li>\n<li>多边形网格</li>\n<li>贝塞尔曲线(通过参数t定义)<h4 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h4>用一系列的控制点$p_0…p_n$去定义某个曲线。</li>\n</ul>\n<p>曲线一定经过$p<em>0$和$p_n$，且在$p_0$和$p_n$的切线与$p_0$,$p_1$和$p</em>{n-1}$，$p_n$的切线相同</p>\n<ul>\n<li><p>画线的算法：</p>\n<ul>\n<li>假设$p_0$是时间0的点，$p_n$是时间1的点，需要找出时间t(t&lt;1)的点在哪。遍历就能画出曲线上的所有点</li>\n<li>推导过程见下图，就是一个递归求t的过程 <img src=\"/img/games101/beziert.png\" alt=\"bezier t\"></li>\n<li>总结公式：(n+1)个控制点$p<em>0…p_n$，公式就是$b^n(t)=b_0^n(t) = \\sum</em>{j=0}^nb_jB_j^n(t)$，$B_j^n(t)$就是多项展开式的值<ul>\n<li>$B_i^n(t) = \\left( \\begin{matrix} n \\  i \\end{matrix} \\right) t^i (1-t)^{n-i}$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>仿射变换下贝塞尔曲线是一致的。先变换后画线/先画线后变换是一样的，因此可以只存控制点，做变换之后再画出来，不用记录所有点。</p>\n</li>\n<li>投影变换下不适用。</li>\n<li>凸包性质：不会超过给定控制点形成的凸包范围</li>\n</ul>\n<h5 id=\"逐段贝塞尔曲线\"><a href=\"#逐段贝塞尔曲线\" class=\"headerlink\" title=\"逐段贝塞尔曲线\"></a>逐段贝塞尔曲线</h5><p>复杂曲线由多段简单贝赛尔曲线组成，一般这些简单贝赛尔曲线都是用4个控制点。</p>\n<ul>\n<li>连续性：<ul>\n<li>c0连续：曲线A的终点就是曲线B的起点</li>\n<li>c1连续：c0连续，且该重合点切线相同</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"B-splines-B样条曲线\"><a href=\"#B-splines-B样条曲线\" class=\"headerlink\" title=\"B-splines(B样条曲线)\"></a>B-splines(B样条曲线)</h5><p>比贝塞尔曲线更好，修改的时候只有局部会发生改变</p>\n<h5 id=\"贝塞尔曲面\"><a href=\"#贝塞尔曲面\" class=\"headerlink\" title=\"贝塞尔曲面\"></a>贝塞尔曲面</h5><p>简单来说就是现在u方向上的时间t1上得到n条贝塞尔曲线，然后再对v方向上的时间t2的n个点再求一次贝塞尔曲线的点。</p>\n<p>因此这里需要两个参数$t_1$，$t_2$</p>\n<h4 id=\"Mesh-Operations-网格操作\"><a href=\"#Mesh-Operations-网格操作\" class=\"headerlink\" title=\"Mesh Operations(网格操作)\"></a>Mesh Operations(网格操作)</h4><h4 id=\"Mesh-Subvision-网格细分-UpSampling\"><a href=\"#Mesh-Subvision-网格细分-UpSampling\" class=\"headerlink\" title=\"Mesh Subvision(网格细分)(UpSampling)\"></a>Mesh Subvision(网格细分)(UpSampling)</h4><ul>\n<li>Loop细分<ul>\n<li>将一个三角形分成4个（各边中点相连）</li>\n<li>对各新旧顶点进行不同的顶点位置更新<ul>\n<li>对新顶点的更新方式：（白点） <img src=\"/img/games101/new_vertex.png\" alt=\"new vertex\"></li>\n<li>对旧顶点的更新方式：（白点） <ul>\n<li>n: 该顶点的度</li>\n<li>u: 考虑周围顶点的值</li>\n<li><img src=\"/img/games101/old_vertex.png\" alt=\"old vertex\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>只能用三角形面</li>\n</ul>\n</li>\n<li>Catmull-Clark细分<ul>\n<li>基础定义：<ul>\n<li>quad face: 四边形的面，non-quad face: 非四边形的面</li>\n<li>Extraordinary vertex: 奇异点，度不为4的点</li>\n</ul>\n</li>\n<li>取各边和各面的中点，并且面中点与边中点连接</li>\n<li>一次细分之后，non-quad面都变成了quad面，代价是多了一个奇异点。因此之后无论再做几次，奇异点都不会再增加，因为non-quad面在第一次就没了。</li>\n<li>点的更新<ul>\n<li>面的中心点由四边顶点决定，边中点的规则和旧顶点的规则均如下：</li>\n<li><img src=\"/img/games101/catmull_clark.png\" alt=\"Catmull Clark\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Simplification-网格简化-DownSampling\"><a href=\"#Mesh-Simplification-网格简化-DownSampling\" class=\"headerlink\" title=\"Mesh Simplification(网格简化)(DownSampling)\"></a>Mesh Simplification(网格简化)(DownSampling)</h4><ul>\n<li>Collapse Edge：一条边坍缩成一个点<ul>\n<li>Quadric Error Metrics(二次误差度量)：新的点到与原来的边有关的面的距离的平方和最小，就是该边最优的坍缩位置<ul>\n<li>问题：某边的坍缩会影响相邻边的二次误差度量值 =&gt; 用最小堆，取最小值，更新受影响的值，更新堆，再取最小值</li>\n<li>这其实是贪心算法，没法全局取坍缩的边</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Mesh-Regularization-网格正则化-Same-Triangles\"><a href=\"#Mesh-Regularization-网格正则化-Same-Triangles\" class=\"headerlink\" title=\"Mesh Regularization(网格正则化)(Same #Triangles)\"></a>Mesh Regularization(网格正则化)(Same #Triangles)</h4><h3 id=\"Lecture13-14-15-16-Ray-Tracing\"><a href=\"#Lecture13-14-15-16-Ray-Tracing\" class=\"headerlink\" title=\"Lecture13/14/15/16. Ray Tracing\"></a>Lecture13/14/15/16. Ray Tracing</h3><p>光线追踪需要解决的问题：</p>\n<ul>\n<li>软阴影(Soft shadows)</li>\n<li>Glossy reflection(类似铜镜这种有反射但是不是纯反射还有自身材质的东西)</li>\n<li>间接光照(Indirect illumination): 类似于环境光的真实模拟</li>\n</ul>\n<p>光线追踪类型：</p>\n<ul>\n<li>Pinhole Ray Tracing</li>\n<li>Recursive(Whitted-style) Ray Tracing<br>  <img src=\"/img/games101/recurcive_raytracing.png\" alt=\"recurcive ray tracing\"></li>\n</ul>\n<h4 id=\"光线追踪的技术问题\"><a href=\"#光线追踪的技术问题\" class=\"headerlink\" title=\"光线追踪的技术问题\"></a>光线追踪的技术问题</h4><ul>\n<li><p>光线与物体表面的焦点</p>\n<ul>\n<li>光线：$r(t) = oringin + t * direction, 0 \\le t &lt; \\infty$</li>\n<li>与隐式表面的相交计算，假设隐式函数为$f(p) = 0$，有$f(origin+t*direction) = 0$，需要的解是正数解 </li>\n<li>与显式表面相交计算，<ul>\n<li>也就是与三角形求交点 &lt;=&gt; 光线与三角形所在平面求交 + 交点是否在三角形内。交点p，$(p-p’) \\cdot N = (origin + t * direction - p’) \\cdot N = 0 =&gt; t = \\frac{p’\\cdot N-origin}{direction \\cdot N}$，检查：$0 \\le t &lt; \\infty$</li>\n<li>Moller Trumbore算法：<ul>\n<li>光线上的点与三角形上的点相交有: $origin + t*direction = (1-b_1-b_2)p_0 + b_1p_1+b_2p_2$，最终结果如下：<br>$\\left[ \\begin{matrix} t \\ b_1 \\ b_2 \\end{matrix} \\right] = \\frac{1}{S_1 \\cdot E_1} \\left[ \\begin{matrix} S_2 \\cdot E_2 \\ S_1 \\cdot S \\ S_2 \\cdot D  \\end{matrix} \\right]， \\begin{matrix} E_1 = p_1 - p_0 \\  E_2 = p_2 - p_0 \\ S = O-p_0 \\ S_1=D \\times E_2 \\ S_2=S \\times E_1  \\end{matrix}, 检查: \\begin{matrix} 0 \\le t &lt; \\infty \\ 0 \\le b_1 \\le 1 \\ 0 \\le b_2 \\le 1 \\  \\end{matrix}$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加速光线与表面求交的加速(显然不能与每个三角形都求一次)</p>\n<ul>\n<li>Bounding Volumn(包围盒): 用简单的三维物体包围复杂的三维物体，那么计算相交时就需要先和简单物体作相交判断，不相交则直接pass，节省了大量计算量。<ul>\n<li>Axis-Aligned Bounding Box(AABB): 轴对齐包围盒，这个常用。与这个包围盒的相交判断算法十分简单，这里不做记录了。</li>\n</ul>\n</li>\n<li>Uniform Spatial Partitions(Grids): 不适用于大规模的空白，如果空间中只有某一小块有物体，那格子会非常小，这样按步判断计算量反而很大</li>\n<li>空间划分：<br>  划分的停止条件，某块为空或者块内的物体数量足够少<ul>\n<li>Oct Tree: 八叉树</li>\n<li>KD Tree: 与八叉树类似，但是递归切分时一次只切分为两块；为了切分均匀，轴向的切分需要有顺序，例：x-&gt;y-&gt;z-&gt;x-&gt;y-&gt;z…<ul>\n<li>并不是按物体划分，因此后续的物体判断比较复杂</li>\n</ul>\n</li>\n<li>BSP Tree: 不是横平竖直，随着维度增加，切分计算越来越复杂，不如KD Tree.<br><img src=\"/img/games101/spatial_partition.png\" alt=\"spatial partition\"></li>\n</ul>\n</li>\n<li>Bounding Volume Hierachy(BVH): 以空间物体划分，生成类似KD Tree的树，空间上可能重叠，终止条件是盒子里物体足够少。<ul>\n<li>问题：空间上不是严格分开，因此如何划分以减少重叠空间就是值得研究的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Basic-radiometry-辐射度量学\"><a href=\"#Basic-radiometry-辐射度量学\" class=\"headerlink\" title=\"Basic radiometry(辐射度量学)\"></a>Basic radiometry(辐射度量学)</h4><p>物理上准确定义光线的方法。</p>\n<p>基础定义：</p>\n<ul>\n<li>Radiant Energy: 电磁辐射的能量，以焦耳为单位$Q [J = Joule]$</li>\n<li>Radiant flux: 单位时间的能量（功率），以瓦特为单位$\\Phi = \\frac{dQ}{dt}[W = Watt][lm=lumen]^*$，图形学更多用的是功率</li>\n<li>Radiant Intensity: 单位立体角辐射出去的能量，$I(w) = \\frac{d\\Phi}{dw}[\\frac{W}{sr}][\\frac{lm}{sr} = cd = candela]$<ul>\n<li>立体角=面积/半径的平方：$\\Omega = \\frac{A}{r^2}$</li>\n</ul>\n</li>\n<li>Irradiance：<ul>\n<li>接受辐射，或者是光源往外辐射</li>\n<li>$E(x) = \\frac{d(\\Phi)}{dA}$</li>\n<li>联系Lambert’s Cosine Law，因为有这个定义，才有那个法则</li>\n<li>也能解释季节变化，因为自转导致直射纬度在变</li>\n<li><center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/irradiance_falloff.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Irradiance衰减图示\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>radiance：<ul>\n<li>单位立体角、单位辐射面积上的功率</li>\n<li>$L(p, w) = \\frac{d^2\\Phi(p, w)}{d\\omega dA cos\\theta}$，$cos\\theta$是irradiance的夹角</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h4><p>BRDF：Bidirectional Reflection Ditribution Function双向反射分布函数，描述一束入射光的反射光的分布</p>\n<ul>\n<li>BRDF：某个入射方向的出射方向的贡献分布计算式  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/rushe_fanshe.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          BRDF: 入射光与反射光\n      </div>\n  </center></li>\n<li>反射方程(光线计算)：某个出射方向的光线计算式（即各个反射量的求和/积分）<ul>\n<li>$L<em>r(p, \\omega_r) = \\int</em>{H^2}f_r(p, \\omega_i \\rightarrow \\omega_r)L_i(p, \\omega_i)cos\\theta_i d{\\omega}_i$</li>\n</ul>\n</li>\n<li>渲染方程：<ul>\n<li>反射光 = 自己发光+反射别人的光</li>\n<li>$L<em>o(p,\\omega_o) = L_e(p, \\omega_o) + \\int</em>{\\Omega^+}L_i(p,\\omega_i)f_r(p, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i$，其中$n \\cdot\\omega_i = cos\\theta_i$</li>\n<li>方程简化<ul>\n<li>最终算式：$L = E + KE+K^2E+ K^3E+…$<br><img src=\"/img/games101/brdf1.png\" alt=\"original\"> <img src=\"/img/games101/brdf2.png\" alt=\"./simmplify\"></li>\n</ul>\n</li>\n<li>光栅化只能做到$E$和$E+KE$</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Monte-Carlo-Intergration-蒙特卡洛积分\"><a href=\"#Monte-Carlo-Intergration-蒙特卡洛积分\" class=\"headerlink\" title=\"Monte Carlo Intergration(蒙特卡洛积分)\"></a>Monte Carlo Intergration(蒙特卡洛积分)</h4><p>求解难以计算解析解的函数的定积分：$\\int_a^b f(x)dx$</p>\n<ul>\n<li>常规算式：$\\int f(x)dx = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{f(X_i)}{p(X_i)}$，$X_i$ ~ $p(x)$，$N$越大越准确</li>\n</ul>\n<h4 id=\"解渲染方程\"><a href=\"#解渲染方程\" class=\"headerlink\" title=\"解渲染方程\"></a>解渲染方程</h4><ul>\n<li>Simple蒙特卡洛解法(不考虑自光源)<ul>\n<li>直接光照下<br>  $L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L<em>i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) d{\\omega}_i<br>  =\\frac{1}{N} \\sum</em>{i=1}^{N} \\frac{L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i)}{p(\\omega_i)}$</li>\n</ul>\n</li>\n<li>考虑物体发光，也就是考虑间接反射。<ul>\n<li>只要假设某点也会从其他点接受光线，那么它本身就像是摄像机，于是就形成了递归，递归伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_n.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——N\n      </div>\n  </center></li>\n</ul>\n</li>\n<li>每条入射光产生N条出射光的结果会导致光线数量爆炸。因此上述伪代码无法实现。解决办法也很简单，每次只产生一条，然后在该点随机N次，取N次结果的平均以得到噪声较小的结果。代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/motekarluo_1.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          蒙特卡洛方法——1\n      </div>\n  </center>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/ray_generation.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Ray Generation\n      </div>\n  </center></li>\n<li><p>解决无限递归：采用概率p决定是否往下递归。伪代码如下：</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/recursion_solution.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          解决无限递归\n      </div>\n  </center>\n</li>\n<li><p>在着色点上采样，光的传播结果大部分都是一种浪费。因此我们将对着色点采样改为对光源采样，这样可以节省大量无用的计算量</p>\n<ul>\n<li>首先是立体角到光源面积的积分转换，关系：$d\\omega_i = \\frac{cos\\theta’}{||x’-p||^2} dA$，$\\theta’$是光源面的法线向量与入射光线的夹角，$||x’-p||^2$光源点到入射点的距离的平方(这个不难理解)</li>\n<li>得到新的渲染方程：$L<em>o(a,\\omega_o)<br>  =\\int</em>{\\Omega^+}L_i(a,\\omega_i)f_r(a, \\omega_i, \\omega_o) (n \\cdot \\omega_i) \\frac{cos\\theta’}{||x’-p||^2} dA$</li>\n<li>因此，可以对光源进行简单的均匀采样(即概率为常数)，然后计算贡献度和，取平均。</li>\n<li>注意，有物体遮挡的时候也要考虑进去，这是直接光照和间接光照（其实也就是变相的直接光照）都要考虑的。</li>\n<li>伪代码如下：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/lightsource.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          光源采样\n      </div>\n  </center>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture17-Materials-and-Appearances-材质外观\"><a href=\"#Lecture17-Materials-and-Appearances-材质外观\" class=\"headerlink\" title=\"Lecture17. Materials and Appearances(材质外观)\"></a>Lecture17. Materials and Appearances(材质外观)</h3><ul>\n<li>Diffuse / Lambertian Material<ul>\n<li>BRDF $f_r = \\frac{\\rho}{\\pi}$，其中$\\rho$是albedo，既可以是材质的颜色，也可以是纹理，参照unity里的设置</li>\n</ul>\n</li>\n<li>Glossy Material(抛光金属)</li>\n<li>Ideal reflective / refractive material (BSDF*)<ul>\n<li>水、玻璃等既可反射也可折射的材质(也有部分吸收)</li>\n<li>折射定律：Snell’s Law <ul>\n<li>$\\eta_i sin\\theta_i = \\eta_t sin\\theta_t$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Specular </li>\n<li>Fresnel Term(菲涅尔项，$\\eta = 1.5$)<ul>\n<li>视线方向与法线方向越接近平行，折射就越是严重；反之，反射就越严重。</li>\n<li>Schlick’s近似算法：$R(\\theta) = R_0 + (1-R_0)(1-cos\\theta)^5$，其中$R_0 = (\\frac{n_1 - n_2}{n_1 + n_2})^2$，$n_1,n_2$就是两种介质的折射率。</li>\n</ul>\n</li>\n<li>Microfacet Material(微表面材料，非常重要！！！)<ul>\n<li>从近处看能看到微表面的细节，能看到凹凸不平的、但是能出现镜面反射的；从远处看能看到平坦粗糙的外观。</li>\n<li>近处是几何，远处的材质</li>\n<li>因此，微表面上法线方向不同但大体相同也就是Glossy的材质</li>\n<li>$f(i,o) = \\frac{F(i, h) G(i,o,h) D(h) }{4(n,i)(n,o)}$<ul>\n<li>F(i, h)：$F<em>{Schlick} = C</em>{spec} + (1-C<em>{spec})(1-l \\cdot h)^5$(考虑了高光颜色$C</em>{spec}$)，菲涅尔项，描述光的反射与折射量</li>\n<li>G(i,o,h)：$G_{Cook-Torrance} = min(1, \\frac{2(n \\cdot h)(n \\cdot v)}{v \\cdot h}, \\frac{2(n \\cdot h)(n \\cdot l)}{v \\cdot h})$ shadow-masking项，可以处理边界处太亮的情况</li>\n<li>D(h)：$D_{GGX} = \\frac{\\alpha^2}{\\pi ((n \\cdot h)^2(\\alpha^2-1)+1)^2}$，法线分布  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/games101/microfacet.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          微表面模型\n      </div>\n  </center></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Isotropic / Anisotropic Materials(各向同性/各向异性材料)<ul>\n<li>与绝对方位角有关</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture18-Advanced-Topics-in-Rendering\"><a href=\"#Lecture18-Advanced-Topics-in-Rendering\" class=\"headerlink\" title=\"Lecture18. Advanced Topics in Rendering\"></a>Lecture18. Advanced Topics in Rendering</h3><ul>\n<li>无偏：unbiased，利用蒙特卡洛方法计算的估计的期望和实际的相等的。(也就是概率上的无偏性)</li>\n<li>有偏：biased，与unbiased相反。<ul>\n<li>一致：consistent，原本有偏，收敛之后是无偏的。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"无偏光线传播算法\"><a href=\"#无偏光线传播算法\" class=\"headerlink\" title=\"无偏光线传播算法\"></a>无偏光线传播算法</h4><ul>\n<li>BDPT: Bidrectional Path Tracing<ul>\n<li>从光源和视点同时采样得到半路径，然后连接两个顶点得到整个路径。</li>\n<li>很难实现，速度也很慢，对某些情况的效果很好。</li>\n</ul>\n</li>\n<li>MLT: Metropolis Light Transport<ul>\n<li>马尔科夫链的应用：蒙特卡洛积分法中，当采样分布与原函数基本一致的时候得到的误差是最小的。而马尔科夫链就可以生成这种与原函数基本一致的pdf。它可以生成与给定路径相似的路径</li>\n<li>复杂光路上效果很好。但是很难判断是否收敛</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有偏光线传播算法\"><a href=\"#有偏光线传播算法\" class=\"headerlink\" title=\"有偏光线传播算法\"></a>有偏光线传播算法</h4><ul>\n<li>Photon Mapping<ul>\n<li>能很好的处理Specular-Diffuse-Specular(SDS)和产生caustics<ul>\n<li>caustics: 由于光线聚焦产生的非常强烈的图案</li>\n</ul>\n</li>\n<li>实现过程<ul>\n<li>stage 1: 从光源发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>stage 2: 从照相机发散出photons，不断反射、折射它们，直到达到diffuse的表面。</li>\n<li>计算：local density estimation<ul>\n<li>对每个着色点，取其周围的N个photon，求出它们所占的面积，就能求出密度。密度越大的就应该越亮。</li>\n<li>N越小的时候，noise就会比较大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Vertex Connection and Merging<ul>\n<li>BDPT和Photon Mapping的组合</li>\n</ul>\n</li>\n<li>Instant Radiosity(IR)实时辐射度<ul>\n<li>不能处理Glossy的物体</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Lecture19-Cameras-Lenses-and-Light-Fields\"><a href=\"#Lecture19-Cameras-Lenses-and-Light-Fields\" class=\"headerlink\" title=\"Lecture19. Cameras, Lenses and Light Fields\"></a>Lecture19. Cameras, Lenses and Light Fields</h3><h3 id=\"Lecture20-Color-and-Perception\"><a href=\"#Lecture20-Color-and-Perception\" class=\"headerlink\" title=\"Lecture20. Color and Perception\"></a>Lecture20. Color and Perception</h3><p>上述两讲内容与基本图形学关系不大，具体可以去看视频内容，这里不做记录。</p>\n<h3 id=\"Lecture21-22-Animation\"><a href=\"#Lecture21-22-Animation\" class=\"headerlink\" title=\"Lecture21/22. Animation\"></a>Lecture21/22. Animation</h3><ul>\n<li>关键帧动画</li>\n<li>质点弹簧系统</li>\n<li>粒子系统</li>\n<li>Forward Kinematics</li>\n<li>Rigging(绑定)</li>\n</ul>\n<h4 id=\"Euler方法\"><a href=\"#Euler方法\" class=\"headerlink\" title=\"Euler方法\"></a>Euler方法</h4><ul>\n<li>一阶(前向)欧拉方法<ul>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^t, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^t$</li>\n<li>受步长$\\Delta t$的影响误差可能很大，当然减小$\\Delta t$可以减小误差</li>\n<li>非常不稳定，可能会出现不符合实际规律得到结果</li>\n</ul>\n</li>\n<li>中点法（Midpoint method）<ul>\n<li>$x<em>{mid} = x^t + \\Delta t /2 \\cdot x’^t \\rightarrow x^{t+\\Delta t} = x^t + \\Delta t \\cdot x’</em>{mid}$</li>\n<li>上式化简得$x^{t+ \\Delta t} = x^t + \\Delta t x’^t + \\frac{(\\Delta t)^2}{2} x’’^t$</li>\n</ul>\n</li>\n<li>Implicit Euler Method<ul>\n<li>与显式欧拉方法不同，隐式欧拉方法是用下一时刻的速度和加速度等量</li>\n<li>$x^{t+ \\Delta t} = x^t + \\Delta t x’^{t+ \\Delta t}, x’^{t+ \\Delta t} = x’^t + \\Delta t x’’^{t+ \\Delta t}$</li>\n</ul>\n</li>\n<li>Runge Kutta Method<ul>\n<li>RK4,4阶，最常用</li>\n<li>假设初始条件$\\frac{dy}{dt} = f(x, y), y(t_0) = y_0$</li>\n<li>有$y<em>{n+1} = y_n + \\frac{1}{6}h(k_1+2k_2+2k_3+k_4), t</em>{n+1} = t_n + h$</li>\n<li>上式中$k_{1-4}$的值如下：$\\left[ \\begin{matrix} k_1 \\ k_2 \\ k_3 \\ k_4 \\end{matrix} \\right] = \\left[ \\begin{matrix} f(t_n, y_n) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_1}{2}) \\ f(t_n+\\frac{h}{2}, y_n+h \\frac{k_2}{2}) \\ f(t_n+h, y_n+hk_3) \\end{matrix} \\right]$</li>\n</ul>\n</li>\n<li>Position Based / Verlet Integration</li>\n</ul>\n<h4 id=\"大规模粒子的模拟方法\"><a href=\"#大规模粒子的模拟方法\" class=\"headerlink\" title=\"大规模粒子的模拟方法\"></a>大规模粒子的模拟方法</h4><ul>\n<li>拉格朗日法（质点法）<ul>\n<li>对每个单独的粒子计算其运动变化规律</li>\n</ul>\n</li>\n<li>欧拉法（网格法）<ul>\n<li>划分空间，以空间为单位考虑</li>\n</ul>\n</li>\n<li>Material Point Method(MPM)<ul>\n<li>现在非常热门的方法，也是拉格朗日法和的结合</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hexo + Github","date":"2020-06-12T14:11:13.000Z","top_img":"/img/cover/hexo_github.png","cover":"/img/cover/hexo_github.png","description":"配置个人专属博客网站，采坑小结","_content":"这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","source":"_posts/Hexo-Github.md","raw":"---\ntitle: Hexo + Github\ndate: 2020-06-12 22:11:13\ntop_img: /img/cover/hexo_github.png\ncover: /img/cover/hexo_github.png\ndescription: 配置个人专属博客网站，采坑小结\ntags: \n  - config\n  - 教程\n---\n这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。\n\n这里是[参考博文链接](https://zhuanlan.zhihu.com/p/35668237)，这里是[主题Butterfly](https://github.com/jerryc127/hexo-theme-butterfly)的链接地址。\n\n参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。\n\n### 创建文章\n\n```bash\nhexo new post article-title\n```\n\n这里```article-title```是要创建的.md文件的名称。\n\n### Hexo清理、生成、运行与提交\n\n+ Hexo清理\n```bash\nhexo clean\n```\n\n+ Hexo生成\n```bash\nhexo g\n```\n\n+ Hexo运行\n```bash\nhexo s\n```\n\n输入指令后根据提示就可以在```http://localhost:4000```看到预期结果了\n\n+ Hexo提交\n```bash\nhexo d\n```\n\n这里需要先在```_config.yml```配置发布，代码如下：\n```bash\ndeploy:\n  type: git\n  repo: https://github.com/ruishaopu561/ruishaopu561.github.io\n  branch: hexo\n  message: update blog again, maybe something useful\n```\n\n`branch`是你上传代码的分支，`message`是上传时提交的信息（其实`hexo d`就是做了git add到push那一套）\n\n### 关于github上的repo\n\n在你应用主题之后，发布上去的应该是`public`文件夹里的代码，这也正是`hexo g`生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。\n\n### 应用主题之后的修改\n\n应用主题之后可能会想修改默认背景、默认头像等。这里可以参考`Butterfly`主题的[参考文档](https://docs.jerryc.me)\n\n### 解决markdown里latex公式显现问题\n\n[参考链接1](https://www.jianshu.com/p/e8d433a2c5b7)  \n[参考链接2](https://www.jianshu.com/p/7ab21c7f0674)\n\n#### 第一步：删除无用包\n```bash\nnpm uninstall hexo-renderer-marked --save\nnpm uninstall hexo-math --save\n```\n\n#### 第二步：安装新的替换包\n```bash\nnpm install hexo-renderer-kramed --save\nnpm install hexo-renderer-mathjax --save\n```\n\n#### 第三步：修改代码\n更改`<your-project-dir>/node_modules/hexo-renderer-kramed/lib/renderer.js`，更改：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    // Fit kramed's rule: $$ + \\1 + $$\n    return text.replace(/`\\$(.*?)\\$`/g, '$$$$$1$$$$');\n}\n```\n为：\n```js\n// Change inline math rule\nfunction formatText(text) {\n    return text;\n}\n```\n\n更新 Mathjax 的 CDN 链接，打开`<path-to-your-project>/node_modules/hexo-renderer-mathjax/mathjax.html`，把`<script>`更改为：\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\">\n</script>\n```\n\n更改默认转义规则\n打开`<path-to-your-project/node_modules/kramed/lib/rules/inline.js`，\n\n把:\n```js\nescape: /^\\\\([\\\\`*{}\\[\\]()#$+\\-.!_>])/,\n```\n更改为:\n```js\nescape: /^\\\\([`*\\[\\]()# +\\-.!_>])/,\n```\n把\n```js\nem: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n更改为:\n```js\nem: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n#### 第四步：开启mathjax\n在**主题**里的` _config.yml`中开启 Mathjax， 找到 **mathjax** 字段添加如下代码：\n```yml\nmathjax:\n    enable: true\n```\n在博客中开启 Mathjax，添加以下内容：\n\n```markdown\n---\n···\nmathjax: true\n---\n```","slug":"Hexo-Github","published":1,"updated":"2021-01-21T03:00:06.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3500013a6wag7x5ncv","content":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>这是我的第一篇博客，因为暂时没有什么内容需要记录，就记录一下这个博客创建的过程。</p>\n<p>这里是<a href=\"https://zhuanlan.zhihu.com/p/35668237\" target=\"_blank\" rel=\"noopener\">参考博文链接</a>，这里是<a href=\"https://github.com/jerryc127/hexo-theme-butterfly\" target=\"_blank\" rel=\"noopener\">主题Butterfly</a>的链接地址。</p>\n<p>参考博文的记录非常详细了，这里主要记录一些我认为重要的以及踩过坑的地方。</p>\n<h3 id=\"创建文章\"><a href=\"#创建文章\" class=\"headerlink\" title=\"创建文章\"></a>创建文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new post article-title</span><br></pre></td></tr></table></figure>\n<p>这里<code>article-title</code>是要创建的.md文件的名称。</p>\n<h3 id=\"Hexo清理、生成、运行与提交\"><a href=\"#Hexo清理、生成、运行与提交\" class=\"headerlink\" title=\"Hexo清理、生成、运行与提交\"></a>Hexo清理、生成、运行与提交</h3><ul>\n<li><p>Hexo清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo生成</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Hexo运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入指令后根据提示就可以在<code>http://localhost:4000</code>看到预期结果了</p>\n<ul>\n<li>Hexo提交<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里需要先在<code>_config.yml</code>配置发布，代码如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repo: https://github.com/ruishaopu561/ruishaopu561.github.io</span><br><span class=\"line\">  branch: hexo</span><br><span class=\"line\">  message: update blog again, maybe something useful</span><br></pre></td></tr></table></figure></p>\n<p><code>branch</code>是你上传代码的分支，<code>message</code>是上传时提交的信息（其实<code>hexo d</code>就是做了git add到push那一套）</p>\n<h3 id=\"关于github上的repo\"><a href=\"#关于github上的repo\" class=\"headerlink\" title=\"关于github上的repo\"></a>关于github上的repo</h3><p>在你应用主题之后，发布上去的应该是<code>public</code>文件夹里的代码，这也正是<code>hexo g</code>生成文件的位置。所以如果网站访问有问题的话应该去看看github里的文件分别是什么。</p>\n<h3 id=\"应用主题之后的修改\"><a href=\"#应用主题之后的修改\" class=\"headerlink\" title=\"应用主题之后的修改\"></a>应用主题之后的修改</h3><p>应用主题之后可能会想修改默认背景、默认头像等。这里可以参考<code>Butterfly</code>主题的<a href=\"https://docs.jerryc.me\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<h3 id=\"解决markdown里latex公式显现问题\"><a href=\"#解决markdown里latex公式显现问题\" class=\"headerlink\" title=\"解决markdown里latex公式显现问题\"></a>解决markdown里latex公式显现问题</h3><p><a href=\"https://www.jianshu.com/p/e8d433a2c5b7\" target=\"_blank\" rel=\"noopener\">参考链接1</a><br><a href=\"https://www.jianshu.com/p/7ab21c7f0674\" target=\"_blank\" rel=\"noopener\">参考链接2</a></p>\n<h4 id=\"第一步：删除无用包\"><a href=\"#第一步：删除无用包\" class=\"headerlink\" title=\"第一步：删除无用包\"></a>第一步：删除无用包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步：安装新的替换包\"><a href=\"#第二步：安装新的替换包\" class=\"headerlink\" title=\"第二步：安装新的替换包\"></a>第二步：安装新的替换包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-kramed --save</span><br><span class=\"line\">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步：修改代码\"><a href=\"#第三步：修改代码\" class=\"headerlink\" title=\"第三步：修改代码\"></a>第三步：修改代码</h4><p>更改<code>&lt;your-project-dir&gt;/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Fit kramed's rule: $$ + \\1 + $$</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> text.replace(<span class=\"regexp\">/`\\$(.*?)\\$`/g</span>, <span class=\"string\">'$$$$$1$$$$'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>为：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Change inline math rule</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">formatText</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>更新 Mathjax 的 CDN 链接，打开<code>&lt;path-to-your-project&gt;/node_modules/hexo-renderer-mathjax/mathjax.html</code>，把<code>&lt;script&gt;</code>更改为：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>更改默认转义规则<br>打开<code>&lt;path-to-your-project/node_modules/kramed/lib/rules/inline.js</code>，</p>\n<p>把:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()# +\\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><br>把<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure><br>更改为:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"第四步：开启mathjax\"><a href=\"#第四步：开启mathjax\" class=\"headerlink\" title=\"第四步：开启mathjax\"></a>第四步：开启mathjax</h4><p>在<strong>主题</strong>里的<code>_config.yml</code>中开启 Mathjax， 找到 <strong>mathjax</strong> 字段添加如下代码：<br><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">    <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>在博客中开启 Mathjax，添加以下内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">···</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>"},{"title":"c++ 基础(1)","date":"2021-01-20T06:51:34.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### struct和class的区别\n在C++中，可以用`struct`和`class`定义类，都可以继承。区别在于：\n`struct`的默认继承权限和默认访问权限是**public**，而`class`的默认继承权限和默认访问权限是**private**。\n\n另外，`class`还可以定义模板类形参，比如\n```c++\ntemplate <class T, int i>\n```\n\n### static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","source":"_posts/c++基础-1.md","raw":"---\ntitle: c++ 基础(1)\ndate: 2021-01-20 14:51:34\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（1）\n### C++和C的区别\n设计思想上：\n\n    C++是面向对象的语言，而C是面向过程的结构化编程语言\n\n语法上：\n\n    C++具有封装、继承和多态三种特性\n    C++相比C，增加多许多类型安全的功能，比如强制类型转换、\n    C++支持范式编程，比如模板类、函数模板等\n\n### C/C++ 中指针和引用的区别\n1. 指针有自己的一块空间，而引用只是一个别名；\n2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；\n3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；\n4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；\n5. 可以有const指针，但是没有const引用；\n6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；\n7. 指针可以有多级指针（**p），而引用至于一级；\n8. 指针和引用使用++运算符的意义不一样；\n9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。\n\n### struct和class的区别\n在C++中，可以用`struct`和`class`定义类，都可以继承。区别在于：\n`struct`的默认继承权限和默认访问权限是**public**，而`class`的默认继承权限和默认访问权限是**private**。\n\n另外，`class`还可以定义模板类形参，比如\n```c++\ntemplate <class T, int i>\n```\n\n### static关键字的作用\n1. 全局静态变量\n在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.\n静态存储区，在整个程序运行期间一直存在。\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。\n\n2.  局部静态变量\n在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。\n内存中的位置：静态存储区\n初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；\n作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；\n\n3. 静态函数\n在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。\n函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；\n\n注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；\n\n4. 类的静态成员\n在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用\n\n5. 类的静态函数\n静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。\n在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);\n\n### 智能指针\nc++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。\n\n头文件：\n```c++\n#include <memory>\n```\n\n为什么要使用智能指针？\n智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。\n\n#### 1. auto_ptr\n采用所有权模式。\n```c++\nauto_ptr< string> p1 (new string (\"I reigned lonely as a cloud.”));\nauto_ptr<string> p2;\np2 = p1; //auto_ptr不会报错.\n```\n此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！\n\n#### 2. unique_ptr（替换auto_ptr）\nunique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。\n\n采用所有权模式，还是上面那个例子\n```c++\nunique_ptr<string> p3 (new string (\"auto\"));   //#4\nunique_ptr<string> p4;                         //#5\np4 = p3;                                       //此时会报错！！\n```\n\n编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。\n\n另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：\n\n```c++\nunique_ptr<string> pu1(new string (\"hello world\"));\nunique_ptr<string> pu2;\npu2 = pu1;                                      // #1 not allowed\n\nunique_ptr<string> pu3;\npu3 = unique_ptr<string>(new string (\"You\"));   // #2 allowed\n```\n\n其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。\n\n注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：\n\n```c++\nunique_ptr<string> ps1, ps2;\nps1 = demo(\"hello\");\nps2 = move(ps1);\nps1 = demo(\"alexia\");\ncout << *ps2 << *ps1 << endl;\n\n// output: hello alexia\n```\n\n#### 3. shared_ptr\nshared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。\n\nshared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。\n\n| 成员函数名称 | 描述 |\n| --- | --- |\n| use_count | 返回引用计数的个数 |\n| unique | 返回是否是独占所有权( use_count 为 1) |\n| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |\n| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |\n| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |\n\n#### 4. weak_ptr\nweak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。\n\nweak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。\n\n和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。\n\nweak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：\n```c++\nweak_ptr a;\nshared_ptr b = a.lock();\nb->print();\n```\n\n#### 智能指针有没有内存泄漏，有的话如何解决\n有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。\n\n为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)","slug":"c++基础-1","published":1,"updated":"2021-01-21T03:00:06.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3n00033a6w6rm5b4e1","content":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"struct和class的区别\"><a href=\"#struct和class的区别\" class=\"headerlink\" title=\"struct和class的区别\"></a>struct和class的区别</h3><p>在C++中，可以用<code>struct</code>和<code>class</code>定义类，都可以继承。区别在于：<br><code>struct</code>的默认继承权限和默认访问权限是<strong>public</strong>，而<code>class</code>的默认继承权限和默认访问权限是<strong>private</strong>。</p>\n<p>另外，<code>class</code>还可以定义模板类形参，比如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">int</span> <span class=\"title\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"static关键字的作用\"><a href=\"#static关键字的作用\" class=\"headerlink\" title=\"static关键字的作用\"></a>static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（1）\"><a href=\"#C-基础知识（1）\" class=\"headerlink\" title=\"C++ 基础知识（1）\"></a>C++ 基础知识（1）</h2><h3 id=\"C-和C的区别\"><a href=\"#C-和C的区别\" class=\"headerlink\" title=\"C++和C的区别\"></a>C++和C的区别</h3><p>设计思想上：</p>\n<pre><code>C++是面向对象的语言，而C是面向过程的结构化编程语言\n</code></pre><p>语法上：</p>\n<pre><code>C++具有封装、继承和多态三种特性\nC++相比C，增加多许多类型安全的功能，比如强制类型转换、\nC++支持范式编程，比如模板类、函数模板等\n</code></pre><h3 id=\"C-C-中指针和引用的区别\"><a href=\"#C-C-中指针和引用的区别\" class=\"headerlink\" title=\"C/C++ 中指针和引用的区别\"></a>C/C++ 中指针和引用的区别</h3><ol>\n<li>指针有自己的一块空间，而引用只是一个别名；</li>\n<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>\n<li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>\n<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>\n<li>可以有const指针，但是没有const引用；</li>\n<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>\n<li>指针可以有多级指针（**p），而引用至于一级；</li>\n<li>指针和引用使用++运算符的意义不一样；</li>\n<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>\n</ol>\n<h3 id=\"struct和class的区别\"><a href=\"#struct和class的区别\" class=\"headerlink\" title=\"struct和class的区别\"></a>struct和class的区别</h3><p>在C++中，可以用<code>struct</code>和<code>class</code>定义类，都可以继承。区别在于：<br><code>struct</code>的默认继承权限和默认访问权限是<strong>public</strong>，而<code>class</code>的默认继承权限和默认访问权限是<strong>private</strong>。</p>\n<p>另外，<code>class</code>还可以定义模板类形参，比如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">int</span> <span class=\"title\">i</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"static关键字的作用\"><a href=\"#static关键字的作用\" class=\"headerlink\" title=\"static关键字的作用\"></a>static关键字的作用</h3><ol>\n<li><p>全局静态变量<br>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.<br>静态存储区，在整个程序运行期间一直存在。<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>\n</li>\n<li><p>局部静态变量<br>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。<br>内存中的位置：静态存储区<br>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；<br>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p>\n</li>\n<li><p>静态函数<br>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。<br>函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>\n</li>\n</ol>\n<p>注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；</p>\n<ol>\n<li><p>类的静态成员<br>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>\n</li>\n<li><p>类的静态函数<br>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。<br>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p>\n</li>\n</ol>\n<h3 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h3><p>c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。</p>\n<p>头文件：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>为什么要使用智能指针？<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>\n<h4 id=\"1-auto-ptr\"><a href=\"#1-auto-ptr\" class=\"headerlink\" title=\"1. auto_ptr\"></a>1. auto_ptr</h4><p>采用所有权模式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt; <span class=\"built_in\">string</span>&gt; <span class=\"title\">p1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"I reigned lonely as a cloud.”));</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">auto_ptr&lt;string&gt; p2;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">p2 = p1; //auto_ptr不会报错.</span></span></span></span><br></pre></td></tr></table></figure><br>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p>\n<h4 id=\"2-unique-ptr（替换auto-ptr）\"><a href=\"#2-unique-ptr（替换auto-ptr）\" class=\"headerlink\" title=\"2. unique_ptr（替换auto_ptr）\"></a>2. unique_ptr（替换auto_ptr）</h4><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p>\n<p>采用所有权模式，还是上面那个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">p3</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"auto\"</span>))</span></span>;   <span class=\"comment\">//#4</span></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p4;                         <span class=\"comment\">//#5</span></span><br><span class=\"line\">p4 = p3;                                       <span class=\"comment\">//此时会报错！！</span></span><br></pre></td></tr></table></figure></p>\n<p>编译器认为<code>p4=p3</code>非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。</p>\n<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">pu1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"hello world\"</span>))</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu2;</span><br><span class=\"line\">pu2 = pu1;                                      <span class=\"comment\">// #1 not allowed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; pu3;</span><br><span class=\"line\">pu3 = <span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">string</span> (<span class=\"string\">\"You\"</span>));   <span class=\"comment\">// #2 allowed</span></span><br></pre></td></tr></table></figure>\n<p>其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。</p>\n<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unique_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; ps1, ps2;</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">ps2 = <span class=\"built_in\">move</span>(ps1);</span><br><span class=\"line\">ps1 = demo(<span class=\"string\">\"alexia\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: hello alexia</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shared-ptr\"><a href=\"#3-shared-ptr\" class=\"headerlink\" title=\"3. shared_ptr\"></a>3. shared_ptr</h4><p>shared_ptr 实现共享式拥有概念。<strong>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放</strong>。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。<strong>当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放</strong>。</p>\n<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>成员函数名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>use_count</td>\n<td>返回引用计数的个数</td>\n</tr>\n<tr>\n<td>unique</td>\n<td>返回是否是独占所有权( use_count 为 1)</td>\n</tr>\n<tr>\n<td>swap</td>\n<td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td>\n</tr>\n<tr>\n<td>reset</td>\n<td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td>\n</tr>\n<tr>\n<td>get</td>\n<td>返回内部对象(指针) ，等价于对象本身（已经重载了()方法）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h4 id=\"4-weak-ptr\"><a href=\"#4-weak-ptr\" class=\"headerlink\" title=\"4. weak_ptr\"></a>4. weak_ptr</h4><p>weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的<strong>构造和析构不会引起引用记数的增加或减少</strong>。</p>\n<p>weak_ptr 是用来解决 shared_ptr <strong>相互引用时的死锁问题</strong>，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。</p>\n<p>和 shared_ptr 之间可以相互转化，<strong>shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr</strong>。</p>\n<p>weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">weak_ptr a;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span> b = a.lock();</span><br><span class=\"line\">b-&gt;<span class=\"built_in\">print</span>();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"智能指针有没有内存泄漏，有的话如何解决\"><a href=\"#智能指针有没有内存泄漏，有的话如何解决\" class=\"headerlink\" title=\"智能指针有没有内存泄漏，有的话如何解决\"></a>智能指针有没有内存泄漏，有的话如何解决</h4><p>有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。</p>\n<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a></p>\n"},{"title":"c++ 基础(2)","date":"2021-01-20T08:46:15.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","source":"_posts/c++基础-2.md","raw":"---\ntitle: c++ 基础(2)\ndate: 2021-01-20 16:46:15\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（2）\n### 析构函数的作用\n析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。\n\n析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。\n\n如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。\n\n如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。\n\n类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。\n\n#### 静态函数和虚函数的区别\n静态函数在编译的时候就已经确定运行时机，**虚函数在运行的时候动态绑定**。虚函数因为用了**虚函数表机制**，调用的时候会增加一次内存开销。\n\n#### 为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\n将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。\n\nC++默认的析构函数不是虚函数是因为虚函数需要**额外的虚函数表和虚表指针**，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。\n\n#### 虚函数表机制\n为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。\n\n每个实现了虚函数的类都有一个虚表，**虚表是与类绑定**的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。\n\n如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。\n\n为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 `*_vptr`。\n\n**执行函数的动态绑定**的3个条件：\n1. 通过指针来调用函数\n2. 指针 upcast 向上转型（继承类向基类转换）\n3. 调用的是虚函数\n\n详见[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n\n### 函数指针\n1. 定义\n函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。\n\n2. 用途\n调用函数和做函数的参数，比如回调函数。\n\n3. 示例\n\n    ```c++\n    char *fun(char *p) {…}                        // 函数 fun\n    char *(*pf)(char *p);                         // 函数指针 pf\n    pf = fun;                                     // 函数指针 pf 指向函数 fun\n    pf(p);                                        // 通过函数指针 pf 调用函数 fun\n    ```\n\n### 常量\n常量是在程序运行中不能被改变的标识符。\nc++中定义常量可以用 `#define` 、`const` 这两种方法。\n\n```c++\n#define PRICE 10 //定义单价常量10\nconst int PRICE = 10; //定义单价常量10\n```\n\n区别：\n    `#define`是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 `constant` 则是定义含有变量类型的常量，它会在编译时做语法检查。`#define`经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。\n\n使用常量的好处：\n1. 增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。\n2. 如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。\n\n#### 常量的存放位置\n+ 对于局部对象，常量存放在**栈区**；\n+ 对于全局对象，常量存放在**全局/静态存储区**；\n+ 对于字面值常量，常量存放在**常量存储区**；\n    + 在c/c++中，即4, 3.1415926, 0x24, \"BEIJING\"等\n\n### new/delete与malloc/free的区别\nnew/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。\n\n另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。\n\n### 重载和重写/覆盖的区别\n重载：两个函数名相同，但是参数列表不同（**参数名称、个数、类型不同**），**返回值类型没有要求**，在同一作用域中\n重写/覆盖：**子类继承父类**，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写\n\n### strcpy memcpy\n```c++\nchar *strcpy(char* dest, const char *src);                  // 字符串拷贝函数，不指定大小\nvoid *memcpy(void *dest, const void *src, size_t n);        // 任意类型复制，指定大小n字节\n```\n\n`strcpy()`从src逐字节拷贝到dest，直到遇到`'\\0'`结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是`strncpy`函数。\n`strlen`函数是计算字符串长度的函数，返回从开始到`'\\0'`之间的字符个数。\n\n## 参考链接\n[C++面试宝典](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[c++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)\n[字面值常量](https://blog.csdn.net/wangjianno2/article/details/52729583)","slug":"c++基础-2","published":1,"updated":"2021-01-21T14:23:05.496Z","_id":"ckk6y1e3o00043a6w03n32plb","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（2）\"><a href=\"#C-基础知识（2）\" class=\"headerlink\" title=\"C++ 基础知识（2）\"></a>C++ 基础知识（2）</h2><h3 id=\"析构函数的作用\"><a href=\"#析构函数的作用\" class=\"headerlink\" title=\"析构函数的作用\"></a>析构函数的作用</h3><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>\n<p>析构函数名与类名相同，只是在函数名前面加一个位取反符~，例如 ~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>\n<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>\n<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>\n<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>\n<h4 id=\"静态函数和虚函数的区别\"><a href=\"#静态函数和虚函数的区别\" class=\"headerlink\" title=\"静态函数和虚函数的区别\"></a>静态函数和虚函数的区别</h4><p>静态函数在编译的时候就已经确定运行时机，<strong>虚函数在运行的时候动态绑定</strong>。虚函数因为用了<strong>虚函数表机制</strong>，调用的时候会增加一次内存开销。</p>\n<h4 id=\"为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\"><a href=\"#为什么析构函数必须是虚函数，为什么C-默认的析构函数不是虚函数\" class=\"headerlink\" title=\"为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数\"></a>为什么析构函数必须是虚函数，为什么C++默认的析构函数不是虚函数</h4><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>\n<p>C++默认的析构函数不是虚函数是因为虚函数需要<strong>额外的虚函数表和虚表指针</strong>，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>\n<h4 id=\"虚函数表机制\"><a href=\"#虚函数表机制\" class=\"headerlink\" title=\"虚函数表机制\"></a>虚函数表机制</h4><p>为了实现c++的多态，c++使用了一种动态绑定的机制，其核心是虚函数表。</p>\n<p>每个实现了虚函数的类都有一个虚表，<strong>虚表是与类绑定</strong>的，与对象无关，在程序编译阶段就构造出来了。每个类的虚表只记录虚函数，不记录非虚函数，因此虚函数与非虚函数的调用方式有一点不同。</p>\n<p>如果一个子类继承的父类有虚函数，那么该子类也有自己的虚函数表。</p>\n<p>为了调用虚函数，每个对象需要保存其类的虚表的起始地址，即虚表指针 <code>*_vptr</code>。</p>\n<p><strong>执行函数的动态绑定</strong>的3个条件：</p>\n<ol>\n<li>通过指针来调用函数</li>\n<li>指针 upcast 向上转型（继承类向基类转换）</li>\n<li>调用的是虚函数</li>\n</ol>\n<p>详见<a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><ol>\n<li><p>定义<br>函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里指向函数。c/c++在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>\n</li>\n<li><p>用途<br>调用函数和做函数的参数，比如回调函数。</p>\n</li>\n<li><p>示例</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">char</span> *p)</span> </span>&#123;…&#125;                        <span class=\"comment\">// 函数 fun</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *(*pf)(<span class=\"keyword\">char</span> *p);                         <span class=\"comment\">// 函数指针 pf</span></span><br><span class=\"line\">pf = fun;                                     <span class=\"comment\">// 函数指针 pf 指向函数 fun</span></span><br><span class=\"line\">pf(p);                                        <span class=\"comment\">// 通过函数指针 pf 调用函数 fun</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>常量是在程序运行中不能被改变的标识符。<br>c++中定义常量可以用 <code>#define</code> 、<code>const</code> 这两种方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PRICE 10 <span class=\"comment\">//定义单价常量10</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> PRICE = <span class=\"number\">10</span>; <span class=\"comment\">//定义单价常量10</span></span><br></pre></td></tr></table></figure>\n<p>区别：<br>    <code>#define</code>是定义宏变量，它其实是在编译之前，由预处理指令把代码里面的宏变量用指定的字符串替换，它不做语法检查，而 <code>constant</code> 则是定义含有变量类型的常量，它会在编译时做语法检查。<code>#define</code>经常被认为好象不是语言本身的一部分。而且有时候用宏，会出现意想不到的输出结果。因此定义常量尽量用编译器而不用预处理。</p>\n<p>使用常量的好处：</p>\n<ol>\n<li>增强程序的可读性。用一个有意义的常量字符串代替一个常数，程序读起来会更加的方便。</li>\n<li>如果很多地方用到像PI（3.14159）这样的常量，可以一改改全局。</li>\n</ol>\n<h4 id=\"常量的存放位置\"><a href=\"#常量的存放位置\" class=\"headerlink\" title=\"常量的存放位置\"></a>常量的存放位置</h4><ul>\n<li>对于局部对象，常量存放在<strong>栈区</strong>；</li>\n<li>对于全局对象，常量存放在<strong>全局/静态存储区</strong>；</li>\n<li>对于字面值常量，常量存放在<strong>常量存储区</strong>；<ul>\n<li>在c/c++中，即4, 3.1415926, 0x24, “BEIJING”等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"new-delete与malloc-free的区别\"><a href=\"#new-delete与malloc-free的区别\" class=\"headerlink\" title=\"new/delete与malloc/free的区别\"></a>new/delete与malloc/free的区别</h3><p>new/delete是c++的关键字，而malloc/free是C语言的库函数，new/delete是动态申请，申请的空间大小不需要明确指明，malloc/free是静态申请，必须指明申请内存空间的大小。对于类类型的对象，malloc/free不会调用构造函数和析构函数。</p>\n<p>另外，malloc返回的指针需要强转，new会调用构造函数，返回的指针不用强转。</p>\n<h3 id=\"重载和重写-覆盖的区别\"><a href=\"#重载和重写-覆盖的区别\" class=\"headerlink\" title=\"重载和重写/覆盖的区别\"></a>重载和重写/覆盖的区别</h3><p>重载：两个函数名相同，但是参数列表不同（<strong>参数名称、个数、类型不同</strong>），<strong>返回值类型没有要求</strong>，在同一作用域中<br>重写/覆盖：<strong>子类继承父类</strong>，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>\n<h3 id=\"strcpy-memcpy\"><a href=\"#strcpy-memcpy\" class=\"headerlink\" title=\"strcpy memcpy\"></a>strcpy memcpy</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *src)</span></span>;                  <span class=\"comment\">// 字符串拷贝函数，不指定大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">memcpy</span><span class=\"params\">(<span class=\"keyword\">void</span> *dest, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *src, <span class=\"keyword\">size_t</span> n)</span></span>;        <span class=\"comment\">// 任意类型复制，指定大小n字节</span></span><br></pre></td></tr></table></figure>\n<p><code>strcpy()</code>从src逐字节拷贝到dest，直到遇到<code>&#39;\\0&#39;</code>结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是<code>strncpy</code>函数。<br><code>strlen</code>函数是计算字符串长度的函数，返回从开始到<code>&#39;\\0&#39;</code>之间的字符个数。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">C++面试宝典</a><br><a href=\"https://blog.csdn.net/lihao21/article/details/50688337\" target=\"_blank\" rel=\"noopener\">c++虚函数表剖析</a><br><a href=\"https://blog.csdn.net/wangjianno2/article/details/52729583\" target=\"_blank\" rel=\"noopener\">字面值常量</a></p>\n"},{"title":"c++ 基础(3)","date":"2021-01-20T14:00:05.000Z","top_img":"/img/cover/cpp.jpg","cover":"/img/cover/cpp.jpg","_content":"\n## C++ 基础知识（3）\n### 右值引用\n#### 左值和右值\n根据《C++ Primer》的说法，左值和右值可以这样区分：\n\n> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如\n```c++\nint foo(42);\nint bar;\n\n// 将 foo 的值赋给 bar，保存在 bar 对应的内存中\n// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值\n// 但是 foo 作为对象，既可以充当左值又可以充当右值\nbar = foo;\n```\n\n因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即\n\n+ 在大多数情况下，需要右值的地方可以用左值来替代，但\n+ 需要左值的地方，一定不能用右值来替代。\n\n又有一个重要的特点，即\n\n+ 左值存放在对象中，有持久的状态；而\n+ 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。\n\n#### 常量左值引用\n常量左值引用，即const的左值引用。\n\n右值只能绑定到右值引用上，左值引用不能绑定右值，例如：\n```c++\nint i = 42;\nint &&rr = i;     // ERR: i 是左值\nint &r = i * 2;   // ERR: i * 2 是右值\n```\n\n但是常量左值引用可以绑定右值：\n```c++\nint i = 42;\nconst int &r = i * 42;  // OK: 可以将 const 引用绑定到右值上\n```\n\n可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 `int &r = 42` 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：\n```c++\n// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么\ndouble dval = 3.14;\nconst int &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 先将双精度浮点数变成一个整型常量\nconst int &ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上\n```\n\n这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。\n\n我们再来看看如果 ri 不是常量引用会发生什么：\n```c++\ndouble dval = 3.14; \nint &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 还是先将双精度浮点数变成一个整型常量\nint &ri = tmp;          // 再让这个普通引用和 tmp 绑定\n```\n\n可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：\n\n+ tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。\n+ 就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。\n\n于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。\n\n通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。\n\n同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。\n\n#### 左值引用和右值引用\n在 C++ 中，有两种对对象的引用：左值引用和右值引用。\n\n左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。\n\n```c++\n// lvalue-reference\nint foo(42);\nint& bar = foo;  // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起\nint& baz = 42;   // Err: 42 是右值，不能将它绑定在左值引用上\nconst int& qux = 42;  // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上\n```\n右值引用也是引用，但是它只能且必须绑定在右值上。\n\n```c++\n// rvalue-reference\nint foo(42);\nint& bar = foo;        // OK: 将 foo 绑定在左值引用上\nint&& baz = foo;       // Err: foo 可以是左值，所以不能将它绑定在右值引用上\nint&& qux = 42;        // OK: 将右值 42 绑定在右值引用上\nint&& quux = foo * 1;  // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上\nint& garply = foo++;   // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上\nint&& waldo = foo--;   // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上\n```\n\n由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：\n\n+ 右值引用的对象，是临时的，即将被销毁；并且\n+ 右值引用的对象，不会在其它地方使用。\n\n> 敲黑板：这是重点！\n\n这两个特性意味着：**接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏**。\n\n需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：\n```c++\nint &&rr1 = 42;   // OK: 字面量是右值\nint &&rr2 = rr1;  // ERR: rr1 是变量，虽然它是右值引用，但仍然是左值\n```\n\n#### 右值的作用\n##### 标准库 move 函数\n虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：\n```c++\nint&& rr1 = 42;                 // 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值\nint&& rr2 = std::move(rr1);     // 使用 std::move() 而不是 move()\n```\n\n需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。\n\n##### 移动构造函数\n有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。\n\n和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。\n\n详见\n\n##### 移动赋值运算符\n移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：\n```c++\nMyString& Mystring::operator=(MyString&& rhs) noexcept {\n  if (this != &rhs) {\n    if (string) free(string);  // 先将原有资源释放\n    string = rhs.string;\n    rhs.string = nullptr;\n  }\n  return *this;\n}\n```\n只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。\n\n#### 转发\n转发与 std::forward 的内容详见[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。\n\n## 参考链接\n[struct和class的区别](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[C++ 引用、移动、转发 (一)](https://guodong.plus/2020/0307-190855/)\n[C++ 引用、移动、转发 (二)](https://guodong.plus/2020/0311-225314/)\n[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)\n[谈谈c++中的右值引用](https://liam.page/2016/12/11/rvalue-reference-in-Cpp/)","source":"_posts/c++基础-3.md","raw":"---\ntitle: c++ 基础(3)\ndate: 2021-01-20 22:00:05\ntop_img: /img/cover/cpp.jpg\ncover: /img/cover/cpp.jpg\ntags: [c++, intern, 笔记]\n---\n\n## C++ 基础知识（3）\n### 右值引用\n#### 左值和右值\n根据《C++ Primer》的说法，左值和右值可以这样区分：\n\n> 一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如\n```c++\nint foo(42);\nint bar;\n\n// 将 foo 的值赋给 bar，保存在 bar 对应的内存中\n// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值\n// 但是 foo 作为对象，既可以充当左值又可以充当右值\nbar = foo;\n```\n\n因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即\n\n+ 在大多数情况下，需要右值的地方可以用左值来替代，但\n+ 需要左值的地方，一定不能用右值来替代。\n\n又有一个重要的特点，即\n\n+ 左值存放在对象中，有持久的状态；而\n+ 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。\n\n#### 常量左值引用\n常量左值引用，即const的左值引用。\n\n右值只能绑定到右值引用上，左值引用不能绑定右值，例如：\n```c++\nint i = 42;\nint &&rr = i;     // ERR: i 是左值\nint &r = i * 2;   // ERR: i * 2 是右值\n```\n\n但是常量左值引用可以绑定右值：\n```c++\nint i = 42;\nconst int &r = i * 42;  // OK: 可以将 const 引用绑定到右值上\n```\n\n可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 `int &r = 42` 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：\n```c++\n// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么\ndouble dval = 3.14;\nconst int &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 先将双精度浮点数变成一个整型常量\nconst int &ri = tmp;    // 让常量引用 ri 绑定到这个临时变量上\n```\n\n这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。\n\n我们再来看看如果 ri 不是常量引用会发生什么：\n```c++\ndouble dval = 3.14; \nint &ri = dval;\n// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：\nconst int tmp = dval;   // 还是先将双精度浮点数变成一个整型常量\nint &ri = tmp;          // 再让这个普通引用和 tmp 绑定\n```\n\n可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：\n\n+ tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。\n+ 就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。\n\n于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。\n\n通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。\n\n同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。\n\n#### 左值引用和右值引用\n在 C++ 中，有两种对对象的引用：左值引用和右值引用。\n\n左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。\n\n```c++\n// lvalue-reference\nint foo(42);\nint& bar = foo;  // OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起\nint& baz = 42;   // Err: 42 是右值，不能将它绑定在左值引用上\nconst int& qux = 42;  // OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上\n```\n右值引用也是引用，但是它只能且必须绑定在右值上。\n\n```c++\n// rvalue-reference\nint foo(42);\nint& bar = foo;        // OK: 将 foo 绑定在左值引用上\nint&& baz = foo;       // Err: foo 可以是左值，所以不能将它绑定在右值引用上\nint&& qux = 42;        // OK: 将右值 42 绑定在右值引用上\nint&& quux = foo * 1;  // OK: foo * 1 的结果是一个右值，将它绑定在右值引用上\nint& garply = foo++;   // Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上\nint&& waldo = foo--;   // OK: 后置自减运算符返回的是右值，将它绑定在右值引用上\n```\n\n由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：\n\n+ 右值引用的对象，是临时的，即将被销毁；并且\n+ 右值引用的对象，不会在其它地方使用。\n\n> 敲黑板：这是重点！\n\n这两个特性意味着：**接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏**。\n\n需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：\n```c++\nint &&rr1 = 42;   // OK: 字面量是右值\nint &&rr2 = rr1;  // ERR: rr1 是变量，虽然它是右值引用，但仍然是左值\n```\n\n#### 右值的作用\n##### 标准库 move 函数\n虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：\n```c++\nint&& rr1 = 42;                 // 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值\nint&& rr2 = std::move(rr1);     // 使用 std::move() 而不是 move()\n```\n\n需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。\n\n##### 移动构造函数\n有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。\n\n和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。\n\n详见\n\n##### 移动赋值运算符\n移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：\n```c++\nMyString& Mystring::operator=(MyString&& rhs) noexcept {\n  if (this != &rhs) {\n    if (string) free(string);  // 先将原有资源释放\n    string = rhs.string;\n    rhs.string = nullptr;\n  }\n  return *this;\n}\n```\n只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。\n\n#### 转发\n转发与 std::forward 的内容详见[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。\n\n## 参考链接\n[struct和class的区别](https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24)\n[C++ 引用、移动、转发 (一)](https://guodong.plus/2020/0307-190855/)\n[C++ 引用、移动、转发 (二)](https://guodong.plus/2020/0311-225314/)\n[C++ 引用、移动、转发 (三)](https://guodong.plus/2020/0314-132811/)\n[谈谈c++中的右值引用](https://liam.page/2016/12/11/rvalue-reference-in-Cpp/)","slug":"c++基础-3","published":1,"updated":"2021-01-21T14:23:12.120Z","_id":"ckk6y1e3p00053a6w57ht8r87","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"C-基础知识（3）\"><a href=\"#C-基础知识（3）\" class=\"headerlink\" title=\"C++ 基础知识（3）\"></a>C++ 基础知识（3）</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><h4 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h4><p>根据《C++ Primer》的说法，左值和右值可以这样区分：</p>\n<blockquote>\n<p>一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 的值赋给 bar，保存在 bar 对应的内存中</span></span><br><span class=\"line\"><span class=\"comment\">// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值</span></span><br><span class=\"line\"><span class=\"comment\">// 但是 foo 作为对象，既可以充当左值又可以充当右值</span></span><br><span class=\"line\">bar = foo;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即</p>\n<ul>\n<li>在大多数情况下，需要右值的地方可以用左值来替代，但</li>\n<li>需要左值的地方，一定不能用右值来替代。</li>\n</ul>\n<p>又有一个重要的特点，即</p>\n<ul>\n<li>左值存放在对象中，有持久的状态；而</li>\n<li>右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。</li>\n</ul>\n<h4 id=\"常量左值引用\"><a href=\"#常量左值引用\" class=\"headerlink\" title=\"常量左值引用\"></a>常量左值引用</h4><p>常量左值引用，即const的左值引用。</p>\n<p>右值只能绑定到右值引用上，左值引用不能绑定右值，例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i;     <span class=\"comment\">// ERR: i 是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">2</span>;   <span class=\"comment\">// ERR: i * 2 是右值</span></span><br></pre></td></tr></table></figure></p>\n<p>但是常量左值引用可以绑定右值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 可以将 const 引用绑定到右值上</span></span><br></pre></td></tr></table></figure></p>\n<p>可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 <code>int &amp;r = 42</code> 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = tmp;    <span class=\"comment\">// 让常量引用 ri 绑定到这个临时变量上</span></span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。</p>\n<p>我们再来看看如果 ri 不是常量引用会发生什么：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>; </span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 还是先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = tmp;          <span class=\"comment\">// 再让这个普通引用和 tmp 绑定</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：</p>\n<ul>\n<li>tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。</li>\n<li>就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。</li>\n</ul>\n<p>于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。</p>\n<p>通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。</p>\n<p>同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。</p>\n<h4 id=\"左值引用和右值引用\"><a href=\"#左值引用和右值引用\" class=\"headerlink\" title=\"左值引用和右值引用\"></a>左值引用和右值引用</h4><p>在 C++ 中，有两种对对象的引用：左值引用和右值引用。</p>\n<p>左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;  <span class=\"comment\">// OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; baz = <span class=\"number\">42</span>;   <span class=\"comment\">// Err: 42 是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; qux = <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上</span></span><br></pre></td></tr></table></figure>\n<p>右值引用也是引用，但是它只能且必须绑定在右值上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;        <span class=\"comment\">// OK: 将 foo 绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; baz = foo;       <span class=\"comment\">// Err: foo 可以是左值，所以不能将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; qux = <span class=\"number\">42</span>;        <span class=\"comment\">// OK: 将右值 42 绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; quux = foo * <span class=\"number\">1</span>;  <span class=\"comment\">// OK: foo * 1 的结果是一个右值，将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; garply = foo++;   <span class=\"comment\">// Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; waldo = foo--;   <span class=\"comment\">// OK: 后置自减运算符返回的是右值，将它绑定在右值引用上</span></span><br></pre></td></tr></table></figure>\n<p>由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：</p>\n<ul>\n<li>右值引用的对象，是临时的，即将被销毁；并且</li>\n<li>右值引用的对象，不会在其它地方使用。</li>\n</ul>\n<blockquote>\n<p>敲黑板：这是重点！</p>\n</blockquote>\n<p>这两个特性意味着：<strong>接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏</strong>。</p>\n<p>需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">// OK: 字面量是右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;  <span class=\"comment\">// ERR: rr1 是变量，虽然它是右值引用，但仍然是左值</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"右值的作用\"><a href=\"#右值的作用\" class=\"headerlink\" title=\"右值的作用\"></a>右值的作用</h4><h5 id=\"标准库-move-函数\"><a href=\"#标准库-move-函数\" class=\"headerlink\" title=\"标准库 move 函数\"></a>标准库 move 函数</h5><p>虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr1 = <span class=\"number\">42</span>;                 <span class=\"comment\">// 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr2 = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(rr1);     <span class=\"comment\">// 使用 std::move() 而不是 move()</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。</p>\n<h5 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h5><p>有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。</p>\n<p>和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。</p>\n<p>详见</p>\n<h5 id=\"移动赋值运算符\"><a href=\"#移动赋值运算符\" class=\"headerlink\" title=\"移动赋值运算符\"></a>移动赋值运算符</h5><p>移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyString&amp; Mystring::<span class=\"keyword\">operator</span>=(MyString&amp;&amp; rhs) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>) <span class=\"built_in\">free</span>(<span class=\"built_in\">string</span>);  <span class=\"comment\">// 先将原有资源释放</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> = rhs.<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    rhs.<span class=\"built_in\">string</span> = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。</p>\n<h4 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h4><p>转发与 std::forward 的内容详见<a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a>，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">struct和class的区别</a><br><a href=\"https://guodong.plus/2020/0307-190855/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (一)</a><br><a href=\"https://guodong.plus/2020/0311-225314/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (二)</a><br><a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a><br><a href=\"https://liam.page/2016/12/11/rvalue-reference-in-Cpp/\" target=\"_blank\" rel=\"noopener\">谈谈c++中的右值引用</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"C-基础知识（3）\"><a href=\"#C-基础知识（3）\" class=\"headerlink\" title=\"C++ 基础知识（3）\"></a>C++ 基础知识（3）</h2><h3 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h3><h4 id=\"左值和右值\"><a href=\"#左值和右值\" class=\"headerlink\" title=\"左值和右值\"></a>左值和右值</h4><p>根据《C++ Primer》的说法，左值和右值可以这样区分：</p>\n<blockquote>\n<p>一个表达式是左值还是右值，取决于我们使用的是它的值还是它在内存中的位置（作为对象的身份）。也就是说一个表达式具体是左值还是右值，要根据实际在语句中的含义来确定。例如<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 foo 的值赋给 bar，保存在 bar 对应的内存中</span></span><br><span class=\"line\"><span class=\"comment\">// foo 在这里作为表达式是右值；bar 在这里作为表达式是左值</span></span><br><span class=\"line\"><span class=\"comment\">// 但是 foo 作为对象，既可以充当左值又可以充当右值</span></span><br><span class=\"line\">bar = foo;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>因为 C++ 中的对象本身可以是一个表达式，所以这里有一个重要的原则，即</p>\n<ul>\n<li>在大多数情况下，需要右值的地方可以用左值来替代，但</li>\n<li>需要左值的地方，一定不能用右值来替代。</li>\n</ul>\n<p>又有一个重要的特点，即</p>\n<ul>\n<li>左值存放在对象中，有持久的状态；而</li>\n<li>右值要么是字面常量，要么是在表达式求值过程中创建的临时对象，没有持久的状态。</li>\n</ul>\n<h4 id=\"常量左值引用\"><a href=\"#常量左值引用\" class=\"headerlink\" title=\"常量左值引用\"></a>常量左值引用</h4><p>常量左值引用，即const的左值引用。</p>\n<p>右值只能绑定到右值引用上，左值引用不能绑定右值，例如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr = i;     <span class=\"comment\">// ERR: i 是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">2</span>;   <span class=\"comment\">// ERR: i * 2 是右值</span></span><br></pre></td></tr></table></figure></p>\n<p>但是常量左值引用可以绑定右值：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;r = i * <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 可以将 const 引用绑定到右值上</span></span><br></pre></td></tr></table></figure></p>\n<p>可能一开始会觉得 const 引用可以绑定右值很奇怪，引用并不是对象，他只是为已经存在的对象另取一个名字而已，所以像 <code>int &amp;r = 42</code> 这样的语法是不允许的，因为 42 不是一个对象，只是一个普通字面数值而已，而 const 引用却是一个例外，如果我们将这个过程拆开来看，就可以知道为什么有这个例外了：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们可以先看看常量引用被绑定到另外一种类型上时到底发生了什么</span></span><br><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;ri = tmp;    <span class=\"comment\">// 让常量引用 ri 绑定到这个临时变量上</span></span><br></pre></td></tr></table></figure></p>\n<p>这种情况下，ri 会被绑定到一个 临时量 (temporary)对象上，所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 创建临时量是需要消耗资源的，这也是本文的主题之一：右值引用的由来。</p>\n<p>我们再来看看如果 ri 不是常量引用会发生什么：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> dval = <span class=\"number\">3.14</span>; </span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = dval;</span><br><span class=\"line\"><span class=\"comment\">// 以上将一个双精度浮点数绑定到整型引用上，所以编译器会对其进行类型转换：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> tmp = dval;   <span class=\"comment\">// 还是先将双精度浮点数变成一个整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;ri = tmp;          <span class=\"comment\">// 再让这个普通引用和 tmp 绑定</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样的情况下，我们可以对 ri 进行赋值，因为 ri 并不是常量引用。但有两个问题：</p>\n<ul>\n<li>tmp 是常量，而我们却用一个不是常量的引用与其绑定，这是不被允许的。</li>\n<li>就算我们可以对其进行绑定，而我们绑定的是 tmp，而不是 dval，所以我们对 ri 赋值并不会改变 dval 的值。</li>\n</ul>\n<p>于是乎，编译器直接禁止了这种行为。而常引用就不一样了，反正我们也不会改变其值，只是需要知道它的值而已，并且也不违反语法规则，所以将常引用与这种临时量绑定的行为是被允许的。</p>\n<p>通过上例我们又可以推出一个规则：引用类型必须与其所引用的对象类型保持一致，不然就会引发临时量的产生，从而引发以上两个问题。同样，常引用除外。</p>\n<p>同理我们推出原问题的解：一个字面值如 42，也会产生一个临时量，若不是常引用，同样会引发上文提到的两个问题，所以，我们只可以用常引用绑定右值，而普通引用是不可以的。</p>\n<h4 id=\"左值引用和右值引用\"><a href=\"#左值引用和右值引用\" class=\"headerlink\" title=\"左值引用和右值引用\"></a>左值引用和右值引用</h4><p>在 C++ 中，有两种对对象的引用：左值引用和右值引用。</p>\n<p>左值引用是常见的引用，所以一般在提到「对象的引用」的时候，指得就是左值引用。如果我们将一个对象的内存空间绑定到另一个变量上，那么这个变量就是左值引用。在建立引用的时候，我们是「将内存空间绑定」，因此我们使用的是一个对象在内存中的位置，这是一个左值。因此，我们不能将一个右值绑定到左值引用上。另一方面，由于常量左值引用保证了我们不能通过引用改变对应内存空间的值，因此我们可以将右值绑定在常量引用上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;  <span class=\"comment\">// OK: foo 在此是左值，将它的内存空间与 bar 绑定在一起</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; baz = <span class=\"number\">42</span>;   <span class=\"comment\">// Err: 42 是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; qux = <span class=\"number\">42</span>;  <span class=\"comment\">// OK: 42 是右值，但是编译器可以为它开辟一块内存空间，绑定在 qux 上</span></span><br></pre></td></tr></table></figure>\n<p>右值引用也是引用，但是它只能且必须绑定在右值上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// rvalue-reference</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; bar = foo;        <span class=\"comment\">// OK: 将 foo 绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; baz = foo;       <span class=\"comment\">// Err: foo 可以是左值，所以不能将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; qux = <span class=\"number\">42</span>;        <span class=\"comment\">// OK: 将右值 42 绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; quux = foo * <span class=\"number\">1</span>;  <span class=\"comment\">// OK: foo * 1 的结果是一个右值，将它绑定在右值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; garply = foo++;   <span class=\"comment\">// Err: 后置自增运算符返回的是右值，不能将它绑定在左值引用上</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; waldo = foo--;   <span class=\"comment\">// OK: 后置自减运算符返回的是右值，将它绑定在右值引用上</span></span><br></pre></td></tr></table></figure>\n<p>由于右值引用只能绑定在右值上，而右值要么是字面常量，要么是临时对象，所以：</p>\n<ul>\n<li>右值引用的对象，是临时的，即将被销毁；并且</li>\n<li>右值引用的对象，不会在其它地方使用。</li>\n</ul>\n<blockquote>\n<p>敲黑板：这是重点！</p>\n</blockquote>\n<p>这两个特性意味着：<strong>接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏</strong>。</p>\n<p>需要注意的是，右值引用和左值引用本身都是变量，也就是说其本身都是左值，因此不能将一个右值引用绑定到另一个右值引用上，如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;   <span class=\"comment\">// OK: 字面量是右值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;rr2 = rr1;  <span class=\"comment\">// ERR: rr1 是变量，虽然它是右值引用，但仍然是左值</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"右值的作用\"><a href=\"#右值的作用\" class=\"headerlink\" title=\"右值的作用\"></a>右值的作用</h4><h5 id=\"标准库-move-函数\"><a href=\"#标准库-move-函数\" class=\"headerlink\" title=\"标准库 move 函数\"></a>标准库 move 函数</h5><p>虽然右值引用也是变量，是左值，但是可以通过标准库里的 move 函数将左值转变为右值，使得其可以作为右值绑定到右值引用上。如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr1 = <span class=\"number\">42</span>;                 <span class=\"comment\">// 虽然 rr1 是右值引用类型，但其仍然是变量，所以还是左值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; rr2 = <span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(rr1);     <span class=\"comment\">// 使用 std::move() 而不是 move()</span></span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，调用 move 函数之后，资源的所有权就会发生转移，原先的右值引用（如rr1）就不能再继续使用了，除非对其重新赋值(即给一份新资源)或者销毁掉。</p>\n<h5 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h5><p>有了 move 函数，我们就可以引出移动构造函数和移动赋值运算符了，之前只是提到什么情况下可以使用右值引用，而这里就介绍右值引用该如何应用到实际程序当中了。</p>\n<p>和拷贝构造函数不同的是，移动构造函数接受的是右值引用而非左值引用，并且经过移动构造函数，被移动的对象的资源将被”窃取“掉。在完成资源的移动之后，源对象将不在拥有任何资源，其资源所有权已经转交给新创建的对象了。</p>\n<p>详见</p>\n<h5 id=\"移动赋值运算符\"><a href=\"#移动赋值运算符\" class=\"headerlink\" title=\"移动赋值运算符\"></a>移动赋值运算符</h5><p>移动赋值的原理和移动构造是一样的，下面直接给出移动赋值的代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyString&amp; Mystring::<span class=\"keyword\">operator</span>=(MyString&amp;&amp; rhs) <span class=\"keyword\">noexcept</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">string</span>) <span class=\"built_in\">free</span>(<span class=\"built_in\">string</span>);  <span class=\"comment\">// 先将原有资源释放</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span> = rhs.<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    rhs.<span class=\"built_in\">string</span> = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>只需要注意自我赋值的情况即可，并且如果自己本身就持有着资源，记得一定要先释放掉。</p>\n<h4 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h4><p>转发与 std::forward 的内容详见<a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a>，作者描述的非常详细，通俗易懂。但第一次接触，还是需要多看多揣摩。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/8f38bec08f974de192275e5366d8ae24\" target=\"_blank\" rel=\"noopener\">struct和class的区别</a><br><a href=\"https://guodong.plus/2020/0307-190855/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (一)</a><br><a href=\"https://guodong.plus/2020/0311-225314/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (二)</a><br><a href=\"https://guodong.plus/2020/0314-132811/\" target=\"_blank\" rel=\"noopener\">C++ 引用、移动、转发 (三)</a><br><a href=\"https://liam.page/2016/12/11/rvalue-reference-in-Cpp/\" target=\"_blank\" rel=\"noopener\">谈谈c++中的右值引用</a></p>\n"},{"title":"Hello World","date":"2020-06-12T08:46:15.000Z","top_img":"/img/cover/helloworld.png","cover":"/img/cover/helloworld.png","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2020-06-12 16:46:15\ntop_img: /img/cover/helloworld.png\ncover: /img/cover/helloworld.png\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2021-01-21T03:00:06.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3r00083a6wcazw9ebi","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"unity-shader学习记录","date":"2020-06-16T15:05:44.000Z","top_img":"/img/cover/shader.jpg","cover":"/img/cover/shader.jpg","_content":"\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","source":"_posts/unity-shader学习记录.md","raw":"---\ntitle: unity-shader学习记录\ndate: 2020-06-16 23:05:44\ntop_img: /img/cover/shader.jpg\ncover: /img/cover/shader.jpg\ntags: 笔记\n---\n\n## 《Unity Shader 入门摘要》阅读笔记\n最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。\n\n原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至[作者github](https://github.com/candycat1992/Unity_Shaders_Book)\n\n### 第3章 Unity Shader基础\n**ShaderLab**：Unity为shader开发者专门设计的语言，详情见[官网](https://docs.unity3d.com/Manual/SL-Shader.html)\n\n我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置```CG/HLSL```代码，完成实际的过程，ShaderLab的作用更像是一个框架。\n\nshader的完整结构如下：\n```shader\nShader \"ShaderName\" {\n    Properties {\n        // 属性\n    }\n    SubShader {\n        // 显卡A使用的着色器\n\n        [Tags] // 标签：可选的\n\n        [RenderSetup] // 状态：可选的\n\n        Pass {\n            [Name]\n            [Tags]\n            [RenderSetup]\n            // other code\n        }\n        // other Passes\n    }\n    SubShader {\n        // 显卡B使用的着色器\n    }\n    Fallback \"default shader name\" // Fall Off\n}\n```\n+ ```Properties```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/properties.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Unity支持的Propertiies类型\n        </div>\n    </center>\n+ ```Subshader```的```RenderSetup```支持如下类型，其对内部```Pass```来说是全局存在的\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_setup.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            常见的渲染状态设置选项\n        </div>\n    </center>\n+ ```Subshader```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/subshader_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            SubShader的标签类型\n        </div>\n    </center>\n+ ```Pass```的```Tags```支持如下类型：\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/pass_tags.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            Pass的标签类型\n        </div>\n    </center>\n+ ```UsePass```复用其他shader里的代码，```GrabPass```抓取屏幕存储在一张纹理中供后续Pass使用\n\n### 第4章\n#### 坐标空间与变换\n+ 坐标空间\n    + 模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间\n    + 世界空间：广义上“最大的空间”\n    + 观察空间：摄像机所在的空间，并且摄像机的位置是原点\n    + 裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定\n    + 屏幕空间：最终显现的二维屏幕（空间）\n+ 坐标空间变换\n    + 模型变换：模型空间 -> 世界空间\n    + 观察变换：世界空间 -> 观察空间\n    + 投影变换：观察空间 -> 裁剪空间\n    + 屏幕映射：裁剪空间 -> 屏幕空间\n\n转换关系图如下：\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n#### Unity内置的变换矩阵\nUnity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n#### Unity内置的摄像机和屏幕参数\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n### 第5章\n+ ShaderLab属性类型与CG变量类型的匹配关系\n    | ShaderLab属性类型 | CG变量类型 |\n    |---|---|\n    | Color, Vector | float4, half4, fixed4 |\n    | Range, Float | float, half, fixed |\n    | 2D | sampler2D |\n    | Cube | SamplerCube |\n    | 3D | sampler3D |\n+ UnityCG.cginc中一些常用的结构体\n    | 名称 | 描述 | 包含的变量 |\n    | --- | --- | --- | \n    | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |\n    | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |\n    | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |\n    | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |\n    | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |\n+ UnityCG.cginc中一些常用的帮助函数\n    <center>\n        <img style=\"border-radius: 0.3125em;\n        box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n        src=\"/img/shader/cg_cginc.png\">\n        <br>\n        <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n        display: inline-block;\n        color: #999;\n        padding: 2px;\">\n            UnityCG.cginc中一些常用的帮助函数\n        </div>\n    </center>\n\n+ 可用于顶点着色器的输入的语义\n    | 语义 | 描述 |\n    | --- | --- |\n    | POSITION | 模型空间中的顶点位置，通常是float4类型 |\n    | NORMAL | 顶点法线，通常是float3类型 |\n    | TANGENT | 顶点切线，通常是float4类型 |\n    | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |\n    | COLOR | 顶点颜色，通常是float4或fixed4类型 |\n\n    + 系统数值语义：System-Value sematics，以```SV```开头\n        + SV_POSITION: 顶点着色器的输出pos\n        + SV_TARGET: 片元着色器的输出（输出到颜色缓冲）\n\n### 第6章\n#### 光照模型的计算\n+ 逐像素光照\n    + 主要计算过程在**片元着色器**中；\n    + 以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为**Phong着色(Phong Shading)**\n+ 逐顶点光照\n    + 主要计算过程在**顶点着色器**中；\n    + **Gouraud shading（高洛德着色）**，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。\n\n由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。\n\n### 第7章\n**纹理映射**：将纹理图附在模型表面，逐纹素的控制模型的颜色\n**凹凸映射**：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节\n#### 凹凸映射\n+ 两种实现方式：\n    + **高度映射**：使用一张**高度纹理**模拟表面位移，以得到一个修改后的法线值\n    + **法线映射**：使用一张**法线纹理**直接存储表面法线\n        + 模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中\n        + 切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。***这种方式由于存储的是相对法线，效果更好，更受欢迎。***\n\n### 第8章\n#### 透明度测试\n设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。\n\n在片元着色器中调用`clip(float/float2/float3/float4 x)`函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色\n\n#### 透明度混合\n可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。\n    \n需要关闭**深度写入**，但不关闭**深度检测**，即计算半透明物体时，深度缓冲是**只读**的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。\n\n**解决思路**：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。\n\n混合命令：**Blend**，开启混合后，对alpha的修改才有意义。\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n#### 渲染队列\nUnity提供了**渲染队列**以解决渲染顺序的问题。使用`Subshader`里的**Queue**标签决定模型归于哪个队列。\n\nUnity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。\n\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n#### Cull命令\n| 命令 | 含义 |\n| --- | --- |\n| Cull Off | 关闭剔除 |\n| Cull Back | 剔除背面，只渲染正面，default |\n| Cull Front | 提出正面，只渲染背面 |\n\n### 第12章 屏幕后处理效果\n**屏幕后处理**：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。\n\n####  函数接口：\n+ OnRenderImage函数：\n    ```c#\n    MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)\n    ```\n    `src`是Unity当前渲染得到的源渲染纹理；`dest`是经过`OnRenderImage`函数处理之后的目标渲染纹理，之后会被渲染到屏幕上\n+ Graphics.Blit函数\n    ```c#\n    public static void Blit(Texture src, RenderTexture dest);\n    public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\n    public static void Blit(Texture src, Material mat, int pass=-1);\n    ```\n    `src`对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；\n    `dest`对应了目标渲染纹理，若为null则直接渲染到屏幕上；\n    `mat`是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而`src`纹理将会被传递给shader中`_MainTex`的纹理属性；\n    `pass`的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；\n","slug":"unity-shader学习记录","published":1,"updated":"2021-01-21T03:00:06.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3s00093a6w36me16r3","content":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"《Unity-Shader-入门摘要》阅读笔记\"><a href=\"#《Unity-Shader-入门摘要》阅读笔记\" class=\"headerlink\" title=\"《Unity Shader 入门摘要》阅读笔记\"></a>《Unity Shader 入门摘要》阅读笔记</h2><p>最近想要系统的学习一下unity shader相关的东西，根据别人的推荐看到了这本书。于是决定边看边把一些比较重要或者原本不知道的知识点记录一下。</p>\n<p>原书讲解十分详细，这里只记录本人相关，欲知详情，请移步至<a href=\"https://github.com/candycat1992/Unity_Shaders_Book\" target=\"_blank\" rel=\"noopener\">作者github</a></p>\n<h3 id=\"第3章-Unity-Shader基础\"><a href=\"#第3章-Unity-Shader基础\" class=\"headerlink\" title=\"第3章 Unity Shader基础\"></a>第3章 Unity Shader基础</h3><p><strong>ShaderLab</strong>：Unity为shader开发者专门设计的语言，详情见<a href=\"https://docs.unity3d.com/Manual/SL-Shader.html\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<p>我们手动开发的Shader都是用ShaderLab实现的，当然中间需要内置<code>CG/HLSL</code>代码，完成实际的过程，ShaderLab的作用更像是一个框架。</p>\n<p>shader的完整结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shader &quot;ShaderName&quot; &#123;</span><br><span class=\"line\">    Properties &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡A使用的着色器</span><br><span class=\"line\"></span><br><span class=\"line\">        [Tags] &#x2F;&#x2F; 标签：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        [RenderSetup] &#x2F;&#x2F; 状态：可选的</span><br><span class=\"line\"></span><br><span class=\"line\">        Pass &#123;</span><br><span class=\"line\">            [Name]</span><br><span class=\"line\">            [Tags]</span><br><span class=\"line\">            [RenderSetup]</span><br><span class=\"line\">            &#x2F;&#x2F; other code</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; other Passes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SubShader &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 显卡B使用的着色器</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Fallback &quot;default shader name&quot; &#x2F;&#x2F; Fall Off</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>Properties</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/properties.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Unity支持的Propertiies类型\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>RenderSetup</code>支持如下类型，其对内部<code>Pass</code>来说是全局存在的  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_setup.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          常见的渲染状态设置选项\n      </div>\n  </center></li>\n<li><code>Subshader</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/subshader_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          SubShader的标签类型\n      </div>\n  </center></li>\n<li><code>Pass</code>的<code>Tags</code>支持如下类型：  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/pass_tags.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          Pass的标签类型\n      </div>\n  </center></li>\n<li><code>UsePass</code>复用其他shader里的代码，<code>GrabPass</code>抓取屏幕存储在一张纹理中供后续Pass使用</li>\n</ul>\n<h3 id=\"第4章\"><a href=\"#第4章\" class=\"headerlink\" title=\"第4章\"></a>第4章</h3><h4 id=\"坐标空间与变换\"><a href=\"#坐标空间与变换\" class=\"headerlink\" title=\"坐标空间与变换\"></a>坐标空间与变换</h4><ul>\n<li>坐标空间<ul>\n<li>模型空间：又称“对象空间”，顾名思义是与模型本身有关的空间</li>\n<li>世界空间：广义上“最大的空间”</li>\n<li>观察空间：摄像机所在的空间，并且摄像机的位置是原点</li>\n<li>裁剪空间：摄像机实际上真正能看到的空间，由视锥体决定</li>\n<li>屏幕空间：最终显现的二维屏幕（空间）</li>\n</ul>\n</li>\n<li>坐标空间变换<ul>\n<li>模型变换：模型空间 -&gt; 世界空间</li>\n<li>观察变换：世界空间 -&gt; 观察空间</li>\n<li>投影变换：观察空间 -&gt; 裁剪空间</li>\n<li>屏幕映射：裁剪空间 -&gt; 屏幕空间</li>\n</ul>\n</li>\n</ul>\n<p>转换关系图如下：</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/space.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        坐标空间及对应变换关系\n    </div>\n</center>\n\n<h4 id=\"Unity内置的变换矩阵\"><a href=\"#Unity内置的变换矩阵\" class=\"headerlink\" title=\"Unity内置的变换矩阵\"></a>Unity内置的变换矩阵</h4><p>Unity内置的变换矩阵见下图：（对应上述的空间变换好好研究下）</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/transform_matrix.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的变换矩阵\n    </div>\n</center>\n\n<h4 id=\"Unity内置的摄像机和屏幕参数\"><a href=\"#Unity内置的摄像机和屏幕参数\" class=\"headerlink\" title=\"Unity内置的摄像机和屏幕参数\"></a>Unity内置的摄像机和屏幕参数</h4><center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/camera_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity内置的摄像机和屏幕参数\n    </div>\n</center>\n\n<h3 id=\"第5章\"><a href=\"#第5章\" class=\"headerlink\" title=\"第5章\"></a>第5章</h3><ul>\n<li>ShaderLab属性类型与CG变量类型的匹配关系<br>  | ShaderLab属性类型 | CG变量类型 |<br>  |—-|—-|<br>  | Color, Vector | float4, half4, fixed4 |<br>  | Range, Float | float, half, fixed |<br>  | 2D | sampler2D |<br>  | Cube | SamplerCube |<br>  | 3D | sampler3D |</li>\n<li>UnityCG.cginc中一些常用的结构体<br>  | 名称 | 描述 | 包含的变量 |<br>  | —- | —- | —- |<br>  | appdata_base | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标 |<br>  | appdata_tan | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标 |<br>  | appdata_full | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标 |<br>  | appdata_img | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标 |<br>  | v2f_img | 可用于顶点着色器的输出 | 裁剪空间中的位置、纹理坐标 |</li>\n<li><p>UnityCG.cginc中一些常用的帮助函数</p>\n  <center>\n      <img style=\"border-radius: 0.3125em;\n      box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n      src=\"/img/shader/cg_cginc.png\">\n      <br>\n      <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n      display: inline-block;\n      color: #999;\n      padding: 2px;\">\n          UnityCG.cginc中一些常用的帮助函数\n      </div>\n  </center>\n</li>\n<li><p>可用于顶点着色器的输入的语义<br>  | 语义 | 描述 |<br>  | —- | —- |<br>  | POSITION | 模型空间中的顶点位置，通常是float4类型 |<br>  | NORMAL | 顶点法线，通常是float3类型 |<br>  | TANGENT | 顶点切线，通常是float4类型 |<br>  | TEXCOORDn | 该顶点的第n组纹理坐标，通常是float2或float4类型 |<br>  | COLOR | 顶点颜色，通常是float4或fixed4类型 |</p>\n<ul>\n<li>系统数值语义：System-Value sematics，以<code>SV</code>开头<ul>\n<li>SV_POSITION: 顶点着色器的输出pos</li>\n<li>SV_TARGET: 片元着色器的输出（输出到颜色缓冲）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第6章\"><a href=\"#第6章\" class=\"headerlink\" title=\"第6章\"></a>第6章</h3><h4 id=\"光照模型的计算\"><a href=\"#光照模型的计算\" class=\"headerlink\" title=\"光照模型的计算\"></a>光照模型的计算</h4><ul>\n<li>逐像素光照<ul>\n<li>主要计算过程在<strong>片元着色器</strong>中；</li>\n<li>以每个像素为基础，得到其法线（顶点发现插值或法线纹理采样），再进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为<strong>Phong着色(Phong Shading)</strong></li>\n</ul>\n</li>\n<li>逐顶点光照<ul>\n<li>主要计算过程在<strong>顶点着色器</strong>中；</li>\n<li><strong>Gouraud shading（高洛德着色）</strong>，在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出像素颜色。</li>\n</ul>\n</li>\n</ul>\n<p>由于顶点数往往小于像素数量，因此逐顶点光照的计算量更小；但是如果模型中有非线性插值的计算，逐顶点光照的结果会有问题（棱角现象）。</p>\n<h3 id=\"第7章\"><a href=\"#第7章\" class=\"headerlink\" title=\"第7章\"></a>第7章</h3><p><strong>纹理映射</strong>：将纹理图附在模型表面，逐纹素的控制模型的颜色<br><strong>凹凸映射</strong>：使用一张纹理图（法线纹理/高度纹理）来改变模型表面的法线，为模型提供更多细节</p>\n<h4 id=\"凹凸映射\"><a href=\"#凹凸映射\" class=\"headerlink\" title=\"凹凸映射\"></a>凹凸映射</h4><ul>\n<li>两种实现方式：<ul>\n<li><strong>高度映射</strong>：使用一张<strong>高度纹理</strong>模拟表面位移，以得到一个修改后的法线值</li>\n<li><strong>法线映射</strong>：使用一张<strong>法线纹理</strong>直接存储表面法线<ul>\n<li>模型空间的法线纹理：修改后的模型空间的表面法线存储在一张纹理中</li>\n<li>切线空间的法线纹理：对每个顶点，求出顶点在其切线空间内的法线，将其存储到法线纹理中。<strong><em>这种方式由于存储的是相对法线，效果更好，更受欢迎。</em></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"第8章\"><a href=\"#第8章\" class=\"headerlink\" title=\"第8章\"></a>第8章</h3><h4 id=\"透明度测试\"><a href=\"#透明度测试\" class=\"headerlink\" title=\"透明度测试\"></a>透明度测试</h4><p>设置一个阈值，当片元的透明度不满足条件时，该片元会被舍弃（不再做任何处理），否则就视为不透明物体处理。因此它并不能实现真正的半透明效果。</p>\n<p>在片元着色器中调用<code>clip(float/float2/float3/float4 x)</code>函数进行透明度测试，当传入的参数有任何一个分量是负数，就会舍弃当前像素的输出颜色</p>\n<h4 id=\"透明度混合\"><a href=\"#透明度混合\" class=\"headerlink\" title=\"透明度混合\"></a>透明度混合</h4><p>可以实现真正的半透明效果。他会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>\n<p>需要关闭<strong>深度写入</strong>，但不关闭<strong>深度检测</strong>，即计算半透明物体时，深度缓冲是<strong>只读</strong>的。这会导致渲染的顺序十分重要，因为这时深度缓冲无法完全正常工作。</p>\n<p><strong>解决思路</strong>：先渲染所有的不透明物体，这里深度关系会一切正常；再将半透明物体加入渲染（半透明物体之间的遮挡关系仍有问题，先不考虑）。</p>\n<p>混合命令：<strong>Blend</strong>，开启混合后，对alpha的修改才有意义。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的Blend命令\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_param.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合因子\n    </div>\n</center>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/blend_op.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        ShaderLab的混合操作\n    </div>\n</center>\n\n<h4 id=\"渲染队列\"><a href=\"#渲染队列\" class=\"headerlink\" title=\"渲染队列\"></a>渲染队列</h4><p>Unity提供了<strong>渲染队列</strong>以解决渲染顺序的问题。使用<code>Subshader</code>里的<strong>Queue</strong>标签决定模型归于哪个队列。</p>\n<p>Unity内部使用整数索引来表示每个渲染队列，索引号越小表示越早渲染。</p>\n<center>\n    <img style=\"border-radius: 0.3125em;\n    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);\" \n    src=\"/img/shader/queue.png\">\n    <br>\n    <div style=\"color:orange; border-bottom: 1px solid #d9d9d9;\n    display: inline-block;\n    color: #999;\n    padding: 2px;\">\n        Unity提前定义的5个渲染队列\n    </div>\n</center>\n\n<h4 id=\"Cull命令\"><a href=\"#Cull命令\" class=\"headerlink\" title=\"Cull命令\"></a>Cull命令</h4><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cull Off</td>\n<td>关闭剔除</td>\n</tr>\n<tr>\n<td>Cull Back</td>\n<td>剔除背面，只渲染正面，default</td>\n</tr>\n<tr>\n<td>Cull Front</td>\n<td>提出正面，只渲染背面</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"第12章-屏幕后处理效果\"><a href=\"#第12章-屏幕后处理效果\" class=\"headerlink\" title=\"第12章 屏幕后处理效果\"></a>第12章 屏幕后处理效果</h3><p><strong>屏幕后处理</strong>：通常指的是在渲染完整个场景得到屏幕图像之后，再对这个图像进行一系列操作，实现各种屏幕特效（景深、运动模糊等）。</p>\n<h4 id=\"函数接口：\"><a href=\"#函数接口：\" class=\"headerlink\" title=\"函数接口：\"></a>函数接口：</h4><ul>\n<li>OnRenderImage函数：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MonoBehaviour.OnRenderImage(RenderTexture src, RenderTexture dest)</span><br></pre></td></tr></table></figure>\n  <code>src</code>是Unity当前渲染得到的源渲染纹理；<code>dest</code>是经过<code>OnRenderImage</code>函数处理之后的目标渲染纹理，之后会被渲染到屏幕上</li>\n<li>Graphics.Blit函数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void Blit(Texture src, RenderTexture dest);</span><br><span class=\"line\">public static void Blit(Texture src, RenderTexture dest, Material mat, int pass&#x3D;-1);</span><br><span class=\"line\">public static void Blit(Texture src, Material mat, int pass&#x3D;-1);</span><br></pre></td></tr></table></figure>\n  <code>src</code>对应了源纹理，通常就是当前屏幕的渲染纹理或是上一步处理后得到的渲染纹理；<br>  <code>dest</code>对应了目标渲染纹理，若为null则直接渲染到屏幕上；<br>  <code>mat</code>是我们使用的材质，它使用的shader会进行一系列屏幕后处理操作，而<code>src</code>纹理将会被传递给shader中<code>_MainTex</code>的纹理属性；<br>  <code>pass</code>的默认值为-1，表示会一次调用shader内的所有Pass；否则只调用给定索引的Pass；</li>\n</ul>\n"},{"title":"数据库基础-1","date":"2021-01-21T11:50:55.000Z","top_img":"/img/cover/database.jpg","cover":"/img/cover/database.jpg","_content":"\n## 数据库基础知识（1）\n### 事务\n数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。\n\n#### 原子性(Atomicity)\n原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。\n\n#### 一致性(Consistency)\n一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。\n\n当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。\n\n#### 隔离性(Isolation)\n隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。\n\n隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n1. 脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。\n2. 不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。\n3. 幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。\n\nSQL 标准定义了四个隔离级别：\n1. **读取未提交**(Read Uncommited)\n    + 最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致**脏读、幻读或不可重复读**。\n2. **读取已提交**(Read Commited)\n    + 事务智能读取到其他事务已提交的修改。**可以阻止脏读，但不能阻止幻读和不可重复读**。\n3. **可重复读**(Repeatable Read)\n    + 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但不能阻止幻读**。\n4. **串行化**(Serializable)\n    + 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别**可以防止脏读、不可重复读以及幻读**。\n\n#### 持久性(Durability)\n持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 范式\n1. 第一范式(1NF)：无重复的列。\n    在关系模型中，对于添加的一个规范要求，**所有的域都应该是原子性**的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。\n2. 第二范式(2NF)：属性完全依赖于主键\n    第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。\n3. 第三范式(3NF)：任何非主属性不依赖于其它非主属性\n    第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。\n4. BCNF：主属性不能对主键子集依赖\n    巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。\n\n### 索引\n众所周知，给表加上索引就可以加快表的查询速度，因为索引的结构是通过平衡树来维持的。\n\n常规的索引分为聚集索引和非聚集索引两类，聚集索引就是将表的主键作为平衡树的节点值，以主键的值来排列表中条目的顺序。也就是说，通过聚集索引就可以实现从主键到条目数据这个过程。\n\n而非聚集索引是指将表中的非主键属性作为平衡树的值，每个表可以建立多个非聚集索引，而非聚集索引主要实现的就是从非主键属性找到主键属性。\n\n增加索引一方面会提高查询效率，一方面也会降低修改效率，因为数据修改也会导致平衡树的调整，这对于不加索引的表来说是多余的操作。而且，建立索引也会增加额外数据量，导致占用的存储空间变大。\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab)\n[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)\n[数据库范式解析](https://blog.csdn.net/GarfieldEr007/article/details/54319026)","source":"_posts/数据库基础-1.md","raw":"---\ntitle: 数据库基础-1\ndate: 2021-01-21 19:50:55\ntop_img: /img/cover/database.jpg\ncover: /img/cover/database.jpg\ntags: [Database, intern, 笔记]\n---\n\n## 数据库基础知识（1）\n### 事务\n数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。\n\n#### 原子性(Atomicity)\n原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。\n\n#### 一致性(Consistency)\n一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。\n\n当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。\n\n#### 隔离性(Isolation)\n隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。\n\n隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。\n\n在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n1. 脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。\n2. 不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。\n3. 幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。\n\nSQL 标准定义了四个隔离级别：\n1. **读取未提交**(Read Uncommited)\n    + 最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致**脏读、幻读或不可重复读**。\n2. **读取已提交**(Read Commited)\n    + 事务智能读取到其他事务已提交的修改。**可以阻止脏读，但不能阻止幻读和不可重复读**。\n3. **可重复读**(Repeatable Read)\n    + 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但不能阻止幻读**。\n4. **串行化**(Serializable)\n    + 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别**可以防止脏读、不可重复读以及幻读**。\n\n#### 持久性(Durability)\n持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。\n\n### 范式\n1. 第一范式(1NF)：无重复的列。\n    在关系模型中，对于添加的一个规范要求，**所有的域都应该是原子性**的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。\n2. 第二范式(2NF)：属性完全依赖于主键\n    第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。\n3. 第三范式(3NF)：任何非主属性不依赖于其它非主属性\n    第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。\n4. BCNF：主属性不能对主键子集依赖\n    巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。\n\n### 索引\n众所周知，给表加上索引就可以加快表的查询速度，因为索引的结构是通过平衡树来维持的。\n\n常规的索引分为聚集索引和非聚集索引两类，聚集索引就是将表的主键作为平衡树的节点值，以主键的值来排列表中条目的顺序。也就是说，通过聚集索引就可以实现从主键到条目数据这个过程。\n\n而非聚集索引是指将表中的非主键属性作为平衡树的值，每个表可以建立多个非聚集索引，而非聚集索引主要实现的就是从非主键属性找到主键属性。\n\n增加索引一方面会提高查询效率，一方面也会降低修改效率，因为数据修改也会导致平衡树的调整，这对于不加索引的表来说是多余的操作。而且，建立索引也会增加额外数据量，导致占用的存储空间变大。\n\n## 参考链接\n[c++面试宝典](https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab)\n[深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)\n[数据库范式解析](https://blog.csdn.net/GarfieldEr007/article/details/54319026)","slug":"数据库基础-1","published":1,"updated":"2021-01-21T14:21:21.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6y1e3u000b3a6w8cmy0sm7","content":"<h2 id=\"数据库基础知识（1）\"><a href=\"#数据库基础知识（1）\" class=\"headerlink\" title=\"数据库基础知识（1）\"></a>数据库基础知识（1）</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。</p>\n<h4 id=\"原子性-Atomicity\"><a href=\"#原子性-Atomicity\" class=\"headerlink\" title=\"原子性(Atomicity)\"></a>原子性(Atomicity)</h4><p>原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。</p>\n<h4 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h4><p>一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。</p>\n<p>当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。</p>\n<h4 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h4><p>隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。</p>\n<p>隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ol>\n<li>脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。</li>\n<li>不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。</li>\n<li>幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。</li>\n</ol>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ol>\n<li><strong>读取未提交</strong>(Read Uncommited)<ul>\n<li>最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致<strong>脏读、幻读或不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>读取已提交</strong>(Read Commited)<ul>\n<li>事务智能读取到其他事务已提交的修改。<strong>可以阻止脏读，但不能阻止幻读和不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>(Repeatable Read)<ul>\n<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但不能阻止幻读</strong>。</li>\n</ul>\n</li>\n<li><strong>串行化</strong>(Serializable)<ul>\n<li>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h4><p>持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h3 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h3><ol>\n<li>第一范式(1NF)：无重复的列。<br> 在关系模型中，对于添加的一个规范要求，<strong>所有的域都应该是原子性</strong>的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。</li>\n<li>第二范式(2NF)：属性完全依赖于主键<br> 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。</li>\n<li>第三范式(3NF)：任何非主属性不依赖于其它非主属性<br> 第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</li>\n<li>BCNF：主属性不能对主键子集依赖<br> 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。</li>\n</ol>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>众所周知，给表加上索引就可以加快表的查询速度，因为索引的结构是通过平衡树来维持的。</p>\n<p>常规的索引分为聚集索引和非聚集索引两类，聚集索引就是将表的主键作为平衡树的节点值，以主键的值来排列表中条目的顺序。也就是说，通过聚集索引就可以实现从主键到条目数据这个过程。</p>\n<p>而非聚集索引是指将表中的非主键属性作为平衡树的值，每个表可以建立多个非聚集索引，而非聚集索引主要实现的就是从非主键属性找到主键属性。</p>\n<p>增加索引一方面会提高查询效率，一方面也会降低修改效率，因为数据修改也会导致平衡树的调整，这对于不加索引的表来说是多余的操作。而且，建立索引也会增加额外数据量，导致占用的存储空间变大。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://zhuanlan.zhihu.com/p/23624390\" target=\"_blank\" rel=\"noopener\">深入浅出数据库索引原理</a><br><a href=\"https://blog.csdn.net/GarfieldEr007/article/details/54319026\" target=\"_blank\" rel=\"noopener\">数据库范式解析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据库基础知识（1）\"><a href=\"#数据库基础知识（1）\" class=\"headerlink\" title=\"数据库基础知识（1）\"></a>数据库基础知识（1）</h2><h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，是DBMS当中用户程序的任何一次执行，事务是DBMS能看到的基本修改单元。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。</p>\n<h4 id=\"原子性-Atomicity\"><a href=\"#原子性-Atomicity\" class=\"headerlink\" title=\"原子性(Atomicity)\"></a>原子性(Atomicity)</h4><p>原子性是指每个事务内的所有操作对于数据库要么全部成功，要么全部取消。如果事务执行失败，那么状态回到事务发生之前（即事务回滚）。</p>\n<h4 id=\"一致性-Consistency\"><a href=\"#一致性-Consistency\" class=\"headerlink\" title=\"一致性(Consistency)\"></a>一致性(Consistency)</h4><p>一致性是指事务使得数据库从一个一致状态转变到另一个一致状态。可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性。</p>\n<p>当然也有对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。</p>\n<h4 id=\"隔离性-Isolation\"><a href=\"#隔离性-Isolation\" class=\"headerlink\" title=\"隔离性(Isolation)\"></a>隔离性(Isolation)</h4><p>隔离性是指各个事务的执行结果不会对其他事务执行造成影响，多个事务之间的结果一定满足一个串行执行的结果。</p>\n<p>隔离性的保证通过加互斥锁来实现，一个在执行的事务会拿到锁，这时其他事务因拿不到锁而等待，只有当前事务执行成功或者失败回滚之后才会放锁。</p>\n<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>\n<ol>\n<li>脏读(Dirty read)：事务可以读到其他事务修改但尚未提交的数据，对这种数据做的操作可能是无效的，因此称为“脏读”。</li>\n<li>不可重复读(Unrepeatable read)：一个事务多次读取一个数据的过程中，可能有其他事务修改了该数据，导致多次读取的结果不相同，因此称为“不可重复读”。</li>\n<li>幻读(Phantom read)：幻读与不可重复读类似，但幻读针对的是一组数据的数量变化导致的问题。当前事务对该组数据进行操作时，由于其他事务插入或删除该组数据中的某些数据（比如表里删去一行），导致前后读取的结果不一致，好像发生了幻觉一样，因此称为“幻读”。</li>\n</ol>\n<p>SQL 标准定义了四个隔离级别：</p>\n<ol>\n<li><strong>读取未提交</strong>(Read Uncommited)<ul>\n<li>最低级别的隔离，事务可以读取到尚未提交的事务的修改。可能会导致<strong>脏读、幻读或不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>读取已提交</strong>(Read Commited)<ul>\n<li>事务智能读取到其他事务已提交的修改。<strong>可以阻止脏读，但不能阻止幻读和不可重复读</strong>。</li>\n</ul>\n</li>\n<li><strong>可重复读</strong>(Repeatable Read)<ul>\n<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但不能阻止幻读</strong>。</li>\n</ul>\n</li>\n<li><strong>串行化</strong>(Serializable)<ul>\n<li>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别<strong>可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"持久性-Durability\"><a href=\"#持久性-Durability\" class=\"headerlink\" title=\"持久性(Durability)\"></a>持久性(Durability)</h4><p>持久性是指被提交的事务对数据库中的数据的改变是永久的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>\n<h3 id=\"范式\"><a href=\"#范式\" class=\"headerlink\" title=\"范式\"></a>范式</h3><ol>\n<li>第一范式(1NF)：无重复的列。<br> 在关系模型中，对于添加的一个规范要求，<strong>所有的域都应该是原子性</strong>的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。</li>\n<li>第二范式(2NF)：属性完全依赖于主键<br> 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实例或记录必须可以被唯一地区分。也就是存在某一个属性，使得表中的每一个实例都可以根据该属性实现区分，不存在两个所有属性都一样的实例。</li>\n<li>第三范式(3NF)：任何非主属性不依赖于其它非主属性<br> 第三范式是第二范式的一个子集，即满足第三范式必须满足第二范式。简而言之，第三范式要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</li>\n<li>BCNF：主属性不能对主键子集依赖<br> 巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足BCNF必须满足3NF。在3NF基础上，任何主属性不能对主键子集依赖（在3NF基础上消除对主码子集的依赖）。主属性是指可以作为该数据表候选码的属性，当选定某一组主属性作为候选码时，其余主属性不依赖于候选码的部分属性则满足BCNF。</li>\n</ol>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>众所周知，给表加上索引就可以加快表的查询速度，因为索引的结构是通过平衡树来维持的。</p>\n<p>常规的索引分为聚集索引和非聚集索引两类，聚集索引就是将表的主键作为平衡树的节点值，以主键的值来排列表中条目的顺序。也就是说，通过聚集索引就可以实现从主键到条目数据这个过程。</p>\n<p>而非聚集索引是指将表中的非主键属性作为平衡树的值，每个表可以建立多个非聚集索引，而非聚集索引主要实现的就是从非主键属性找到主键属性。</p>\n<p>增加索引一方面会提高查询效率，一方面也会降低修改效率，因为数据修改也会导致平衡树的调整，这对于不加索引的表来说是多余的操作。而且，建立索引也会增加额外数据量，导致占用的存储空间变大。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://www.nowcoder.com/tutorial/93/60c2f308109c4a7d8089a710b9ba1dab\" target=\"_blank\" rel=\"noopener\">c++面试宝典</a><br><a href=\"https://zhuanlan.zhihu.com/p/23624390\" target=\"_blank\" rel=\"noopener\">深入浅出数据库索引原理</a><br><a href=\"https://blog.csdn.net/GarfieldEr007/article/details/54319026\" target=\"_blank\" rel=\"noopener\">数据库范式解析</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckk6y1e2x00003a6w2zzn7o85","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e3r00073a6w4lpyat19"},{"post_id":"ckk6y1e3s00093a6w36me16r3","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e3v000c3a6w1becbjpw"},{"post_id":"ckk6y1e3500013a6wag7x5ncv","tag_id":"ckk6y1e3q00063a6we1504yqv","_id":"ckk6y1e3x000e3a6w9gu5gv5r"},{"post_id":"ckk6y1e3500013a6wag7x5ncv","tag_id":"ckk6y1e3t000a3a6wga0mh52l","_id":"ckk6y1e3x000f3a6w0zwj527y"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e41000j3a6wdl7y5hn8"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e41000k3a6wdv74e449"},{"post_id":"ckk6y1e3n00033a6w6rm5b4e1","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e42000m3a6wdlgr2mc6"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e43000o3a6w4fc5bat8"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e43000p3a6w160dazad"},{"post_id":"ckk6y1e3o00043a6w03n32plb","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e44000r3a6w5xmldt4k"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3v000d3a6wcpcp2rv3","_id":"ckk6y1e45000t3a6w5jotgfev"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e45000u3a6w52wx72g5"},{"post_id":"ckk6y1e3p00053a6w57ht8r87","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e46000w3a6wflum7fbf"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e44000s3a6wh1s69ajs","_id":"ckk6y1e46000x3a6whuyo9sxi"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e3x000g3a6w6iz3hyjm","_id":"ckk6y1e47000y3a6w5by9222p"},{"post_id":"ckk6y1e3u000b3a6w8cmy0sm7","tag_id":"ckk6y1e3l00023a6w6b6x1r3h","_id":"ckk6y1e47000z3a6wf5ra7n5o"}],"Tag":[{"name":"笔记","_id":"ckk6y1e3l00023a6w6b6x1r3h"},{"name":"config","_id":"ckk6y1e3q00063a6we1504yqv"},{"name":"教程","_id":"ckk6y1e3t000a3a6wga0mh52l"},{"name":"c++","_id":"ckk6y1e3v000d3a6wcpcp2rv3"},{"name":"intern","_id":"ckk6y1e3x000g3a6w6iz3hyjm"},{"name":"Database","_id":"ckk6y1e44000s3a6wh1s69ajs"}]}}