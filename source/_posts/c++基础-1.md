---
title: c++ 基础(1)
date: 2021-01-20 14:51:34
top_img: /img/cover/cpp.jpg
cover: /img/cover/cpp.jpg
tags: [c++, intern, 笔记]
---

## C++ 基础知识（1）
### C++和C的区别
设计思想上：

    C++是面向对象的语言，而C是面向过程的结构化编程语言

语法上：

    C++具有封装、继承和多态三种特性
    C++相比C，增加多许多类型安全的功能，比如强制类型转换、
    C++支持范式编程，比如模板类、函数模板等

### C/C++ 中指针和引用的区别
1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
5. 可以有const指针，但是没有const引用；
6. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；
7. 指针可以有多级指针（**p），而引用至于一级；
8. 指针和引用使用++运算符的意义不一样；
9. 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

### 说一下static关键字的作用
1. 全局静态变量
在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量.
静态存储区，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2.  局部静态变量
在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。
内存中的位置：静态存储区
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

3. 静态函数
在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
函数的实现使用 static 修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

注：不要再头文件中声明 static 的全局函数，不要在cpp内声明非 static 的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上 static 修饰；

4. 类的静态成员
在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

5. 类的静态函数
静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。
在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

### 智能指针
c++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且auto_ptr已经被11弃用。

头文件：
```c++
#include <memory>
```

为什么要使用智能指针？
智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。

#### 1. auto_ptr
采用所有权模式。
```c++
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错.
```
此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题！

#### 2. unique_ptr（替换auto_ptr）
unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

采用所有权模式，还是上面那个例子
```c++
unique_ptr<string> p3 (new string ("auto"));   //#4
unique_ptr<string> p4;                         //#5
p4 = p3;                                       //此时会报错！！
```

编译器认为`p4=p3`非法，避免了p3不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr 更安全。

另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：

```c++
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed

unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed
```

其中#1留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr。

注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;

// output: hello alexia
```

#### 3. shared_ptr
shared_ptr 实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放**。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。**当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放**。

shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

| 成员函数名称 | 描述 |
| --- | --- |
| use_count | 返回引用计数的个数 |
| unique | 返回是否是独占所有权( use_count 为 1) |
| swap | 交换两个 shared_ptr 对象(即交换所拥有的对象) |
| reset | 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少 |
| get | 返回内部对象(指针) ，等价于对象本身（已经重载了()方法） |

#### 4. weak_ptr
weak_ptr 是一种不控制对象生命周期的智能指针，是对对象的弱引用。它指向一个 shared_ptr 管理的对象，但进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的**构造和析构不会引起引用记数的增加或减少**。

weak_ptr 是用来解决 shared_ptr **相互引用时的死锁问题**，如果说两个 shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。

和 shared_ptr 之间可以相互转化，**shared_ptr 可以直接赋值给它，它可以通过调用lock函数来获得 shared_ptr**。

weak_ptr 不能直接访问对象，而应先转化为 shared_ptr，如：
```c++
weak_ptr a;
shared_ptr b = a.lock();
b->print();
```

#### 智能指针有没有内存泄漏，有的话如何解决
有，当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

## 参考链接
[C++面试宝典](https://www.nowcoder.com/tutorial/93/a34ed23d58b84da3a707c70371f59c21)