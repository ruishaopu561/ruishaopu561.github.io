---
title: 数据库基础-2
date: 2021-01-24 22:59:00
top_img: /img/cover/database.jpg
cover: /img/cover/database.jpg
tags: [Database, intern, 笔记]
---

## 数据库基础知识（2）
### Mysql
#### 超键 候选键 主键 外键
**超键(super key)**：在关系中能唯一标识元组的属性集称为关系模式的超键。超键一定包含主键。
**候选键(candidate key)**：不含多余属性的超键称为候选键。即若在候选键中删除一个属性，那么该属性集就不是键了。
**主键(primary key)**：用户选作元组标识的一个候选键。
**外键(foreign key)**：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。

#### 视图
基本语法：
```sql
create view view_name as select_sql;                -- 创建视图
select * from view_name;                            -- 查看视图
create or replace view name as select_sql;          -- 更新视图，不更新表
update view_name;                                   -- 更新视图，也更新表
drop view view_name;                                -- 删除视图
```

视图是查询表结果的一个临时存储，便于简化复杂的sql操作，隐藏具体的细节，保护数据。视图创建后，可以使用与表相同的方式利用它们。

一般来说，视图只作查询使用，并不能更新，不能被索引，也不能有关联的触发器或默认值。但是对于某些视图(比如未使用联结子查询分组聚集函数 Distinct Union 等)，是可以对其更新的，并且也会对基表进行更新。

视图和表的区别：
1. 视图是已经编译好的sql语句；而表不是。  
2. 视图没有实际的物理记录；而表有。
3. 表是内容；视图是窗口。
4. 表只用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它进行修改，但视图只能有创建的语句来修改。
5. 表是内模式；视图是外模式。
6. 视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。从安全的角度说，视图可以不给用户接触数据表，从而不知道表结构。
7. 表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。
8. 视图的建立和删除只影响视图本身，不影响对应的基本表。

视图和表的联系：
    视图是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有数据行）都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也可以对应多个基本表。视图是基本表的抽象和在逻辑意义上建立的新关系。

#### drop delete truncate
基本语法：
```sql
drop table table_name                           -- 直接删掉表
truncate table table_name                       -- 删除表中数据，再插入时自增长id又从1开始
delete from table_name where_sql                -- 删除表中数据，可以加where字句
```

1. 一般而言，drop > truncate > delete
2. 应用范围：truncate 只能对 table；delete 可以是 table 和 view 。
3. truncate 和 delete 只删除数据，而 drop 则删除整个表（结构和数据）。
4. 表和索引所占空间。drop 语句将表所占用的空间全释放掉；truncate 语句将表和索引所占用的空间会恢复到初始大小；而 delete 操作不会减少表或索引所占用的空间。
5. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop；若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老是想触发 trigger，还是用 delete。
6. delete 语句为 DML(Data Manipulation Language)，这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger，执行的时候将被触发； truncate、drop 是 DDL(Data Define Language)，操作立即生效，原数据不放到 rollback segment 中，不能回滚。
7. truncate 在功能上与不带 where 子句的 delete 语句相同——二者均删除表中的全部行。但 truncate 比 delete 速度快，且使用的系统和事务日志资源少。delete 语句每次删除一行，就在事务日志中为所删除的行记录一项，因此可以回滚。truncate 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放，因此删除的行是没法回滚的，也不会激活相关的触发器。
8. truncate 与不带 where 的 delete 只删除数据，而不删除表的结构；而 drop 语句将删除表的结构、被依赖的约束(constrain)、触发器(trigger)、索引(index)，依赖于该表的存储过程/函数将被保留，但其状态会变为 invalid。
9. truncate 删除表中的所有行，但表结构及其列、约束、索引等保持不变，新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 delete。如果要删除表定义及其数据，请使用 drop。
10. 对于由 foreign key 约束引用的表，不能使用 truncate，而应使用不带 where 的 delete 语句。

#### 连接的种类
查询分析器中执行：
```sql
--建表table1,table2：
create table table1(id int,name varchar(10));
create table table2(id int,score int);

insert into table1 select 1,'lee';
insert into table1 select 2,'zhang';
insert into table1 select 4,'wang';
insert into table2 select 1,90;
insert into table2 select 2,100;
insert into table2 select 3,70;
```

如表:
```sql
-------------------------------------------------
|  table1  |  table2  |
-------------------------------------------------
| id  name | id score |
| 1    lee | 1     90 |
| 2  zhang | 2    100 |
| 4   wang | 3     70 |
-------------------------------------------------
```

以下均在查询分析器中执行
##### 一、外连接
概念：包括左向外联接、右向外联接和完整外部联接

1. 左连接：`left join`或`left outer join`
    左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。

    ```sql
    select * from table1 left join table2 on table1.id=table2.id
    -----------result------------
    | id  name   id  score |
    -----------------------------
    | 1    lee    1     90 |
    | 2  zhang    2    100 |
    | 4   wang  NULL  NULL |
    -----------------------------
    -- 注释：包含 table1 的所有子句，根据指定条件返回 table2 相应的字段，不符合的以 null 显示
    ```

2. 右连接：`right join`或`right outer join`
    右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。

    ```sql
    select * from table1 right join table2 on table1.id=table2.id
    ------------result------------
    | id    name id  score |
    ------------------------------
    |   1    lee  1     90 |
    |   2  zhang  2    100 |
    | NULL  NULL  3     70 |
    ------------------------------
    -- 注释：包含 table2 的所有子句，根据指定条件返回 table1 相应的字段，不符合的以 null 显示
    ```

3. 完整外部联接:`full join`或`full outer join`
    完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。
    ```sql
    select * from table1 full join table2 on table1.id=table2.id
    -------------结果-------------
    | id   name   id score |
    ------------------------------
    | 1     lee    1    90 |
    | 2   zhang    2   100 |
    | 4    wang NULL  NULL |
    | NULL NULL    3    70 |
    ------------------------------
    -- 注释：返回左右连接的和（见上左、右连接）
    ```

##### 二、内连接
概念：内联接是用比较运算符比较要联接列的值的联接

内连接：`join`或`inner join`
```sql
select * from table1 join table2 on table1.id=table2.id
-------------结果-------------
| id  name  id  score |
------------------------------
|  1   lee   1     90 |
|  2 zhang   2    100 |
------------------------------
-- 注释：只返回符合条件的table1和table2的列
```
等价（与下列执行效果相同）
```sql
A: select a.*, b.* from table1 a, table2 b where a.id=b.id
B: select * from table1 cross join table2 where table1.id=table2.id
-- 注：cross join后加条件只能用where, 不能用on
```

##### 三、交叉连接(完全)
概念：没有 WHERE 子句的交叉联接将产生联接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。（table1和table2交叉连接产生3*3=9条记录）

交叉连接：`cross join`(不带条件where...)

```sql
select * from table1 cross join table2
-------------结果-------------
| id  name  id score |
------------------------------
| 1    lee   1    90 |
| 2  zhang   1    90 |
| 4   wang   1    90 |
| 1    lee   2   100 |
| 2  zhang   2   100 |
| 4   wang   2   100 |
| 1    lee   3    70 |
| 2  zhang   3    70 |
| 4   wang   3    70 |
------------------------------
-- 注释：返回3*3=9条记录，即笛卡尔积
```

等价
```sql
A: select * from table1, table2
```

#### 数据库优化的思路
##### 1. SQL语句优化
- 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描。  
- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
    ```sql
    select id from t where num is null
    ```
    可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
    ```sql
    select id from t where num=0
    ```
- 很多时候用 exists 代替 in 是一个好的选择。
- 用 Where 子句替换 having 子句 因为 having 只会在检索出所有记录之后才对结果集进行过滤。

##### 2. 索引优化
详见[数据库基础-1](https://ruishaopu561.github.io/2021/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-1/)索引部分

##### 3. 数据库结构优化
1. 范式优化： 比如消除冗余（节省空间......）
2. 反范式优化：比如适当加冗余等（减少join）
3. 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的表可采取此方法。可按月自动建表分区。

- 拆分其实又分垂直拆分和水平拆分：
    + **垂直拆分**：
    解决问题：表与表之间的io竞争 
    不解决问题：单表中数据量增长出现的压力 
    + **水平拆分**：    
    解决问题：单表中数据量增长出现的压力 
    不解决问题：表与表之间的io争夺

    + 案例： 简单购物系统暂设涉及如下表：
        1. 产品表（数据量10w，稳定） 
        2. 订单表（数据量200w，且有增长趋势）
        3. 用户表 （数据量100w，且有增长趋势）    
    
        + 垂直划分方案： 把产品表和用户表放到一个server上，订单表单独放到一个server上
        + 水平划分方案：用户表通过性别拆分为男用户表和女用户表，订单表通过已完成和完成中拆分为已完成订单和未完成订单，产品表未完成订单放一个server上，已完成订单表和男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)

##### 4. 服务器硬件优化
这个么，多花钱咯

#### 存储过程与触发器的区别
触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用 EXECUTE 语句调用，而是在用户执行 Transact-SQL 语句时自动触发（激活）执行。

触发器是在一个修改了指定表中的数据时执行的存储过程。

通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。

触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL SERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。

#### MySQL引擎
```sql
show engines;                                            -- 查看存储引擎
show variables like 'storage_engine';                    -- 查看数据库默认使用的引擎
create table table_name()engine=engine_name;             -- 建表时设置引擎
```
Mysql有很多种引擎，这里主要记录一下 InnoDB 和 MyISAM 两种。
##### InnoDB存储引擎
InnoDB是事务型数据库的首选引擎，也是默认的MySQL引擎，支持事务安全表（ACID），支持行锁定和外键。

> InnoDB主要特性
+ 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合
+ 为在主内存中缓存数据和索引，InnoDB存储引擎有维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上
+ InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键

使用 InnoDB 存储引擎，MySQL将在数据目录下创建一个名为`ibdata1`的10MB大小的自动扩展数据文件，以及两个名为`ib_logfile0`和`ib_logfile1`的5MB大小的日志文件。

##### MyISAM存储引擎
MyISAM 基于`ISAM存储引擎`，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有**较高的插入、查询速度，但不支持事务**。

> MyISAM主要特性：
+ 被大文件系统和操作系统支持
+ 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成
+ 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16
+ 最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上
+ BLOB和TEXT列可以被索引
+ NULL被允许在索引的列中，这个值占每个键的0~1个字节
+ 所有数字键值以高字节优先被存储以允许一个更高的索引压缩
+ 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快
+ 可以把数据文件和索引文件放在不同目录
+ 每个字符列可以有不同的字符集
+ 有VARCHAR的表可以固定或动态记录长度
+ VARCHAR和CHAR列可以多达64KB

使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名体现文件类型：存储表的元数据信息（包括表结构的定义信息）的文件的扩展名为.frm、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名是.MYI（MYIndex）。

##### 存储引擎的选择
在实际工作中，选择一个合适的存储引擎是一个比较复杂的问题。每种存储引擎都有自己的优缺点，不能笼统地说谁比谁好。但建议选择使用InnoDB

| 特性 | InnoDB | MyISAM |
| --- | :---: | :---: |
| 事务安全 | 支持 | 无 |
| 存储限制 | 64TB | 有 |
| 空间使用 | 高 | 低 |
| 内存使用 | 高 | 低 |
| 插入数据的速度 | 低 | 高 |
| 对外键的支持 | 支持 | 无 |

**InnoDB**： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。

**MyISAM**： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。

## 参考链接
[c++面试宝典](https://www.nowcoder.com/tutorial/93/8ac75a692a3b4b0a868796b9f008bc2c)
[SQL视图](https://www.w3school.com.cn/sql/sql_view.asp)
[视图和表的区别](https://www.cnblogs.com/binyao/p/4899970.html)
[Mysql常见的三种存储引擎](https://segmentfault.com/a/1190000012588602)